{"version":3,"file":"\\packages\\spacebars-compiler.js","sources":["spacebars-compiler/tokens.js","spacebars-compiler/tojs.js","spacebars-compiler/templatetag.js","spacebars-compiler/spacebars-compiler.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AACA,kE;AACA,yB;AACA,6kF;AACA,wS;AACA,iuE;AACA,gE;AACA,kgF;AACA,gxB;AACA,2zC;AACA,oU;AACA,mE;AACA,6C;AACA,E;;AAEA,sC;AACA,c;AACA,sE;AACA,E;;AAEA,8C;AACA,6D;AACA,4B;AACA,mC;AACA,wC;AACA,gE;AACA,4E;AACA,U;AACA,gE;AACA,qD;AACA,4D;AACA,8E;AACA,mC;AACA,2E;AACA,sD;;;AAGA,gD;AACA,6C;AACA,iB;AACA,yE;;AAEA,gB;AACA,2B;AACA,yE;AACA,wD;AACA,sD;AACA,qB;AACA,mF;AACA,kC;AACA,uB;AACA,6C;;;AAGA,kC;AACA,6B;;AAEA,yB;AACA,+B;AACA,kB;AACA,sB;AACA,G;AACA,uD;;AAEA,4B;AACA,+D;AACA,gB;AACA,2B;AACA,gB;AACA,G;AACA,2B;AACA,kC;;AAEA,iD;AACA,gC;AACA,wC;AACA,sC;AACA,E;;AAEA,0C;AACA,6B;AACA,4B;AACA,2C;AACA,c;AACA,gB;AACA,iC;AACA,wB;AACA,uB;;AAEA,qB;AACA,sB;;AAEA,yC;AACA,gB;AACA,uB;AACA,qC;AACA,4B;AACA,K;;AAEA,yC;AACA,gB;AACA,uB;AACA,qC;AACA,4B;AACA,K;AACA,G;;AAEA,wD;AACA,E;;AAEA,yC;AACA,6B;AACA,4B;AACA,sC;AACA,c;AACA,gB;;AAEA,uB;AACA,gB;AACA,wB;;AAEA,wB;;AAEA,iB;AACA,qC;AACA,gB;AACA,8B;AACA,Y;AACA,yC;AACA,kB;AACA,2B;AACA,8E;AACA,6E;AACA,2E;AACA,mB;AACA,0B;AACA,mC;AACA,+B;AACA,mE;AACA,mC;AACA,uC;AACA,gD;AACA,gC;AACA,6B;AACA,Y;AACA,6B;AACA,c;AACA,6C;AACA,sB;AACA,0C;AACA,sB;AACA,6B;AACA,8B;AACA,4B;AACA,oC;AACA,+B;AACA,a;AACA,W;AACA,S;AACA,O;AACA,K;AACA,gB;AACA,qC;AACA,4B;AACA,6B;AACA,c;AACA,K;AACA,G;;AAEA,yB;AACA,iD;;AAEA,qB;AACA,4D;AACA,sC;AACA,sC;AACA,E;;AAEA,qB;AACA,gB;AACA,2B;AACA,2C;AACA,wC;AACA,E;;;;;;;;;;;;;;;;;;;;ACtLA,sD;AACA,8B;AACA,oF;AACA,oC;AACA,6B;AACA,iE;AACA,4E;AACA,c;AACA,E;;;;AAIA,yC;AACA,+a;AACA,e;AACA,K;AACA,a;AACA,O;;AAEA,mC;AACA,yE;AACA,a;AACA,wB;AACA,E;;AAEA,kE;AACA,oE;AACA,iE;AACA,yD;AACA,qC;AACA,8C;AACA,mB;AACA,mB;AACA,oB;AACA,+B;AACA,wC;AACA,kD;AACA,uD;AACA,K;AACA,sB;AACA,kD;AACA,G;;AAEA,kD;AACA,uD;AACA,G;;AAEA,6B;AACA,gB;AACA,mC;AACA,gC;AACA,0E;AACA,wC;AACA,4D;AACA,M;AACA,sD;;AAEA,oD;AACA,E;;AAEA,kD;AACA,0D;AACA,+D;AACA,8D;AACA,qD;AACA,+C;AACA,E;;AAEA,kD;AACA,0D;AACA,mD;AACA,+D;AACA,+C;AACA,E;;AAEA,8C;AACA,sD;AACA,mD;AACA,+D;AACA,+C;AACA,E;;AAEA,mD;AACA,oB;AACA,E;;AAEA,sC;AACA,qB;AACA,wB;AACA,kB;AACA,uG;AACA,8D;AACA,6B;AACA,qC;AACA,Y;AACA,mB;AACA,yC;AACA,8C;AACA,wC;AACA,yB;AACA,4B;AACA,8B;AACA,U;AACA,yE;AACA,iE;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AC3GA,iE;AACA,E;AACA,0C;AACA,E;AACA,2B;AACA,6B;AACA,8B;AACA,gC;AACA,+B;AACA,gC;AACA,0B;AACA,E;AACA,iE;AACA,E;AACA,yE;AACA,2E;AACA,oB;AACA,E;AACA,wE;AACA,sE;AACA,2E;AACA,uE;AACA,sC;AACA,E;AACA,gE;AACA,E;AACA,qD;AACA,E;AACA,6E;AACA,yE;AACA,qD;AACA,mC;AACA,E;AACA,sE;AACA,sE;AACA,6B;;AAEA,4D;;AAEA,qD;;AAEA,4C;AACA,oD;AACA,6C;AACA,E;;AAEA,c;AACA,0D;AACA,oD;AACA,sD;AACA,uD;AACA,gD;AACA,2D;AACA,2D;AACA,4D;AACA,E;;AAEA,Y;AACA,qB;AACA,sB;AACA,E;;AAEA,iE;AACA,qE;AACA,iE;AACA,6C;AACA,gD;AACA,gC;AACA,kC;AACA,qD;;AAEA,kC;AACA,gD;AACA,gB;;AAEA,8B;AACA,yC;AACA,4C;AACA,iB;AACA,kB;AACA,wB;AACA,8B;AACA,e;AACA,I;;AAEA,mC;AACA,0B;AACA,I;;AAEA,iD;AACA,0C;AACA,a;AACA,6B;AACA,wB;AACA,2D;AACA,yF;;AAEA,c;AACA,I;;AAEA,8B;AACA,sB;;AAEA,oE;AACA,a;AACA,mC;AACA,4D;AACA,2C;;AAEA,wB;AACA,iC;;AAEA,0D;AACA,0B;AACA,sD;AACA,iD;AACA,gB;AACA,iC;AACA,sC;AACA,S;;AAEA,+B;AACA,6B;AACA,S;;AAEA,iC;;AAEA,yB;AACA,wB;AACA,K;;AAEA,kB;AACA,4B;;AAEA,uB;AACA,qC;AACA,kB;AACA,6C;AACA,+B;AACA,uC;AACA,sD;AACA,2B;AACA,c;AACA,mD;AACA,4B;AACA,kC;AACA,6B;AACA,+B;AACA,kB;AACA,oI;AACA,W;AACA,gB;AACA,4B;AACA,S;AACA,O;;AAEA,+B;AACA,gB;AACA,c;AACA,K;;AAEA,oB;AACA,I;;AAEA,mD;AACA,sC;AACA,kD;AACA,iD;AACA,oC;AACA,oE;AACA,gB;AACA,qC;AACA,sB;AACA,Y;AACA,kB;AACA,K;AACA,I;;AAEA,0C;AACA,8C;AACA,sD;AACA,kB;AACA,6B;AACA,kE;AACA,+B;AACA,mD;AACA,I;;AAEA,kE;AACA,4D;AACA,kC;AACA,+B;AACA,e;AACA,0C;AACA,sC;AACA,wD;AACA,sC;AACA,gD;AACA,kC;AACA,yD;AACA,sB;AACA,0B;AACA,8B;AACA,mD;AACA,0C;AACA,c;AACA,iD;AACA,oC;AACA,O;AACA,Y;AACA,+D;AACA,K;AACA,I;;AAEA,W;;AAEA,8B;AACA,uB;AACA,I;;AAEA,kC;AACA,8B;AACA,I;;AAEA,uD;;AAEA,sC;AACA,+C;AACA,+C;AACA,2D;AACA,iD;AACA,qD;AACA,qD;AACA,uD;AACA,M;AACA,gC;;AAEA,4B;AACA,kB;;AAEA,gC;AACA,4C;AACA,iB;AACA,sC;AACA,0D;AACA,kC;AACA,sC;AACA,iB;AACA,gC;AACA,oC;AACA,qC;AACA,0B;AACA,2B;AACA,uB;AACA,+B;AACA,2B;AACA,uB;AACA,U;AACA,2C;AACA,0B;AACA,kB;AACA,2B;AACA,kB;AACA,kB;AACA,8B;AACA,6B;AACA,gB;AACA,wC;AACA,4B;AACA,c;AACA,6B;AACA,gB;AACA,wC;AACA,2B;AACA,O;AACA,6B;AACA,gC;AACA,0B;AACA,c;AACA,uB;AACA,8E;AACA,O;AACA,4B;;AAEA,mC;AACA,0B;AACA,K;AACA,G;;AAEA,a;AACA,E;;AAEA,yE;AACA,4B;AACA,E;AACA,wE;AACA,wB;AACA,uC;AACA,6B;AACA,0C;AACA,yB;AACA,gB;AACA,E;;AAEA,0E;AACA,0E;AACA,+B;AACA,E;AACA,e;AACA,E;AACA,oE;AACA,E;AACA,sE;AACA,8D;AACA,E;AACA,2E;AACA,wC;AACA,E;AACA,yE;AACA,qE;AACA,gC;AACA,kC;AACA,qD;;AAEA,mD;AACA,kD;AACA,e;AACA,kB;;AAEA,qC;AACA,gB;;AAEA,gC;AACA,gB;;AAEA,6B;AACA,yC;;AAEA,mC;AACA,qD;;AAEA,yD;AACA,iD;AACA,+B;;AAEA,oC;AACA,2B;;AAEA,oE;AACA,uE;AACA,oE;AACA,gB;AACA,0C;;AAEA,wB;AACA,qC;AACA,0D;AACA,wC;AACA,gE;AACA,mE;AACA,wC;AACA,O;AACA,2B;AACA,oD;AACA,yC;AACA,0B;AACA,Q;AACA,qE;;AAEA,4C;AACA,yE;;AAEA,yD;AACA,qE;;AAEA,kC;AACA,mD;AACA,2E;;AAEA,8C;AACA,+D;;AAEA,4B;AACA,2C;AACA,K;;AAEA,wC;AACA,8C;AACA,qC;AACA,8B;AACA,yE;AACA,kC;AACA,O;AACA,Y;AACA,4B;AACA,uE;AACA,kC;AACA,K;AACA,G;;AAEA,6B;AACA,yB;AACA,+B;AACA,yB;;AAEA,gB;AACA,E;;AAEA,+C;AACA,qC;AACA,I;AACA,yE;AACA,kE;AACA,yE;AACA,2C;AACA,iB;AACA,mC;AACA,yD;AACA,6C;AACA,oD;AACA,sD;AACA,E;;AAEA,oE;AACA,mE;AACA,W;AACA,4C;;AAEA,+D;AACA,yB;AACA,2E;AACA,qE;AACA,wB;AACA,yH;AACA,K;AACA,G;;AAEA,gE;AACA,wD;AACA,iC;AACA,a;AACA,2C;AACA,2B;AACA,0B;AACA,oD;AACA,wD;AACA,sD;AACA,wD;AACA,0H;AACA,O;AACA,Y;AACA,qF;AACA,K;AACA,+D;AACA,qC;AACA,8N;AACA,K;AACA,iC;AACA,4L;AACA,K;AACA,G;;AAEA,E;;;;;;;;;;;;;;;;;;;;;;AC3cA,oC;;AAEA,qC;AACA,U;AACA,qD;;AAEA,c;AACA,E;;AAEA,+D;AACA,4D;AACA,oC;;AAEA,gC;;AAEA,4C;AACA,yB;AACA,oD;AACA,qD;AACA,Y;AACA,iC;AACA,K;AACA,I;;AAEA,qC;AACA,4D;AACA,I;;AAEA,sE;AACA,oE;AACA,qE;AACA,4C;AACA,+E;AACA,sB;AACA,sB;AACA,kB;AACA,mD;AACA,6C;AACA,0B;AACA,kC;AACA,8B;AACA,wE;AACA,sB;AACA,qC;AACA,uD;AACA,S;AACA,0B;AACA,c;AACA,gC;AACA,8B;AACA,0E;AACA,qD;AACA,S;AACA,O;AACA,K;AACA,0B;AACA,0E;AACA,+C;AACA,8C;AACA,yC;AACA,gD;AACA,sC;AACA,O;AACA,K;AACA,kB;AACA,I;;AAEA,qD;AACA,uC;AACA,kB;AACA,gC;AACA,kB;;AAEA,6B;AACA,wC;AACA,iD;AACA,sB;AACA,mB;AACA,K;;AAEA,iB;AACA,I;;AAEA,uC;AACA,uE;AACA,wE;AACA,4B;AACA,uD;AACA,2E;AACA,qC;AACA,+D;AACA,kB;AACA,0C;AACA,iC;AACA,mC;AACA,6C;AACA,oD;AACA,2E;AACA,2E;AACA,qB;AACA,oB;AACA,O;;AAEA,+B;;AAEA,2E;AACA,8E;AACA,wE;AACA,0B;AACA,8B;AACA,4B;;AAEA,yC;AACA,+B;AACA,8B;AACA,yD;AACA,gC;AACA,kB;AACA,W;AACA,S;AACA,O;;AAEA,uF;;AAEA,+B;AACA,oB;;AAEA,sE;AACA,gC;;AAEA,oB;;AAEA,uC;AACA,qD;AACA,Y;AACA,kB;AACA,K;AACA,I;;AAEA,oC;AACA,uB;AACA,kC;AACA,mB;;AAEA,wC;;AAEA,iC;AACA,yB;;AAEA,iB;AACA,E;;AAEA,+D;AACA,mC;;AAEA,2B;AACA,gB;AACA,wB;AACA,2B;AACA,mB;AACA,E;;AAEA,qE;AACA,uB;AACA,uC;AACA,uC;AACA,E;;AAEA,8D;AACA,iD;AACA,4C;AACA,kD;AACA,E;;AAEA,yC;AACA,sE;AACA,mE;AACA,kD;AACA,4E;AACA,kC;AACA,U;AACA,gC;AACA,oD;AACA,wE;AACA,uC;AACA,sE;AACA,yE;AACA,sE;AACA,0B;;AAEA,qC;AACA,wD;AACA,kC;AACA,U;AACA,sD;AACA,4E;;AAEA,mF;AACA,qC;AACA,4B;AACA,8E;AACA,8B;AACA,mE;;AAEA,mD;AACA,8E;AACA,2D;AACA,sE;;AAEA,gD;AACA,6B;AACA,0C;;AAEA,6B;AACA,0E;;AAEA,c;AACA,iE;;AAEA,gC;AACA,+C;AACA,gE;AACA,S;;AAEA,mD;AACA,0C;AACA,wC;AACA,gD;;AAEA,qC;AACA,sB;AACA,oC;AACA,0B;AACA,0C;AACA,S;;AAEA,yB;AACA,kE;;AAEA,uB;AACA,uB;AACA,kE;AACA,iE;AACA,S;;AAEA,+B;AACA,sE;AACA,4E;AACA,S;;AAEA,0C;AACA,O;AACA,Y;AACA,gE;AACA,mE;AACA,mE;AACA,K;AACA,G;AACA,E;;AAEA,wC;AACA,iB;AACA,oB;AACA,sD;AACA,sC;AACA,E;;AAEA,6C;AACA,E;AACA,2D;AACA,oD;AACA,E;AACA,8D;AACA,E;AACA,W;AACA,E;AACA,mE;AACA,iE;AACA,kE;AACA,+B;AACA,yC;AACA,kD;AACA,qE;AACA,8E;AACA,8D;AACA,6B;AACA,yB;AACA,oE;AACA,wB;AACA,gE;AACA,+C;AACA,oC;AACA,G;;AAEA,oC;AACA,8B;AACA,uD;AACA,oC;AACA,kE;;AAEA,wB;AACA,2C;AACA,yD;AACA,G;;AAEA,c;AACA,E;;AAEA,6D;AACA,iE;AACA,E;AACA,+D;AACA,0D;AACA,sC;AACA,uB;AACA,wB;;AAEA,c;AACA,oB;AACA,gB;AACA,gB;AACA,iB;AACA,c;AACA,oC;AACA,U;AACA,c;AACA,oC;AACA,U;AACA,U;AACA,qB;AACA,uD;AACA,G;;AAEA,iB;AACA,E;;AAEA,sE;AACA,qE;AACA,mC;AACA,2D;AACA,mC;AACA,0C;AACA,8C;;AAEA,mD;AACA,qD;AACA,E;;AAEA,kD;AACA,e;AACA,8C;AACA,wC;AACA,8B;;AAEA,wB;AACA,kC;AACA,uC;;AAEA,yB;AACA,8D;AACA,8B;AACA,+B;AACA,Y;AACA,4B;AACA,0B;AACA,yB;AACA,K;AACA,K;;AAEA,oD;AACA,e;AACA,wB;AACA,iE;AACA,G;;AAEA,c;AACA,E;;AAEA,4E;AACA,iD;AACA,E;AACA,wD;AACA,+C;AACA,wD;AACA,E;AACA,oD;AACA,4C;AACA,e;;AAEA,yB;AACA,mB;AACA,0D;AACA,G;AACA,6B;AACA,uB;AACA,8D;AACA,G;;AAEA,0B;;AAEA,sB;AACA,sB;AACA,sB;AACA,e;AACA,oC;AACA,yD;AACA,uB;AACA,iC;AACA,0B;AACA,yE;AACA,O;AACA,gD;AACA,qC;AACA,sD;AACA,M;AACA,qE;AACA,yC;AACA,4C;AACA,iC;AACA,mC;AACA,qE;AACA,U;AACA,6D;AACA,mD;AACA,G;;AAEA,gE;;AAEA,a;AACA,E;;;AAGA,+D;AACA,gB;;AAEA,uC;AACA,iC;AACA,4D;AACA,4D;AACA,oE;AACA,8B;AACA,wB;;AAEA,mB;AACA,+C;AACA,qC;AACA,sC;AACA,kD;AACA,S;AACA,S;;AAEA,4D;AACA,oC;AACA,0E;AACA,mD;AACA,W;AACA,O;AACA,K;;AAEA,4B;AACA,kB;AACA,qC;AACA,wC;AACA,iD;AACA,0C;AACA,U;AACA,gB;AACA,G;AACA,E;;AAEA,+C;AACA,oC;AACA,0C;AACA,E;;AAEA,mD;AACA,sD;AACA,wB;AACA,mD;;AAEA,uB;;AAEA,4D;AACA,kD;AACA,4E;AACA,0B;AACA,0B;AACA,G;;AAEA,+B;;AAEA,gD;AACA,mB;AACA,oE;AACA,wD;AACA,kC;AACA,oC;AACA,G;AACA,oB;AACA,0B;AACA,iB;;AAEA,wB;;AAEA,c;AACA,E;;AAEA,gC;AACA,8D;AACA,qC;AACA,mD;AACA,gD;AACA,kD;AACA,2D;AACA,4D;AACA,2D;AACA,6B;AACA,+E;AACA,gC;AACA,sC;AACA,kB;AACA,U;AACA,2C;AACA,gB;AACA,G;AACA,E;;AAEA,mC;AACA,+B","sourcesContent":["\r\n// Adapted from source code of http://xregexp.com/plugins/#unicode\r\nvar unicodeCategories = {\r\n  Ll: \"0061-007A00B500DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F05210523052505270561-05871D00-1D2B1D6B-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7B2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2CF32D00-2D252D272D2DA641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA661A663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CA78EA791A793A7A1A7A3A7A5A7A7A7A9A7FAFB00-FB06FB13-FB17FF41-FF5A\",\r\n  Lm: \"02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D6A1D781D9B-1DBF2071207F2090-209C2C7C2C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A7F8A7F9A9CFAA70AADDAAF3AAF4FF70FF9EFF9F\",\r\n  Lo: \"00AA00BA01BB01C0-01C3029405D0-05EA05F0-05F20620-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150840-085808A008A2-08AC0904-0939093D09500958-09610972-09770979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10CF10CF20D05-0D0C0D0E-0D100D12-0D3A0D3D0D4E0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC-0EDF0F000F40-0F470F49-0F6C0F88-0F8C1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA10FD-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1BBA-1BE51C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF11CF51CF62135-21382D30-2D672D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31BA31F0-31FF3400-4DB54E00-9FCCA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCAAE0-AAEAAAF2AB01-AB06AB09-AB0EAB11-AB16AB20-AB26AB28-AB2EABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC\",\r\n  Lt: \"01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC\",\r\n  Lu: \"0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E05200522052405260531-055610A0-10C510C710CD1E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CED2CF2A640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA660A662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BA78DA790A792A7A0A7A2A7A4A7A6A7A8A7AAFF21-FF3A\",\r\n  Mc: \"0903093B093E-09400949-094C094E094F0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1BAC1BAD1BE71BEA-1BEC1BEE1BF21BF31C24-1C2B1C341C351CE11CF21CF3302E302FA823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BAAEBAAEEAAEFAAF5ABE3ABE4ABE6ABE7ABE9ABEAABEC\",\r\n  Mn: \"0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065F067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0859-085B08E4-08FE0900-0902093A093C0941-0948094D0951-095709620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F8D-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135D-135F1712-17141732-1734175217531772177317B417B517B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91BAB1BE61BE81BE91BED1BEF-1BF11C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1CF41DC0-1DE61DFC-1DFF20D0-20DC20E120E5-20F02CEF-2CF12D7F2DE0-2DFF302A-302D3099309AA66FA674-A67DA69FA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1AAECAAEDAAF6ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26\",\r\n  Nd: \"0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19D91A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19\",\r\n  Nl: \"16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF\",\r\n  Pc: \"005F203F20402054FE33FE34FE4D-FE4FFF3F\"\r\n};\r\n\r\nvar unicodeClass = function (abbrev) {\r\n  return '[' +\r\n    unicodeCategories[abbrev].replace(/[0-9A-F]{4}/ig, \"\\\\u$&\") + ']';\r\n};\r\n\r\n// See ECMA-262 spec, 3rd edition, Section 7.6\r\n// Match one or more characters that can start an identifier.\r\n// This is IdentifierStart+.\r\nvar rIdentifierPrefix = new RegExp(\r\n  \"^([a-zA-Z$_]+|\\\\\\\\u[0-9a-fA-F]{4}|\" +\r\n    [unicodeClass('Lu'), unicodeClass('Ll'), unicodeClass('Lt'),\r\n     unicodeClass('Lm'), unicodeClass('Lo'), unicodeClass('Nl')].join('|') +\r\n    \")+\");\r\n// Match one or more characters that can continue an identifier.\r\n// This is (IdentifierPart and not IdentifierStart)+.\r\n// To match a full identifier, match rIdentifierPrefix, then\r\n// match rIdentifierMiddle followed by rIdentifierPrefix until they both fail.\r\nvar rIdentifierMiddle = new RegExp(\r\n  \"^([0-9]|\" + [unicodeClass('Mn'), unicodeClass('Mc'), unicodeClass('Nd'),\r\n                unicodeClass('Pc')].join('|') + \")+\");\r\n\r\n\r\n// See ECMA-262 spec, 3rd edition, Section 7.8.3\r\nvar rHexLiteral = /^0[xX][0-9a-fA-F]+(?!\\w)/;\r\nvar rDecLiteral =\r\n      /^(((0|[1-9][0-9]*)(\\.[0-9]*)?)|\\.[0-9]+)([Ee][+-]?[0-9]+)?(?!\\w)/;\r\n\r\n// Section 7.8.4\r\nvar rStringQuote = /^[\"']/;\r\n// Match one or more characters besides quotes, backslashes, or line ends\r\nvar rStringMiddle = /^(?=.)[^\"'\\\\]+?((?!.)|(?=[\"'\\\\]))/;\r\n// Match one escape sequence, including the backslash.\r\nvar rEscapeSequence =\r\n      /^\\\\(['\"\\\\bfnrtv]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\r\n// Match one ES5 line continuation\r\nvar rLineContinuation =\r\n      /^\\\\(\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\r\n\r\n\r\nparseNumber = function (scanner) {\r\n  var startPos = scanner.pos;\r\n\r\n  var isNegative = false;\r\n  if (scanner.peek() === '-') {\r\n    scanner.pos++;\r\n    isNegative = true;\r\n  }\r\n  // Note that we allow `\"-0xa\"`, unlike `Number(...)`.\r\n\r\n  var rest = scanner.rest();\r\n  var match = rDecLiteral.exec(rest) || rHexLiteral.exec(rest);\r\n  if (! match) {\r\n    scanner.pos = startPos;\r\n    return null;\r\n  }\r\n  var matchText = match[0];\r\n  scanner.pos += matchText.length;\r\n\r\n  var text = (isNegative ? '-' : '') + matchText;\r\n  var value = Number(matchText);\r\n  value = (isNegative ? -value : value);\r\n  return { text: text, value: value };\r\n};\r\n\r\nparseIdentifierName = function (scanner) {\r\n  var startPos = scanner.pos;\r\n  var rest = scanner.rest();\r\n  var match = rIdentifierPrefix.exec(rest);\r\n  if (! match)\r\n    return null;\r\n  scanner.pos += match[0].length;\r\n  rest = scanner.rest();\r\n  var foundMore = true;\r\n\r\n  while (foundMore) {\r\n    foundMore = false;\r\n\r\n    match = rIdentifierMiddle.exec(rest);\r\n    if (match) {\r\n      foundMore = true;\r\n      scanner.pos += match[0].length;\r\n      rest = scanner.rest();\r\n    }\r\n\r\n    match = rIdentifierPrefix.exec(rest);\r\n    if (match) {\r\n      foundMore = true;\r\n      scanner.pos += match[0].length;\r\n      rest = scanner.rest();\r\n    }\r\n  }\r\n\r\n  return scanner.input.substring(startPos, scanner.pos);\r\n};\r\n\r\nparseStringLiteral = function (scanner) {\r\n  var startPos = scanner.pos;\r\n  var rest = scanner.rest();\r\n  var match = rStringQuote.exec(rest);\r\n  if (! match)\r\n    return null;\r\n\r\n  var quote = match[0];\r\n  scanner.pos++;\r\n  rest = scanner.rest();\r\n\r\n  var jsonLiteral = '\"';\r\n\r\n  while (match) {\r\n    match = rStringMiddle.exec(rest);\r\n    if (match) {\r\n      jsonLiteral += match[0];\r\n    } else {\r\n      match = rEscapeSequence.exec(rest);\r\n      if (match) {\r\n        var esc = match[0];\r\n        // Convert all string escapes to JSON-compatible string escapes, so we\r\n        // can use JSON.parse for some of the work.  JSON strings are not the\r\n        // same as JS strings.  They don't support `\\0`, `\\v`, `\\'`, or hex\r\n        // escapes.\r\n        if (esc === '\\\\0')\r\n          jsonLiteral += '\\\\u0000';\r\n        else if (esc === '\\\\v')\r\n          // Note: IE 8 doesn't correctly parse '\\v' in JavaScript.\r\n          jsonLiteral += '\\\\u000b';\r\n        else if (esc.charAt(1) === 'x')\r\n          jsonLiteral += '\\\\u00' + esc.slice(2);\r\n        else if (esc === '\\\\\\'')\r\n          jsonLiteral += \"'\";\r\n        else\r\n          jsonLiteral += esc;\r\n      } else {\r\n        match = rLineContinuation.exec(rest);\r\n        if (! match) {\r\n          match = rStringQuote.exec(rest);\r\n          if (match) {\r\n            var c = match[0];\r\n            if (c !== quote) {\r\n              if (c === '\"')\r\n                jsonLiteral += '\\\\';\r\n              jsonLiteral += c;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (match) {\r\n      scanner.pos += match[0].length;\r\n      rest = scanner.rest();\r\n      if (match[0] === quote)\r\n        break;\r\n    }\r\n  }\r\n\r\n  if (match[0] !== quote)\r\n    scanner.fatal(\"Unterminated string literal\");\r\n\r\n  jsonLiteral += '\"';\r\n  var text = scanner.input.substring(startPos, scanner.pos);\r\n  var value = JSON.parse(jsonLiteral);\r\n  return { text: text, value: value };\r\n};\r\n\r\n// expose for testing\r\nSpacebars._$ = {\r\n  parseNumber: parseNumber,\r\n  parseIdentifierName: parseIdentifierName,\r\n  parseStringLiteral: parseStringLiteral\r\n};\r\n","\r\n// Turns any JSONable value into a JavaScript literal.\r\ntoJSLiteral = function (obj) {\r\n  // See <http://timelessrepo.com/json-isnt-a-javascript-subset> for `\\u2028\\u2029`.\r\n  // Also escape Unicode surrogates.\r\n  return (JSON.stringify(obj)\r\n          .replace(/[\\u2028\\u2029\\ud800-\\udfff]/g, function (c) {\r\n            return '\\\\u' + ('000' + c.charCodeAt(0).toString(16)).slice(-4);\r\n          }));\r\n};\r\n\r\n\r\n\r\nvar jsReservedWordSet = (function (set) {\r\n  _.each(\"abstract else instanceof super boolean enum int switch break export interface synchronized byte extends let this case false long throw catch final native throws char finally new transient class float null true const for package try continue function private typeof debugger goto protected var default if public void delete implements return volatile do import short while double in static with\".split(' '), function (w) {\r\n    set[w] = 1;\r\n  });\r\n  return set;\r\n})({});\r\n\r\ntoObjectLiteralKey = function (k) {\r\n  if (/^[a-zA-Z$_][a-zA-Z$0-9_]*$/.test(k) && jsReservedWordSet[k] !== 1)\r\n    return k;\r\n  return toJSLiteral(k);\r\n};\r\n\r\n// This method is generic, i.e. it can be transplanted to non-Tags\r\n// and it will still work by accessing `this.tagName`, `this.attrs`,\r\n// and `this.children`.  It's ok if `this.attrs` has content that\r\n// isn't allowed in an attribute (this feature is used by\r\n// HTMLTools.Special.prototype.toJS).\r\nHTML.Tag.prototype.toJS = function (options) {\r\n  var argStrs = [];\r\n  if (this.attrs) {\r\n    var kvStrs = [];\r\n    for (var k in this.attrs) {\r\n      if (! HTML.isNully(this.attrs[k]))\r\n        kvStrs.push(toObjectLiteralKey(k) + ': ' +\r\n                    HTML.toJS(this.attrs[k], options));\r\n    }\r\n    if (kvStrs.length)\r\n      argStrs.push('{' + kvStrs.join(', ') + '}');\r\n  }\r\n\r\n  for (var i = 0; i < this.children.length; i++) {\r\n    argStrs.push(HTML.toJS(this.children[i], options));\r\n  }\r\n\r\n  var tagName = this.tagName;\r\n  var tagSymbol;\r\n  if (! (this instanceof HTML.Tag))\r\n    // a CharRef or Comment, say\r\n    tagSymbol = (tagName.indexOf('.') >= 0 ? tagName : 'HTML.' + tagName);\r\n  else if (! HTML.isTagEnsured(tagName))\r\n    tagSymbol = 'HTML.getTag(' + toJSLiteral(tagName) + ')';\r\n  else\r\n    tagSymbol = 'HTML.' + HTML.getSymbolName(tagName);\r\n\r\n  return tagSymbol + '(' + argStrs.join(', ') + ')';\r\n};\r\n\r\nHTML.CharRef.prototype.toJS = function (options) {\r\n  return HTML.Tag.prototype.toJS.call({tagName: \"CharRef\",\r\n                                       attrs: {html: this.html,\r\n                                               str: this.str},\r\n                                       children: []},\r\n                                      options);\r\n};\r\n\r\nHTML.Comment.prototype.toJS = function (options) {\r\n  return HTML.Tag.prototype.toJS.call({tagName: \"Comment\",\r\n                                       attrs: null,\r\n                                       children: [this.value]},\r\n                                      options);\r\n};\r\n\r\nHTML.Raw.prototype.toJS = function (options) {\r\n  return HTML.Tag.prototype.toJS.call({tagName: \"Raw\",\r\n                                       attrs: null,\r\n                                       children: [this.value]},\r\n                                      options);\r\n};\r\n\r\nHTML.EmitCode.prototype.toJS = function (options) {\r\n  return this.value;\r\n};\r\n\r\nHTML.toJS = function (node, options) {\r\n  if (node == null) {\r\n    // null or undefined\r\n    return 'null';\r\n  } else if ((typeof node === 'string') || (typeof node === 'boolean') || (typeof node === 'number')) {\r\n    // string (or something that will be rendered as a string)\r\n    return toJSLiteral(node);\r\n  } else if (node instanceof Array) {\r\n    // array\r\n    var parts = [];\r\n    for (var i = 0; i < node.length; i++)\r\n      parts.push(HTML.toJS(node[i], options));\r\n    return '[' + parts.join(', ') + ']';\r\n  } else if (node.toJS) {\r\n    // Tag or something else\r\n    return node.toJS(options);\r\n  } else {\r\n    throw new Error(\"Expected tag, string, array, null, undefined, or \" +\r\n                    \"object with a toJS method; found: \" + node);\r\n  }\r\n};\r\n","// A TemplateTag is the result of parsing a single `{{...}}` tag.\r\n//\r\n// The `.type` of a TemplateTag is one of:\r\n//\r\n// - `\"DOUBLE\"` - `{{foo}}`\r\n// - `\"TRIPLE\"` - `{{{foo}}}`\r\n// - `\"COMMENT\"` - `{{! foo}}`\r\n// - `\"INCLUSION\"` - `{{> foo}}`\r\n// - `\"BLOCKOPEN\"` - `{{#foo}}`\r\n// - `\"BLOCKCLOSE\"` - `{{/foo}}`\r\n// - `\"ELSE\"` - `{{else}}`\r\n//\r\n// Besides `type`, the mandatory properties of a TemplateTag are:\r\n//\r\n// - `path` - An array of one or more strings.  The path of `{{foo.bar}}`\r\n//   is `[\"foo\", \"bar\"]`.  Applies to DOUBLE, TRIPLE, INCLUSION, BLOCKOPEN,\r\n//   and BLOCKCLOSE.\r\n//\r\n// - `args` - An array of zero or more argument specs.  An argument spec\r\n//   is a two or three element array, consisting of a type, value, and\r\n//   optional keyword name.  For example, the `args` of `{{foo \"bar\" x=3}}`\r\n//   are `[[\"STRING\", \"bar\"], [\"NUMBER\", 3, \"x\"]]`.  Applies to DOUBLE,\r\n//   TRIPLE, INCLUSION, and BLOCKOPEN.\r\n//\r\n// - `value` - For COMMENT tags, a string of the comment's text.\r\n//\r\n// These additional are typically set during parsing:\r\n//\r\n// - `position` - The HTMLTools.TEMPLATE_TAG_POSITION specifying at what sort\r\n//   of site the TemplateTag was encountered (e.g. at element level or as\r\n//   part of an attribute value). Its absence implies\r\n//   TEMPLATE_TAG_POSITION.ELEMENT.\r\n//\r\n// - `content` and `elseContent` - When a BLOCKOPEN tag's contents are\r\n//   parsed, they are put here.  `elseContent` will only be present if\r\n//   an `{{else}}` was found.\r\n\r\nvar TEMPLATE_TAG_POSITION = HTMLTools.TEMPLATE_TAG_POSITION;\r\n\r\nTemplateTag = Spacebars.TemplateTag = function () {};\r\n\r\nvar makeStacheTagStartRegex = function (r) {\r\n  return new RegExp(r.source + /(?![{>!#/])/.source,\r\n                    r.ignoreCase ? 'i' : '');\r\n};\r\n\r\nvar starts = {\r\n  ELSE: makeStacheTagStartRegex(/^\\{\\{\\s*else(?=[\\s}])/i),\r\n  DOUBLE: makeStacheTagStartRegex(/^\\{\\{\\s*(?!\\s)/),\r\n  TRIPLE: makeStacheTagStartRegex(/^\\{\\{\\{\\s*(?!\\s)/),\r\n  BLOCKCOMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!--/),\r\n  COMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!/),\r\n  INCLUSION: makeStacheTagStartRegex(/^\\{\\{\\s*>\\s*(?!\\s)/),\r\n  BLOCKOPEN: makeStacheTagStartRegex(/^\\{\\{\\s*#\\s*(?!\\s)/),\r\n  BLOCKCLOSE: makeStacheTagStartRegex(/^\\{\\{\\s*\\/\\s*(?!\\s)/)\r\n};\r\n\r\nvar ends = {\r\n  DOUBLE: /^\\s*\\}\\}/,\r\n  TRIPLE: /^\\s*\\}\\}\\}/\r\n};\r\n\r\n// Parse a tag from the provided scanner or string.  If the input\r\n// doesn't start with `{{`, returns null.  Otherwise, either succeeds\r\n// and returns a Spacebars.TemplateTag, or throws an error (using\r\n// `scanner.fatal` if a scanner is provided).\r\nTemplateTag.parse = function (scannerOrString) {\r\n  var scanner = scannerOrString;\r\n  if (typeof scanner === 'string')\r\n    scanner = new HTMLTools.Scanner(scannerOrString);\r\n\r\n  if (! (scanner.peek() === '{' &&\r\n         (scanner.rest()).slice(0, 2) === '{{'))\r\n    return null;\r\n\r\n  var run = function (regex) {\r\n    // regex is assumed to start with `^`\r\n    var result = regex.exec(scanner.rest());\r\n    if (! result)\r\n      return null;\r\n    var ret = result[0];\r\n    scanner.pos += ret.length;\r\n    return ret;\r\n  };\r\n\r\n  var advance = function (amount) {\r\n    scanner.pos += amount;\r\n  };\r\n\r\n  var scanIdentifier = function (isFirstInPath) {\r\n    var id = parseIdentifierName(scanner);\r\n    if (! id)\r\n      expected('IDENTIFIER');\r\n    if (isFirstInPath &&\r\n        (id === 'null' || id === 'true' || id === 'false'))\r\n      scanner.fatal(\"Can't use null, true, or false, as an identifier at start of path\");\r\n\r\n    return id;\r\n  };\r\n\r\n  var scanPath = function () {\r\n    var segments = [];\r\n\r\n    // handle initial `.`, `..`, `./`, `../`, `../..`, `../../`, etc\r\n    var dots;\r\n    if ((dots = run(/^[\\.\\/]+/))) {\r\n      var ancestorStr = '.'; // eg `../../..` maps to `....`\r\n      var endsWithSlash = /\\/$/.test(dots);\r\n\r\n      if (endsWithSlash)\r\n        dots = dots.slice(0, -1);\r\n\r\n      _.each(dots.split('/'), function(dotClause, index) {\r\n        if (index === 0) {\r\n          if (dotClause !== '.' && dotClause !== '..')\r\n            expected(\"`.`, `..`, `./` or `../`\");\r\n        } else {\r\n          if (dotClause !== '..')\r\n            expected(\"`..` or `../`\");\r\n        }\r\n\r\n        if (dotClause === '..')\r\n          ancestorStr += '.';\r\n      });\r\n\r\n      segments.push(ancestorStr);\r\n\r\n      if (!endsWithSlash)\r\n        return segments;\r\n    }\r\n\r\n    while (true) {\r\n      // scan a path segment\r\n\r\n      if (run(/^\\[/)) {\r\n        var seg = run(/^[\\s\\S]*?\\]/);\r\n        if (! seg)\r\n          error(\"Unterminated path segment\");\r\n        seg = seg.slice(0, -1);\r\n        if (! seg && ! segments.length)\r\n          error(\"Path can't start with empty string\");\r\n        segments.push(seg);\r\n      } else {\r\n        var id = scanIdentifier(! segments.length);\r\n        if (id === 'this') {\r\n          if (! segments.length) {\r\n            // initial `this`\r\n            segments.push('.');\r\n          } else {\r\n            error(\"Can only use `this` at the beginning of a path.\\nInstead of `foo.this` or `../this`, just write `foo` or `..`.\");\r\n          }\r\n        } else {\r\n          segments.push(id);\r\n        }\r\n      }\r\n\r\n      var sep = run(/^[\\.\\/]/);\r\n      if (! sep)\r\n        break;\r\n    }\r\n\r\n    return segments;\r\n  };\r\n\r\n  // scan the keyword portion of a keyword argument\r\n  // (the \"foo\" portion in \"foo=bar\").\r\n  // Result is either the keyword matched, or null\r\n  // if we're not at a keyword argument position.\r\n  var scanArgKeyword = function () {\r\n    var match = /^([^\\{\\}\\(\\)\\>#=\\s]+)\\s*=\\s*/.exec(scanner.rest());\r\n    if (match) {\r\n      scanner.pos += match[0].length;\r\n      return match[1];\r\n    } else {\r\n      return null;\r\n    }\r\n  };\r\n\r\n  // scan an argument; succeeds or errors.\r\n  // Result is an array of two or three items:\r\n  // type , value, and (indicating a keyword argument)\r\n  // keyword name.\r\n  var scanArg = function () {\r\n    var keyword = scanArgKeyword(); // null if not parsing a kwarg\r\n    var value = scanArgValue();\r\n    return keyword ? value.concat(keyword) : value;\r\n  };\r\n\r\n  // scan an argument value (for keyword or positional arguments);\r\n  // succeeds or errors.  Result is an array of type, value.\r\n  var scanArgValue = function () {\r\n    var startPos = scanner.pos;\r\n    var result;\r\n    if ((result = parseNumber(scanner))) {\r\n      return ['NUMBER', result.value];\r\n    } else if ((result = parseStringLiteral(scanner))) {\r\n      return ['STRING', result.value];\r\n    } else if (/^[\\.\\[]/.test(scanner.peek())) {\r\n      return ['PATH', scanPath()];\r\n    } else if ((result = parseIdentifierName(scanner))) {\r\n      var id = result;\r\n      if (id === 'null') {\r\n        return ['NULL', null];\r\n      } else if (id === 'true' || id === 'false') {\r\n        return ['BOOLEAN', id === 'true'];\r\n      } else {\r\n        scanner.pos = startPos; // unconsume `id`\r\n        return ['PATH', scanPath()];\r\n      }\r\n    } else {\r\n      expected('identifier, number, string, boolean, or null');\r\n    }\r\n  };\r\n\r\n  var type;\r\n\r\n  var error = function (msg) {\r\n    scanner.fatal(msg);\r\n  };\r\n\r\n  var expected = function (what) {\r\n    error('Expected ' + what);\r\n  };\r\n\r\n  // must do ELSE first; order of others doesn't matter\r\n\r\n  if (run(starts.ELSE)) type = 'ELSE';\r\n  else if (run(starts.DOUBLE)) type = 'DOUBLE';\r\n  else if (run(starts.TRIPLE)) type = 'TRIPLE';\r\n  else if (run(starts.BLOCKCOMMENT)) type = 'BLOCKCOMMENT';\r\n  else if (run(starts.COMMENT)) type = 'COMMENT';\r\n  else if (run(starts.INCLUSION)) type = 'INCLUSION';\r\n  else if (run(starts.BLOCKOPEN)) type = 'BLOCKOPEN';\r\n  else if (run(starts.BLOCKCLOSE)) type = 'BLOCKCLOSE';\r\n  else\r\n    error('Unknown stache tag');\r\n\r\n  var tag = new TemplateTag;\r\n  tag.type = type;\r\n\r\n  if (type === 'BLOCKCOMMENT') {\r\n    var result = run(/^[\\s\\S]*?--\\s*?\\}\\}/);\r\n    if (! result)\r\n      error(\"Unclosed block comment\");\r\n    tag.value = result.slice(0, result.lastIndexOf('--'));\r\n  } else if (type === 'COMMENT') {\r\n    var result = run(/^[\\s\\S]*?\\}\\}/);\r\n    if (! result)\r\n      error(\"Unclosed comment\");\r\n    tag.value = result.slice(0, -2);\r\n  } else if (type === 'BLOCKCLOSE') {\r\n    tag.path = scanPath();\r\n    if (! run(ends.DOUBLE))\r\n      expected('`}}`');\r\n  } else if (type === 'ELSE') {\r\n    if (! run(ends.DOUBLE))\r\n      expected('`}}`');\r\n  } else {\r\n    // DOUBLE, TRIPLE, BLOCKOPEN, INCLUSION\r\n    tag.path = scanPath();\r\n    tag.args = [];\r\n    var foundKwArg = false;\r\n    while (true) {\r\n      run(/^\\s*/);\r\n      if (type === 'TRIPLE') {\r\n        if (run(ends.TRIPLE))\r\n          break;\r\n        else if (scanner.peek() === '}')\r\n          expected('`}}}`');\r\n      } else {\r\n        if (run(ends.DOUBLE))\r\n          break;\r\n        else if (scanner.peek() === '}')\r\n          expected('`}}`');\r\n      }\r\n      var newArg = scanArg();\r\n      if (newArg.length === 3) {\r\n        foundKwArg = true;\r\n      } else {\r\n        if (foundKwArg)\r\n          error(\"Can't have a non-keyword argument after a keyword argument\");\r\n      }\r\n      tag.args.push(newArg);\r\n\r\n      if (run(/^(?=[\\s}])/) !== '')\r\n        expected('space');\r\n    }\r\n  }\r\n\r\n  return tag;\r\n};\r\n\r\n// Returns a Spacebars.TemplateTag parsed from `scanner`, leaving scanner\r\n// at its original position.\r\n//\r\n// An error will still be thrown if there is not a valid template tag at\r\n// the current position.\r\nTemplateTag.peek = function (scanner) {\r\n  var startPos = scanner.pos;\r\n  var result = TemplateTag.parse(scanner);\r\n  scanner.pos = startPos;\r\n  return result;\r\n};\r\n\r\n// Like `TemplateTag.parse`, but in the case of blocks, parse the complete\r\n// `{{#foo}}...{{/foo}}` with `content` and possible `elseContent`, rather\r\n// than just the BLOCKOPEN tag.\r\n//\r\n// In addition:\r\n//\r\n// - Throws an error if `{{else}}` or `{{/foo}}` tag is encountered.\r\n//\r\n// - Returns `null` for a COMMENT.  (This case is distinguishable from\r\n//   parsing no tag by the fact that the scanner is advanced.)\r\n//\r\n// - Takes an HTMLTools.TEMPLATE_TAG_POSITION `position` and sets it as the\r\n//   TemplateTag's `.position` property.\r\n//\r\n// - Validates the tag's well-formedness and legality at in its position.\r\nTemplateTag.parseCompleteTag = function (scannerOrString, position) {\r\n  var scanner = scannerOrString;\r\n  if (typeof scanner === 'string')\r\n    scanner = new HTMLTools.Scanner(scannerOrString);\r\n\r\n  var startPos = scanner.pos; // for error messages\r\n  var result = TemplateTag.parse(scannerOrString);\r\n  if (! result)\r\n    return result;\r\n\r\n  if (result.type === 'BLOCKCOMMENT')\r\n    return null;\r\n\r\n  if (result.type === 'COMMENT')\r\n    return null;\r\n\r\n  if (result.type === 'ELSE')\r\n    scanner.fatal(\"Unexpected {{else}}\");\r\n\r\n  if (result.type === 'BLOCKCLOSE')\r\n    scanner.fatal(\"Unexpected closing template tag\");\r\n\r\n  position = (position || TEMPLATE_TAG_POSITION.ELEMENT);\r\n  if (position !== TEMPLATE_TAG_POSITION.ELEMENT)\r\n    result.position = position;\r\n\r\n  if (result.type === 'BLOCKOPEN') {\r\n    // parse block contents\r\n\r\n    // Construct a string version of `.path` for comparing start and\r\n    // end tags.  For example, `foo/[0]` was parsed into `[\"foo\", \"0\"]`\r\n    // and now becomes `foo,0`.  This form may also show up in error\r\n    // messages.\r\n    var blockName = result.path.join(',');\r\n\r\n    var textMode = null;\r\n      if (blockName === 'markdown' ||\r\n          position === TEMPLATE_TAG_POSITION.IN_RAWTEXT) {\r\n        textMode = HTML.TEXTMODE.STRING;\r\n      } else if (position === TEMPLATE_TAG_POSITION.IN_RCDATA ||\r\n                 position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\r\n        textMode = HTML.TEXTMODE.RCDATA;\r\n      }\r\n      var parserOptions = {\r\n        getSpecialTag: TemplateTag.parseCompleteTag,\r\n        shouldStop: isAtBlockCloseOrElse,\r\n        textMode: textMode\r\n      };\r\n    result.content = HTMLTools.parseFragment(scanner, parserOptions);\r\n\r\n    if (scanner.rest().slice(0, 2) !== '{{')\r\n      scanner.fatal(\"Expected {{else}} or block close for \" + blockName);\r\n\r\n    var lastPos = scanner.pos; // save for error messages\r\n    var tmplTag = TemplateTag.parse(scanner); // {{else}} or {{/foo}}\r\n\r\n    if (tmplTag.type === 'ELSE') {\r\n      // parse {{else}} and content up to close tag\r\n      result.elseContent = HTMLTools.parseFragment(scanner, parserOptions);\r\n\r\n      if (scanner.rest().slice(0, 2) !== '{{')\r\n        scanner.fatal(\"Expected block close for \" + blockName);\r\n\r\n      lastPos = scanner.pos;\r\n      tmplTag = TemplateTag.parse(scanner);\r\n    }\r\n\r\n    if (tmplTag.type === 'BLOCKCLOSE') {\r\n      var blockName2 = tmplTag.path.join(',');\r\n      if (blockName !== blockName2) {\r\n        scanner.pos = lastPos;\r\n        scanner.fatal('Expected tag to close ' + blockName + ', found ' +\r\n                      blockName2);\r\n      }\r\n    } else {\r\n      scanner.pos = lastPos;\r\n      scanner.fatal('Expected tag to close ' + blockName + ', found ' +\r\n                    tmplTag.type);\r\n    }\r\n  }\r\n\r\n  var finalPos = scanner.pos;\r\n  scanner.pos = startPos;\r\n  validateTag(result, scanner);\r\n  scanner.pos = finalPos;\r\n\r\n  return result;\r\n};\r\n\r\nvar isAtBlockCloseOrElse = function (scanner) {\r\n  // Detect `{{else}}` or `{{/foo}}`.\r\n  //\r\n  // We do as much work ourselves before deferring to `TemplateTag.peek`,\r\n  // for efficiency (we're called for every input token) and to be\r\n  // less obtrusive, because `TemplateTag.peek` will throw an error if it\r\n  // sees `{{` followed by a malformed tag.\r\n  var rest, type;\r\n  return (scanner.peek() === '{' &&\r\n          (rest = scanner.rest()).slice(0, 2) === '{{' &&\r\n          /^\\{\\{\\s*(\\/|else\\b)/.test(rest) &&\r\n          (type = TemplateTag.peek(scanner).type) &&\r\n          (type === 'BLOCKCLOSE' || type === 'ELSE'));\r\n};\r\n\r\n// Validate that `templateTag` is correctly formed and legal for its\r\n// HTML position.  Use `scanner` to report errors. On success, does\r\n// nothing.\r\nvar validateTag = function (ttag, scanner) {\r\n\r\n  if (ttag.type === 'INCLUSION' || ttag.type === 'BLOCKOPEN') {\r\n    var args = ttag.args;\r\n    if (args.length > 1 && args[0].length === 2 && args[0][0] !== 'PATH') {\r\n      // we have a positional argument that is not a PATH followed by\r\n      // other arguments\r\n      scanner.fatal(\"First argument must be a function, to be called on the rest of the arguments; found \" + args[0][0]);\r\n    }\r\n  }\r\n\r\n  var position = ttag.position || TEMPLATE_TAG_POSITION.ELEMENT;\r\n  if (position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\r\n    if (ttag.type === 'DOUBLE') {\r\n      return;\r\n    } else if (ttag.type === 'BLOCKOPEN') {\r\n      var path = ttag.path;\r\n      var path0 = path[0];\r\n      if (! (path.length === 1 && (path0 === 'if' ||\r\n                                   path0 === 'unless' ||\r\n                                   path0 === 'with' ||\r\n                                   path0 === 'each'))) {\r\n        scanner.fatal(\"Custom block helpers are not allowed in an HTML attribute, only built-in ones like #each and #if\");\r\n      }\r\n    } else {\r\n      scanner.fatal(ttag.type + \" template tag is not allowed in an HTML attribute\");\r\n    }\r\n  } else if (position === TEMPLATE_TAG_POSITION.IN_START_TAG) {\r\n    if (! (ttag.type === 'DOUBLE')) {\r\n      scanner.fatal(\"Reactive HTML attributes must either have a constant name or consist of a single {{helper}} providing a dictionary of names and values.  A template tag of type \" + ttag.type + \" is not allowed here.\");\r\n    }\r\n    if (scanner.peek() === '=') {\r\n      scanner.fatal(\"Template tags are not allowed in attribute names, only in attribute values or in the form of a single {{helper}} that evaluates to a dictionary of name=value pairs.\");\r\n    }\r\n  }\r\n\r\n};\r\n","\r\n\r\n\r\nSpacebars.parse = function (input) {\r\n\r\n  var tree = HTMLTools.parseFragment(\r\n    input,\r\n    { getSpecialTag: TemplateTag.parseCompleteTag });\r\n\r\n  return tree;\r\n};\r\n\r\n// ============================================================\r\n// Optimizer for optimizing HTMLjs into raw HTML string when\r\n// it doesn't contain template tags.\r\n\r\nvar optimize = function (tree) {\r\n\r\n  var pushRawHTML = function (array, html) {\r\n    var N = array.length;\r\n    if (N > 0 && (array[N-1] instanceof HTML.Raw)) {\r\n      array[N-1] = HTML.Raw(array[N-1].value + html);\r\n    } else {\r\n      array.push(HTML.Raw(html));\r\n    }\r\n  };\r\n\r\n  var isPureChars = function (html) {\r\n    return (html.indexOf('&') < 0 && html.indexOf('<') < 0);\r\n  };\r\n\r\n  // Returns `null` if no specials are found in the array, so that the\r\n  // parent can perform the actual optimization.  Otherwise, returns\r\n  // an array of parts which have been optimized as much as possible.\r\n  // `forceOptimize` forces the latter case.\r\n  var optimizeArrayParts = function (array, optimizePartsFunc, forceOptimize) {\r\n    var result = null;\r\n    if (forceOptimize)\r\n      result = [];\r\n    for (var i = 0, N = array.length; i < N; i++) {\r\n      var part = optimizePartsFunc(array[i]);\r\n      if (part !== null) {\r\n        // something special found\r\n        if (result === null) {\r\n          // This is our first special item.  Stringify the other parts.\r\n          result = [];\r\n          for (var j = 0; j < i; j++)\r\n            pushRawHTML(result, HTML.toHTML(array[j]));\r\n        }\r\n        result.push(part);\r\n      } else {\r\n        // just plain HTML found\r\n        if (result !== null) {\r\n          // we've already found something special, so convert this to Raw\r\n          pushRawHTML(result, HTML.toHTML(array[i]));\r\n        }\r\n      }\r\n    }\r\n    if (result !== null) {\r\n      // clean up unnecessary HTML.Raw wrappers around pure character data\r\n      for (var j = 0; j < result.length; j++) {\r\n        if ((result[j] instanceof HTML.Raw) &&\r\n            isPureChars(result[j].value))\r\n          // replace HTML.Raw with simple string\r\n          result[j] = result[j].value;\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n\r\n  var doesAttributeValueHaveSpecials = function (v) {\r\n    if (v instanceof HTMLTools.Special)\r\n      return true;\r\n    if (typeof v === 'function')\r\n      return true;\r\n\r\n    if (v instanceof Array) {\r\n      for (var i = 0; i < v.length; i++)\r\n        if (doesAttributeValueHaveSpecials(v[i]))\r\n          return true;\r\n      return false;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  var optimizeParts = function (node) {\r\n    // If we have nothing special going on, returns `null` (so that the\r\n    // parent can optimize).  Otherwise returns a replacement for `node`\r\n    // with optimized parts.\r\n    if ((node == null) || (typeof node === 'string') ||\r\n        (node instanceof HTML.CharRef) || (node instanceof HTML.Comment) ||\r\n        (node instanceof HTML.Raw)) {\r\n      // not special; let parent decide how whether to optimize\r\n      return null;\r\n    } else if (node instanceof HTML.Tag) {\r\n      var tagName = node.tagName;\r\n      if (tagName === 'textarea' ||\r\n          (! (HTML.isKnownElement(tagName) &&\r\n              ! HTML.isKnownSVGElement(tagName)))) {\r\n        // optimizing into a TEXTAREA's RCDATA would require being a little\r\n        // more clever.  foreign elements like SVG can't be stringified for\r\n        // innerHTML.\r\n        return node;\r\n      }\r\n\r\n      var mustOptimize = false;\r\n\r\n      // Avoid ever producing HTML containing `<table><tr>...`, because the\r\n      // browser will insert a TBODY.  If we just `createElement(\"table\")` and\r\n      // `createElement(\"tr\")`, on the other hand, no TBODY is necessary\r\n      // (assuming IE 8+).\r\n      if (tagName === 'table')\r\n        mustOptimize = true;\r\n\r\n      if (node.attrs && ! mustOptimize) {\r\n        var attrs = node.attrs;\r\n        for (var k in attrs) {\r\n          if (doesAttributeValueHaveSpecials(attrs[k])) {\r\n            mustOptimize = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      var newChildren = optimizeArrayParts(node.children, optimizeParts, mustOptimize);\r\n\r\n      if (newChildren === null)\r\n        return null;\r\n\r\n      var newTag = HTML.getTag(node.tagName).apply(null, newChildren);\r\n      newTag.attrs = node.attrs;\r\n\r\n      return newTag;\r\n\r\n    } else if (node instanceof Array) {\r\n      return optimizeArrayParts(node, optimizeParts);\r\n    } else {\r\n      return node;\r\n    }\r\n  };\r\n\r\n  var optTree = optimizeParts(tree);\r\n  if (optTree !== null)\r\n    // tree was optimized in parts\r\n    return optTree;\r\n\r\n  optTree = HTML.Raw(HTML.toHTML(tree));\r\n\r\n  if (isPureChars(optTree.value))\r\n    return optTree.value;\r\n\r\n  return optTree;\r\n};\r\n\r\n// ============================================================\r\n// Code-generation of template tags\r\n\r\nvar builtInBlockHelpers = {\r\n  'if': 'UI.If',\r\n  'unless': 'UI.Unless',\r\n  'with': 'Spacebars.With',\r\n  'each': 'UI.Each'\r\n};\r\n\r\n// These must be prefixed with `UI.` when you use them in a template.\r\nvar builtInLexicals = {\r\n  'contentBlock': 'template.__content',\r\n  'elseBlock': 'template.__elseContent'\r\n};\r\n\r\n// A \"reserved name\" can't be used as a <template> name.  This\r\n// function is used by the template file scanner.\r\nSpacebars.isReservedName = function (name) {\r\n  return builtInBlockHelpers.hasOwnProperty(name);\r\n};\r\n\r\nvar codeGenTemplateTag = function (tag) {\r\n  if (tag.position === HTMLTools.TEMPLATE_TAG_POSITION.IN_START_TAG) {\r\n    // only `tag.type === 'DOUBLE'` allowed (by earlier validation)\r\n    return HTML.EmitCode('function () { return ' +\r\n                         codeGenMustache(tag.path, tag.args, 'attrMustache')\r\n                         + '; }');\r\n  } else {\r\n    if (tag.type === 'DOUBLE') {\r\n      return HTML.EmitCode('function () { return ' +\r\n                           codeGenMustache(tag.path, tag.args) + '; }');\r\n    } else if (tag.type === 'TRIPLE') {\r\n      return HTML.EmitCode('function () { return Spacebars.makeRaw(' +\r\n                           codeGenMustache(tag.path, tag.args) + '); }');\r\n    } else if (tag.type === 'INCLUSION' || tag.type === 'BLOCKOPEN') {\r\n      var path = tag.path;\r\n\r\n      if (tag.type === 'BLOCKOPEN' &&\r\n          builtInBlockHelpers.hasOwnProperty(path[0])) {\r\n        // if, unless, with, each.\r\n        //\r\n        // If someone tries to do `{{> if}}`, we don't\r\n        // get here, but an error is thrown when we try to codegen the path.\r\n\r\n        // Note: If we caught these errors earlier, while scanning, we'd be able to\r\n        // provide nice line numbers.\r\n        if (path.length > 1)\r\n          throw new Error(\"Unexpected dotted path beginning with \" + path[0]);\r\n        if (! tag.args.length)\r\n          throw new Error(\"#\" + path[0] + \" requires an argument\");\r\n\r\n        var codeParts = codeGenInclusionParts(tag);\r\n        var dataFunc = codeParts.dataFunc; // must exist (tag.args.length > 0)\r\n        var contentBlock = codeParts.content; // must exist\r\n        var elseContentBlock = codeParts.elseContent; // may not exist\r\n\r\n        var callArgs = [dataFunc, contentBlock];\r\n        if (elseContentBlock)\r\n          callArgs.push(elseContentBlock);\r\n\r\n        return HTML.EmitCode(\r\n          builtInBlockHelpers[path[0]] + '(' + callArgs.join(', ') + ')');\r\n\r\n      } else {\r\n        var compCode = codeGenPath(path, {lookupTemplate: true});\r\n\r\n        if (path.length !== 1) {\r\n          // path code may be reactive; wrap it\r\n          compCode = 'function () { return ' + compCode + '; }';\r\n        }\r\n\r\n        var codeParts = codeGenInclusionParts(tag);\r\n        var dataFunc = codeParts.dataFunc;\r\n        var content = codeParts.content;\r\n        var elseContent = codeParts.elseContent;\r\n\r\n        var includeArgs = [compCode];\r\n        if (content) {\r\n          includeArgs.push(content);\r\n          if (elseContent)\r\n            includeArgs.push(elseContent);\r\n        }\r\n\r\n        var includeCode =\r\n              'Spacebars.include(' + includeArgs.join(', ') + ')';\r\n\r\n        if (dataFunc) {\r\n          includeCode =\r\n            'Spacebars.TemplateWith(' + dataFunc + ', UI.block(' +\r\n            Spacebars.codeGen(HTML.EmitCode(includeCode)) + '))';\r\n        }\r\n\r\n        if (path[0] === 'UI' &&\r\n            (path[1] === 'contentBlock' || path[1] === 'elseBlock')) {\r\n          includeCode = 'UI.InTemplateScope(template, ' + includeCode + ')';\r\n        }\r\n\r\n        return HTML.EmitCode(includeCode);\r\n      }\r\n    } else {\r\n      // Can't get here; TemplateTag validation should catch any\r\n      // inappropriate tag types that might come out of the parser.\r\n      throw new Error(\"Unexpected template tag type: \" + tag.type);\r\n    }\r\n  }\r\n};\r\n\r\nvar makeObjectLiteral = function (obj) {\r\n  var parts = [];\r\n  for (var k in obj)\r\n    parts.push(toObjectLiteralKey(k) + ': ' + obj[k]);\r\n  return '{' + parts.join(', ') + '}';\r\n};\r\n\r\n// `path` is an array of at least one string.\r\n//\r\n// If `path.length > 1`, the generated code may be reactive\r\n// (i.e. it may invalidate the current computation).\r\n//\r\n// No code is generated to call the result if it's a function.\r\n//\r\n// Options:\r\n//\r\n// - lookupTemplate {Boolean} If true, generated code also looks in\r\n//   the list of templates. (After helpers, before data context).\r\n//   Used when generating code for `{{> foo}}` or `{{#foo}}`. Only\r\n//   used for non-dotted paths.\r\nvar codeGenPath = function (path, opts) {\r\n  if (builtInBlockHelpers.hasOwnProperty(path[0]))\r\n    throw new Error(\"Can't use the built-in '\" + path[0] + \"' here\");\r\n  // Let `{{#if UI.contentBlock}}` check whether this template was invoked via\r\n  // inclusion or as a block helper, in addition to supporting\r\n  // `{{> UI.contentBlock}}`.\r\n  if (path.length >= 2 &&\r\n      path[0] === 'UI' && builtInLexicals.hasOwnProperty(path[1])) {\r\n    if (path.length > 2)\r\n      throw new Error(\"Unexpected dotted path beginning with \" +\r\n                      path[0] + '.' + path[1]);\r\n    return builtInLexicals[path[1]];\r\n  }\r\n\r\n  var args = [toJSLiteral(path[0])];\r\n  var lookupMethod = 'lookup';\r\n  if (opts && opts.lookupTemplate && path.length === 1)\r\n    lookupMethod = 'lookupTemplate';\r\n  var code = 'self.' + lookupMethod + '(' + args.join(', ') + ')';\r\n\r\n  if (path.length > 1) {\r\n    code = 'Spacebars.dot(' + code + ', ' +\r\n      _.map(path.slice(1), toJSLiteral).join(', ') + ')';\r\n  }\r\n\r\n  return code;\r\n};\r\n\r\n// Generates code for an `[argType, argValue]` argument spec,\r\n// ignoring the third element (keyword argument name) if present.\r\n//\r\n// The resulting code may be reactive (in the case of a PATH of\r\n// more than one element) and is not wrapped in a closure.\r\nvar codeGenArgValue = function (arg) {\r\n  var argType = arg[0];\r\n  var argValue = arg[1];\r\n\r\n  var argCode;\r\n  switch (argType) {\r\n  case 'STRING':\r\n  case 'NUMBER':\r\n  case 'BOOLEAN':\r\n  case 'NULL':\r\n    argCode = toJSLiteral(argValue);\r\n    break;\r\n  case 'PATH':\r\n    argCode = codeGenPath(argValue);\r\n    break;\r\n  default:\r\n    // can't get here\r\n    throw new Error(\"Unexpected arg type: \" + argType);\r\n  }\r\n\r\n  return argCode;\r\n};\r\n\r\n// Generates a call to `Spacebars.fooMustache` on evaluated arguments.\r\n// The resulting code has no function literals and must be wrapped in\r\n// one for fine-grained reactivity.\r\nvar codeGenMustache = function (path, args, mustacheType) {\r\n  var nameCode = codeGenPath(path);\r\n  var argCode = codeGenMustacheArgs(args);\r\n  var mustache = (mustacheType || 'mustache');\r\n\r\n  return 'Spacebars.' + mustache + '(' + nameCode +\r\n    (argCode ? ', ' + argCode.join(', ') : '') + ')';\r\n};\r\n\r\n// returns: array of source strings, or null if no\r\n// args at all.\r\nvar codeGenMustacheArgs = function (tagArgs) {\r\n  var kwArgs = null; // source -> source\r\n  var args = null; // [source]\r\n\r\n  // tagArgs may be null\r\n  _.each(tagArgs, function (arg) {\r\n    var argCode = codeGenArgValue(arg);\r\n\r\n    if (arg.length > 2) {\r\n      // keyword argument (represented as [type, value, name])\r\n      kwArgs = (kwArgs || {});\r\n      kwArgs[arg[2]] = argCode;\r\n    } else {\r\n      // positional argument\r\n      args = (args || []);\r\n      args.push(argCode);\r\n    }\r\n  });\r\n\r\n  // put kwArgs in options dictionary at end of args\r\n  if (kwArgs) {\r\n    args = (args || []);\r\n    args.push('Spacebars.kw(' + makeObjectLiteral(kwArgs) + ')');\r\n  }\r\n\r\n  return args;\r\n};\r\n\r\n// Takes an inclusion tag and returns an object containing these properties,\r\n// all optional, whose values are JS source code:\r\n//\r\n// - `dataFunc` - source code of a data function literal\r\n// - `content` - source code of a content block\r\n// - `elseContent` - source code of an elseContent block\r\n//\r\n// Implements the calling convention for inclusions.\r\nvar codeGenInclusionParts = function (tag) {\r\n  var ret = {};\r\n\r\n  if ('content' in tag) {\r\n    ret.content = (\r\n      'UI.block(' + Spacebars.codeGen(tag.content) + ')');\r\n  }\r\n  if ('elseContent' in tag) {\r\n    ret.elseContent = (\r\n      'UI.block(' + Spacebars.codeGen(tag.elseContent) + ')');\r\n  }\r\n\r\n  var dataFuncCode = null;\r\n\r\n  var args = tag.args;\r\n  if (! args.length) {\r\n    // e.g. `{{#foo}}`\r\n    return ret;\r\n  } else if (args[0].length === 3) {\r\n    // keyword arguments only, e.g. `{{> point x=1 y=2}}`\r\n    var dataProps = {};\r\n    _.each(args, function (arg) {\r\n      var argKey = arg[2];\r\n      dataProps[argKey] = 'Spacebars.call(' + codeGenArgValue(arg) + ')';\r\n    });\r\n    dataFuncCode = makeObjectLiteral(dataProps);\r\n  } else if (args[0][0] !== 'PATH') {\r\n    // literal first argument, e.g. `{{> foo \"blah\"}}`\r\n    //\r\n    // tag validation has confirmed, in this case, that there is only\r\n    // one argument (`args.length === 1`)\r\n    dataFuncCode = codeGenArgValue(args[0]);\r\n  } else if (args.length === 1) {\r\n    // one argument, must be a PATH\r\n    dataFuncCode = 'Spacebars.call(' + codeGenPath(args[0][1]) + ')';\r\n  } else {\r\n    dataFuncCode = codeGenMustache(args[0][1], args.slice(1),\r\n                                   'dataMustache');\r\n  }\r\n\r\n  ret.dataFunc = 'function () { return ' + dataFuncCode + '; }';\r\n\r\n  return ret;\r\n};\r\n\r\n\r\n// ============================================================\r\n// Main compiler\r\n\r\nvar replaceSpecials = function (node) {\r\n  if (node instanceof HTML.Tag) {\r\n    // potential optimization: don't always create a new tag\r\n    var newChildren = _.map(node.children, replaceSpecials);\r\n    var newTag = HTML.getTag(node.tagName).apply(null, newChildren);\r\n    var oldAttrs = node.attrs;\r\n    var newAttrs = null;\r\n\r\n    if (oldAttrs) {\r\n      _.each(oldAttrs, function (value, name) {\r\n        if (name.charAt(0) !== '$') {\r\n          newAttrs = (newAttrs || {});\r\n          newAttrs[name] = replaceSpecials(value);\r\n        }\r\n      });\r\n\r\n      if (oldAttrs.$specials && oldAttrs.$specials.length) {\r\n        newAttrs = (newAttrs || {});\r\n        newAttrs.$dynamic = _.map(oldAttrs.$specials, function (special) {\r\n          return codeGenTemplateTag(special.value);\r\n        });\r\n      }\r\n    }\r\n\r\n    newTag.attrs = newAttrs;\r\n    return newTag;\r\n  } else if (node instanceof Array) {\r\n    return _.map(node, replaceSpecials);\r\n  } else if (node instanceof HTMLTools.Special) {\r\n    return codeGenTemplateTag(node.value);\r\n  } else {\r\n    return node;\r\n  }\r\n};\r\n\r\nSpacebars.compile = function (input, options) {\r\n  var tree = Spacebars.parse(input);\r\n  return Spacebars.codeGen(tree, options);\r\n};\r\n\r\nSpacebars.codeGen = function (parseTree, options) {\r\n  // is this a template, rather than a block passed to\r\n  // a block helper, say\r\n  var isTemplate = (options && options.isTemplate);\r\n\r\n  var tree = parseTree;\r\n\r\n  // The flags `isTemplate` and `isBody` are kind of a hack.\r\n  if (isTemplate || (options && options.isBody)) {\r\n    // optimizing fragments would require being smarter about whether we are\r\n    // in a TEXTAREA, say.\r\n    tree = optimize(tree);\r\n  }\r\n\r\n  tree = replaceSpecials(tree);\r\n\r\n  var code = '(function () { var self = this; ';\r\n  if (isTemplate) {\r\n    // support `{{> UI.contentBlock}}` and `{{> UI.elseBlock}}` with\r\n    // lexical scope by creating a local variable in the\r\n    // template's render function.\r\n    code += 'var template = this; ';\r\n  }\r\n  code += 'return ';\r\n  code += HTML.toJS(tree);\r\n  code += '; })';\r\n\r\n  code = beautify(code);\r\n\r\n  return code;\r\n};\r\n\r\nvar beautify = function (code) {\r\n  if (Package.minifiers && Package.minifiers.UglifyJSMinify) {\r\n    var result = UglifyJSMinify(code,\r\n                                { fromString: true,\r\n                                  mangle: false,\r\n                                  compress: false,\r\n                                  output: { beautify: true,\r\n                                            indent_level: 2,\r\n                                            width: 80 } });\r\n    var output = result.code;\r\n    // Uglify interprets our expression as a statement and may add a semicolon.\r\n    // Strip trailing semicolon.\r\n    output = output.replace(/;$/, '');\r\n    return output;\r\n  } else {\r\n    // don't actually beautify; no UglifyJS\r\n    return code;\r\n  }\r\n};\r\n\r\n// expose for compiler output tests\r\nSpacebars._beautify = beautify;\r\n"]}