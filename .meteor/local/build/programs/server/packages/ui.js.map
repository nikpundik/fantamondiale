{"version":3,"file":"\\packages\\ui.js","sources":["ui/exceptions.js","ui/base.js","ui/attrs.js","ui/render.js","ui/builtins.js","ui/each.js","ui/fields.js","ui/handlebars_backcompat.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AACA,c;;AAEA,mF;AACA,8E;AACA,4E;AACA,sB;AACA,E;AACA,S;AACA,E;AACA,M;AACA,Q;AACA,yB;AACA,gB;AACA,0B;AACA,I;AACA,M;AACA,E;AACA,6D;;AAEA,uC;AACA,kB;AACA,wB;AACA,6B;AACA,6D;AACA,8E;AACA,gC;AACA,M;;AAEA,4E;AACA,gF;AACA,gE;AACA,sE;AACA,E;;;;;;;;;;;;;;;;;;;ACjCA,Q;;AAEA,2D;AACA,2D;AACA,iB;AACA,+B;AACA,oB;AACA,8B;AACA,sB;AACA,a;AACA,E;;AAEA,sD;AACA,Y;AACA,6C;AACA,iD;AACA,6C;AACA,mB;AACA,kD;AACA,O;AACA,qD;AACA,e;AACA,a;AACA,sB;AACA,G;AACA,a;AACA,E;;AAEA,6D;AACA,iE;AACA,mE;AACA,qE;AACA,mD;AACA,c;;AAEA,4D;AACA,2D;AACA,8D;AACA,4D;AACA,iB;AACA,I;AACA,6D;AACA,8D;AACA,6D;AACA,4D;AACA,6B;AACA,qC;;AAEA,wD;AACA,4C;AACA,yD;AACA,uD;AACA,0D;AACA,sD;AACA,wD;AACA,gD;AACA,uB;AACA,yC;AACA,sC;AACA,a;AACA,8B;AACA,K;;AAEA,a;AACA,iC;;AAEA,+B;AACA,iD;AACA,I;AACA,yD;AACA,+C;AACA,gC;AACA,6B;AACA,e;AACA,kB;AACA,oB;AACA,mB;AACA,K;AACA,iB;AACA,I;AACA,uD;AACA,sD;AACA,iB;AACA,sC;AACA,sB;AACA,oF;AACA,I;AACA,gC;AACA,qB;AACA,4E;AACA,I;AACA,6B;AACA,gB;AACA,oF;AACA,G;AACA,G;;AAEA,yB;;AAEA,uB;AACA,oB;AACA,Y;AACA,Y;AACA,yC;AACA,kB;AACA,+D;AACA,sB;AACA,qB;AACA,0D;AACA,iC;AACA,yC;AACA,e;;AAEA,yD;AACA,+C;AACA,4B;AACA,qD;AACA,2D;AACA,2B;;AAEA,sB;AACA,qD;AACA,0D;AACA,sD;AACA,wB;AACA,0D;;AAEA,e;AACA,2B;AACA,8B;AACA,8D;AACA,iE;AACA,kE;AACA,6D;AACA,8B;AACA,8B;AACA,wB;AACA,Y;AACA,4B;AACA,K;;AAEA,yD;AACA,0D;AACA,uD;AACA,qD;AACA,4B;;AAEA,uB;AACA,mB;AACA,yB;;AAEA,c;AACA,wB;;AAEA,wD;AACA,sC;AACA,sC;AACA,mC;;AAEA,a;AACA,G;AACA,G;;AAEA,yD;AACA,wC;AACA,wD;AACA,0D;AACA,0D;AACA,sD;AACA,uC;AACA,oB;AACA,+D;AACA,E;AACA,sC;AACA,wC;AACA,I;;;AAGA,wE;AACA,sE;AACA,kB;AACA,qE;AACA,2C;AACA,2D;AACA,c;AACA,a;AACA,kC;AACA,yC;AACA,mD;AACA,U;AACA,8E;AACA,kF;AACA,sC;AACA,uC;AACA,e;AACA,oD;AACA,G;AACA,E;;AAEA,6C;AACA,gB;AACA,wC;AACA,kB;AACA,uB;AACA,G;AACA,c;AACA,E;;AAEA,+C;AACA,gB;AACA,4B;AACA,0C;AACA,oB;AACA,U;AACA,oB;AACA,K;AACA,uB;AACA,G;AACA,c;AACA,E;;AAEA,oC;AACA,6C;AACA,gB;AACA,4C;AACA,qC;AACA,gB;AACA,E;;AAEA,0C;AACA,+D;AACA,e;AACA,mC;AACA,qC;;AAEA,sC;AACA,sD;AACA,uD;AACA,0D;AACA,yD;AACA,gC;AACA,sE;AACA,qC;AACA,U;AACA,qE;AACA,0B;AACA,yB;AACA,G;AACA,E;;AAEA,uB;AACA,iE;AACA,0B;AACA,4B;AACA,wB;AACA,I;AACA,2B;AACA,e;AACA,uC;AACA,4B;AACA,Q;AACA,mC;;AAEA,2C;AACA,uC;AACA,wE;AACA,yC;AACA,wC;AACA,+B;AACA,iB;;AAEA,sC;AACA,uC;AACA,uC;AACA,wC;AACA,wC;AACA,S;AACA,O;AACA,G;AACA,G;;AAEA,+D;AACA,uD;AACA,2C;AACA,kB;AACA,mD;AACA,0E;AACA,sD;AACA,0C;AACA,kE;AACA,mE;AACA,kE;AACA,gE;AACA,qE;AACA,iD;AACA,kD;AACA,4B;AACA,K;AACA,kE;AACA,iE;AACA,+D;AACA,2B;AACA,6C;AACA,2E;AACA,kD;AACA,wC;AACA,qC;AACA,6C;AACA,6D;AACA,mD;AACA,wE;AACA,gE;AACA,4C;AACA,mE;AACA,sE;AACA,kD;AACA,oE;AACA,W;AACA,Q;;AAEA,4D;AACA,O;AACA,G;;AAEA,sB;AACA,gD;AACA,iC;AACA,+B;AACA,qC;AACA,kD;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,c;AACA,qC;AACA,yF;AACA,E;;AAEA,mE;AACA,gB;AACA,mC;AACA,oD;AACA,wC;AACA,E;;AAEA,0B;AACA,uC;AACA,uB;AACA,E;AACA,yC;AACA,uB;AACA,E;;;;;;;;;;;;;;;;;;;;AChWA,gF;AACA,kE;AACA,uE;AACA,sB;AACA,E;AACA,gD;AACA,uE;AACA,4E;AACA,yE;AACA,uE;AACA,0E;AACA,yE;AACA,wE;AACA,sE;AACA,0E;AACA,+B;AACA,E;AACA,2E;AACA,kE;AACA,E;AACA,4E;AACA,0D;;AAEA,2C;AACA,mB;AACA,qB;AACA,E;;AAEA,yE;AACA,uB;AACA,0B;AACA,yC;AACA,U;AACA,2C;AACA,G;AACA,E;;AAEA,8C;AACA,qB;AACA,iE;AACA,4C;AACA,I;AACA,kC;AACA,kC;AACA,c;AACA,yC;AACA,iB;AACA,E;;AAEA,0D;AACA,gD;AACA,+C;AACA,gD;AACA,2E;;AAEA,oE;AACA,8D;;AAEA,gE;AACA,sE;;AAEA,qE;AACA,iD;AACA,4B;AACA,sC;AACA,wC;AACA,K;AACA,iD;AACA,4B;AACA,0C;AACA,qC;AACA,wB;AACA,K;;AAEA,8C;AACA,G;AACA,G;;AAEA,4C;AACA,6B;AACA,uC;AACA,6B;AACA,I;AACA,2C;AACA,kC;AACA,G;AACA,G;;AAEA,+C;AACA,uC;AACA,qC;AACA,I;AACA,2C;AACA,6C;AACA,G;AACA,G;;AAEA,8C;AACA,+C;AACA,wC;;AAEA,mB;AACA,2B;AACA,0B;AACA,6B;AACA,gC;AACA,c;AACA,6B;AACA,O;AACA,K;AACA,I;AACA,uD;AACA,+B;AACA,sC;AACA,gD;;AAEA,8C;AACA,2D;AACA,wB;AACA,6B;AACA,uD;AACA,uC;;AAEA,mB;AACA,mD;AACA,U;AACA,qB;AACA,Y;AACA,0D;AACA,K;AACA,G;AACA,G;;AAEA,4C;AACA,+C;AACA,uD;;AAEA,iB;AACA,4B;AACA,G;AACA,G;;AAEA,+D;AACA,yC;AACA,4C;AACA,8C;AACA,4C;AACA,yB;AACA,4B;AACA,iD;AACA,Y;AACA,wD;AACA,K;AACA,G;AACA,G;;AAEA,mD;AACA,oC;AACA,mC;AACA,E;;AAEA,mD;AACA,wE;AACA,Q;AACA,yE;AACA,kB;AACA,qB;AACA,yB;AACA,yB;AACA,gB;AACA,kB;AACA,kB;AACA,sD;AACA,yB;AACA,gB;AACA,mB;AACA,mB;AACA,mB;AACA,uC;AACA,+B;AACA,gC;AACA,sB;AACA,oB;AACA,2C;AACA,2B;AACA,mB;AACA,uB;AACA,uB;AACA,qB;AACA,I;;AAEA,8B;AACA,gB;AACA,G;;AAEA,6C;AACA,4C;AACA,E;;AAEA,qE;AACA,uE;AACA,2B;AACA,sB;AACA,2D;AACA,C;;AAEA,mC;AACA,wB;AACA,sC;AACA,uC;AACA,U;AACA,kE;AACA,G;AACA,E;;AAEA,uE;AACA,oD;AACA,mE;AACA,qE;AACA,qE;AACA,uD;AACA,oE;AACA,mD;AACA,iE;AACA,mD;AACA,0C;AACA,+C;AACA,oB;AACA,yB;;AAEA,sC;AACA,mC;AACA,Y;AACA,gC;AACA,+D;AACA,iC;AACA,2E;AACA,2D;AACA,yD;AACA,yC;AACA,0D;AACA,c;AACA,qC;AACA,O;AACA,K;AACA,G;AACA,G;;AAEA,iE;AACA,qD;AACA,sE;AACA,kE;AACA,yB;AACA,6B;AACA,8C;AACA,Y;AACA,2C;AACA,K;AACA,kE;AACA,gE;AACA,2C;AACA,sE;AACA,mC;AACA,8D;AACA,kC;AACA,yC;AACA,gD;AACA,sD;AACA,kD;AACA,uC;AACA,U;AACA,6C;AACA,G;;AAEA,gE;AACA,oC;AACA,E;;;AAGA,4C;AACA,mB;AACA,qB;AACA,E;;AAEA,+D;AACA,sB;AACA,gE;AACA,uB;AACA,+B;;AAEA,2B;AACA,uC;AACA,6D;AACA,4D;AACA,yD;AACA,sD;AACA,4B;AACA,gC;AACA,mC;AACA,2B;AACA,2C;AACA,yB;AACA,K;AACA,G;;AAEA,2B;AACA,uB;AACA,iB;AACA,4B;AACA,uC;AACA,2B;AACA,2B;AACA,uD;AACA,8B;AACA,wB;AACA,O;AACA,Y;AACA,4B;AACA,+B;AACA,K;AACA,6B;AACA,4B;AACA,4C;AACA,yB;AACA,2B;AACA,K;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;;ACvUA,8C;AACA,kB;;AAEA,oB;AACA,6B;AACA,sB;AACA,uE;AACA,U;AACA,+C;AACA,G;;AAEA,+C;AACA,uB;;AAEA,kC;AACA,2B;AACA,kC;AACA,2C;AACA,kC;AACA,M;AACA,+B;AACA,0C;AACA,+B;AACA,M;AACA,oB;AACA,mB;AACA,e;AACA,uB;AACA,I;AACA,0D;;AAEA,iC;;AAEA,gB;AACA,gB;;AAEA,qB;AACA,iC;AACA,6C;AACA,G;;AAEA,c;AACA,E;;AAEA,mC;AACA,c;AACA,E;;AAEA,mC;AACA,kB;;AAEA,mB;AACA,uB;;AAEA,wB;;AAEA,iC;;AAEA,yD;AACA,sC;AACA,2B;;AAEA,6B;;AAEA,yB;AACA,iC;AACA,uC;;AAEA,mD;AACA,sC;AACA,8B;AACA,iB;AACA,S;AACA,O;;AAEA,iC;AACA,yB;AACA,O;AACA,K;AACA,E;;AAEA,kC;AACA,gC;AACA,E;;AAEA,iC;AACA,sD;AACA,sB;;AAEA,wB;AACA,E;;AAEA,8E;AACA,8E;AACA,oD;AACA,E;AACA,yE;AACA,yE;AACA,uE;AACA,0E;AACA,2E;AACA,yE;AACA,4E;AACA,kB;AACA,E;AACA,0E;AACA,0E;AACA,qE;AACA,sE;AACA,yE;AACA,8D;AACA,E;AACA,0E;AACA,oE;AACA,uE;AACA,wE;AACA,0E;AACA,2E;AACA,2E;AACA,4E;AACA,sD;AACA,E;AACA,4E;AACA,8E;AACA,E;AACA,gD;AACA,0C;;AAEA,2B;AACA,oC;;AAEA,yB;AACA,uB;AACA,M;;AAEA,0B;AACA,iB;AACA,M;;AAEA,a;;AAEA,U;AACA,4B;AACA,8B;AACA,mB;AACA,M;AACA,qC;AACA,kB;AACA,G;AACA,E;;;AAGA,2D;AACA,sB;AACA,+C;AACA,a;AACA,a;AACA,G;;AAEA,kC;AACA,gB;AACA,iD;;AAEA,iB;AACA,E;;AAEA,wC;;AAEA,kE;AACA,6B;AACA,iE;;AAEA,oE;AACA,E;;AAEA,gE;AACA,E;AACA,gF;AACA,yC;AACA,iD;AACA,4C;AACA,E;AACA,+E;AACA,kC;AACA,qD;AACA,e;AACA,uD;;AAEA,sC;AACA,oC;AACA,kD;AACA,8C;AACA,oD;AACA,U;AACA,iD;AACA,sE;AACA,G;AACA,E;;AAEA,8C;AACA,oB;AACA,4E;;AAEA,2B;;AAEA,gC;;AAEA,6C;;AAEA,6C;;AAEA,4B;AACA,qB;AACA,2B;;AAEA,K;;AAEA,0C;;AAEA,+B;AACA,4B;AACA,yB;AACA,oC;AACA,qC;AACA,mD;AACA,S;AACA,K;AACA,I;;AAEA,c;AACA,E;;AAEA,4D;AACA,6B;AACA,+C;AACA,oB;AACA,4E;AACA,iC;AACA,yD;;AAEA,qE;AACA,oC;AACA,E;;AAEA,qC;AACA,8B;AACA,4D;AACA,yB;AACA,uB;AACA,U;AACA,uB;AACA,6D;AACA,gC;AACA,G;AACA,E;;AAEA,uD;AACA,6C;AACA,2B;AACA,yD;;AAEA,sC;AACA,iC;AACA,iC;;AAEA,6B;AACA,yB;AACA,E;;AAEA,kE;AACA,mD;AACA,E;;AAEA,4E;AACA,6D;AACA,E;;AAEA,uE;AACA,yE;AACA,oE;AACA,qF;AACA,oF;AACA,0E;;AAEA,qB;AACA,yB;AACA,mB;AACA,uG;AACA,wB;AACA,0D;AACA,qC;AACA,yC;AACA,4D;AACA,0C;;AAEA,gC;AACA,2B;AACA,kD;AACA,2B;AACA,0D;AACA,gC;AACA,uB;AACA,kE;AACA,6B;;AAEA,sD;AACA,kD;AACA,8B;;AAEA,yB;AACA,4B;;AAEA,2D;AACA,O;AACA,O;AACA,iC;AACA,0B;AACA,oB;AACA,oB;AACA,M;AACA,gB;AACA,mC;AACA,qC;AACA,oB;AACA,S;AACA,K;AACA,kC;AACA,wC;AACA,+B;AACA,a;AACA,sE;AACA,6E;AACA,Y;AACA,kD;AACA,K;;AAEA,8B;AACA,iC;AACA,sC;AACA,kC;AACA,gC;AACA,oB;AACA,M;;AAEA,mB;AACA,gD;AACA,oC;AACA,4B;AACA,uE;AACA,S;;AAEA,a;AACA,yE;AACA,+B;AACA,sB;AACA,kC;AACA,0E;AACA,4D;AACA,a;AACA,4C;AACA,W;AACA,qB;AACA,+B;AACA,S;AACA,S;AACA,uD;AACA,wB;AACA,S;AACA,K;AACA,uD;;AAEA,iC;AACA,sD;AACA,gB;AACA,oD;;AAEA,sE;AACA,wB;AACA,8B;AACA,8B;;AAEA,yC;AACA,4C;AACA,8D;AACA,4C;AACA,wE;AACA,wC;AACA,mE;AACA,wB;AACA,wD;AACA,8C;AACA,2C;AACA,kG;AACA,oF;AACA,kD;AACA,8D;AACA,U;AACA,qB;AACA,0D;AACA,G;AACA,E;;;;AAIA,4D;AACA,0D;AACA,6B;;AAEA,+B;AACA,e;AACA,mB;AACA,uB;AACA,6B;AACA,I;AACA,gC;AACA,sB;AACA,oB;AACA,G;;AAEA,kC;AACA,qD;AACA,E;;AAEA,iD;AACA,+C;AACA,E;;AAEA,oD;AACA,qE;AACA,E;;;;;;;;;;;;;;;;;;;;AC7aA,4D;AACA,2E;;AAEA,uB;AACA,mD;AACA,0B;AACA,8B;AACA,M;AACA,2B;AACA,0B;AACA,Q;AACA,sC;AACA,I;;AAEA,W;AACA,E;;;AAGA,gE;AACA,+E;;AAEA,uB;AACA,mD;AACA,0B;AACA,8B;AACA,M;AACA,6B;AACA,0B;AACA,Q;AACA,sC;AACA,I;;AAEA,W;AACA,E;;AAEA,4E;AACA,6E;AACA,8E;AACA,mC;AACA,iC;AACA,c;AACA,iB;AACA,M;AACA,0E;AACA,qC;AACA,E;;AAEA,wE;AACA,E;AACA,yE;AACA,wE;AACA,gB;AACA,4C;AACA,2D;;AAEA,2B;AACA,wB;AACA,8D;AACA,kC;AACA,0B;AACA,O;AACA,G;;AAEA,4B;AACA,yD;AACA,I;;AAEA,4B;AACA,sD;AACA,I;;AAEA,oC;AACA,oB;AACA,sB;AACA,qC;AACA,yB;AACA,S;AACA,K;AACA,I;AACA,mC;;AAEA,e;AACA,E;;AAEA,8D;AACA,6E;;AAEA,6B;AACA,wB;AACA,4B;AACA,mC;AACA,K;AACA,E;;AAEA,2F;AACA,oC;AACA,0E;AACA,qC;AACA,uF;AACA,6D;AACA,iG;AACA,E;;AAEA,gE;AACA,E;AACA,oC;AACA,gE;AACA,0D;AACA,+C;AACA,sD;AACA,uD;AACA,sD;AACA,wD;AACA,uD;AACA,uD;AACA,wC;AACA,+B;;AAEA,gD;AACA,mD;AACA,mB;AACA,Q;AACA,qB;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AC7HA,gC;AACA,mB;AACA,+B;AACA,oB;AACA,iC;AACA,yC;;AAEA,gC;AACA,2D;AACA,yD;AACA,yD;AACA,yD;AACA,qC;AACA,Q;AACA,2D;AACA,2D;AACA,0D;AACA,uD;AACA,0D;AACA,2D;AACA,2D;AACA,6D;AACA,wB;AACA,iD;AACA,yB;AACA,oD;AACA,wB;AACA,c;AACA,W;;AAEA,yB;AACA,qB;AACA,c;AACA,2B;AACA,O;AACA,mB;AACA,Y;AACA,kB;AACA,K;AACA,I;AACA,6B;AACA,oB;;AAEA,yB;;AAEA,iC;AACA,yC;;AAEA,8D;AACA,sE;AACA,+D;AACA,sB;AACA,sC;AACA,qE;AACA,e;;AAEA,gC;AACA,8D;;AAEA,4B;AACA,6B;AACA,0B;AACA,O;AACA,yB;AACA,4B;AACA,uD;AACA,O;AACA,M;;AAEA,8D;AACA,+B;AACA,Q;AACA,iD;AACA,sB;AACA,8C;;AAEA,wB;AACA,sC;;AAEA,yC;AACA,oC;AACA,uB;AACA,sB;AACA,U;AACA,gD;AACA,oC;AACA,sC;AACA,mB;AACA,wB;AACA,U;;AAEA,qB;AACA,4D;;AAEA,6E;AACA,kD;AACA,Q;AACA,sC;AACA,uB;AACA,uD;AACA,Q;AACA,oD;AACA,yB;AACA,2C;AACA,8D;AACA,Q;AACA,kD;AACA,iF;AACA,O;AACA,O;;AAEA,6D;AACA,kB;AACA,I;AACA,0B;AACA,yC;AACA,8C;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;;ACrHA,8C;;AAEA,yD;AACA,6D;AACA,iD;AACA,2C;AACA,yC;AACA,mC;AACA,kC;AACA,gB;AACA,E;;AAEA,4D;AACA,iE;AACA,qC;AACA,2B;AACA,iB;AACA,yB;AACA,4E;AACA,4B;AACA,K;AACA,K;AACA,E;;AAEA,sE;AACA,c;AACA,yB;AACA,qB;AACA,wC;AACA,qC;AACA,E;;AAEA,uB;AACA,a;AACA,I;AACA,sE;AACA,uC;AACA,+B;AACA,oB;AACA,yC;AACA,e;AACA,a;;AAEA,Y;AACA,gD;;AAEA,yB;AACA,qE;AACA,4C;AACA,gC;AACA,yE;AACA,O;;AAEA,6D;AACA,2C;AACA,gG;AACA,O;;AAEA,uD;;AAEA,4D;AACA,kD;AACA,yC;AACA,4B;;AAEA,8C;AACA,mC;;AAEA,gE;AACA,6D;AACA,W;AACA,M;AACA,wD;AACA,wD;AACA,4D;AACA,0B;AACA,6B;AACA,0C;AACA,6C;AACA,4C;AACA,kD;AACA,yB;AACA,W;AACA,iD;AACA,0B;;AAEA,iD;;AAEA,Y;AACA,4D;AACA,uC;AACA,0C;AACA,mD;AACA,oF;AACA,mB;AACA,sB;AACA,8B;AACA,yC;AACA,+C;AACA,sB;AACA,Q;AACA,K;;AAEA,sE;AACA,gF;AACA,sE;AACA,0E;AACA,uC;AACA,0C;AACA,kE;AACA,Q;AACA,Y;AACA,oB;AACA,M;AACA,I;AACA,iC;AACA,6C;AACA,I;AACA,sB;AACA,oD;AACA,yB;AACA,e;;AAEA,iC;AACA,8D;AACA,I;AACA,6B;AACA,+C;AACA,6B;AACA,iD;AACA,uC;AACA,qD;AACA,oB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACvIA,sE;AACA,sC;AACA,uB;;AAEA,2C;AACA,6B;AACA,E;;AAEA,oC;AACA,6B;AACA,E;;AAEA,gB;AACA,8C;;AAEA,mC;AACA,+C;AACA,oB;AACA,gB;AACA,gB;AACA,kB;AACA,kB;AACA,kE;AACA,gB;AACA,I;AACA,gC;AACA,yB;AACA,I;;AAEA,uB;AACA,8C;AACA,I;AACA,K;;AAEA,qE;AACA,iC;AACA,0C;AACA,uB;AACA,E;AACA,uD;AACA,gC;AACA,E","sourcesContent":["\r\nvar debugFunc;\r\n\r\n// Meteor UI calls into user code in many places, and it's nice to catch exceptions\r\n// propagated from user code immediately so that the whole system doesn't just\r\n// break.  Catching exceptions is easy; reporting them is hard.  This helper\r\n// reports exceptions.\r\n//\r\n// Usage:\r\n//\r\n// ```\r\n// try {\r\n//   // ... someStuff ...\r\n// } catch (e) {\r\n//   reportUIException(e);\r\n// }\r\n// ```\r\n//\r\n// An optional second argument overrides the default message.\r\n\r\nreportUIException = function (e, msg) {\r\n  if (! debugFunc)\r\n    // adapted from Deps\r\n    debugFunc = function () {\r\n      return (typeof Meteor !== \"undefined\" ? Meteor._debug :\r\n              ((typeof console !== \"undefined\") && console.log ? console.log :\r\n               function () {}));\r\n    };\r\n\r\n  // In Chrome, `e.stack` is a multiline string that starts with the message\r\n  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.\r\n  // `console.log` supplies the space between the two arguments.\r\n  debugFunc()(msg || 'Exception in Meteor UI:', e.stack || e.message);\r\n};\r\n","UI = {};\r\n\r\n// A very basic operation like Underscore's `_.extend` that\r\n// copies `src`'s own, enumerable properties onto `tgt` and\r\n// returns `tgt`.\r\n_extend = function (tgt, src) {\r\n  for (var k in src)\r\n    if (src.hasOwnProperty(k))\r\n      tgt[k] = src[k];\r\n  return tgt;\r\n};\r\n\r\n// Defines a single non-enumerable, read-only property\r\n// on `tgt`.\r\n// It won't be non-enumerable in IE 8, so its\r\n// non-enumerability can't be relied on for logic\r\n// purposes, it just makes things prettier in\r\n// the dev console.\r\nvar _defineNonEnum = function (tgt, name, value) {\r\n  try {\r\n    Object.defineProperty(tgt, name, {value: value});\r\n  } catch (e) {\r\n    // IE < 9\r\n    tgt[name] = value;\r\n  }\r\n  return tgt;\r\n};\r\n\r\n// Named function (like `function Component() {}` below) make\r\n// inspection in debuggers more descriptive. In IE, this sets the\r\n// value of the `Component` var in the function scope in which it's\r\n// executed. We already have a top-level `Component` var so we create\r\n// a new function scope to not write it over in IE.\r\n(function () {\r\n\r\n  // Components and Component kinds are the same thing, just\r\n  // objects; there are no constructor functions, no `new`,\r\n  // and no `instanceof`.  A Component object is like a class,\r\n  // until it is inited, at which point it becomes more like\r\n  // an instance.\r\n  //\r\n  // `y = x.extend({ ...new props })` creates a new Component\r\n  // `y` with `x` as its prototype, plus additional properties\r\n  // on `y` itself.  `extend` is used both to subclass and to\r\n  // create instances (and the hope is we can gloss over the\r\n  // difference in the docs).\r\n  UI.Component = (function (constr) {\r\n\r\n    // Make sure the \"class name\" that Chrome infers for\r\n    // UI.Component is \"Component\", and that\r\n    // `new UI.Component._constr` (which is what `extend`\r\n    // does) also produces objects whose inferred class\r\n    // name is \"Component\".  Chrome's name inference rules\r\n    // are a little mysterious, but a function name in\r\n    // the source code (as in `function Component() {}`)\r\n    // seems to be reliable and high precedence.\r\n    var C = new constr;\r\n    _defineNonEnum(C, '_constr', constr);\r\n    _defineNonEnum(C, '_super', null);\r\n    return C;\r\n  })(function Component() {});\r\n})();\r\n\r\n_extend(UI, {\r\n  nextGuid: 2, // Component is 1!\r\n\r\n  isComponent: function (obj) {\r\n    return obj && UI.isKindOf(obj, UI.Component);\r\n  },\r\n  // `UI.isKindOf(a, b)` where `a` and `b` are Components\r\n  // (or kinds) asks if `a` is or descends from\r\n  // (transitively extends) `b`.\r\n  isKindOf: function (a, b) {\r\n    while (a) {\r\n      if (a === b)\r\n        return true;\r\n      a = a._super;\r\n    }\r\n    return false;\r\n  },\r\n  // use these to produce error messages for developers\r\n  // (though throwing a more specific error message is\r\n  // even better)\r\n  _requireNotDestroyed: function (c) {\r\n    if (c.isDestroyed)\r\n      throw new Error(\"Component has been destroyed; can't perform this operation\");\r\n  },\r\n  _requireInited: function (c) {\r\n    if (! c.isInited)\r\n      throw new Error(\"Component must be inited to perform this operation\");\r\n  },\r\n  _requireDom: function (c) {\r\n    if (! c.dom)\r\n      throw new Error(\"Component must be built into DOM to perform this operation\");\r\n  }\r\n});\r\n\r\nComponent = UI.Component;\r\n\r\n_extend(UI.Component, {\r\n  kind: \"Component\",\r\n  guid: \"1\",\r\n  dom: null,\r\n  // Has this Component ever been inited?\r\n  isInited: false,\r\n  // Has this Component been destroyed?  Only inited Components\r\n  // can be destroyed.\r\n  isDestroyed: false,\r\n  // Component that created this component (typically also\r\n  // the DOM containment parent).\r\n  // No child pointers (except in `dom`).\r\n  parent: null,\r\n\r\n  // create a new subkind or instance whose proto pointer\r\n  // points to this, with additional props set.\r\n  extend: function (props) {\r\n    // this function should never cause `props` to be\r\n    // mutated in case people want to reuse `props` objects\r\n    // in a mixin-like way.\r\n\r\n    if (this.isInited)\r\n      // Disallow extending inited Components so that\r\n      // inited Components don't inherit instance-specific\r\n      // properties from other inited Components, just\r\n      // default values.\r\n      throw new Error(\"Can't extend an inited Component\");\r\n\r\n    var constr;\r\n    var constrMade = false;\r\n    if (props && props.kind) {\r\n      // If `kind` is different from super, set a constructor.\r\n      // We used to set the function name here so that components\r\n      // printed better in the console, but we took it out because\r\n      // of CSP (and in hopes that Chrome finally adds proper\r\n      // displayName support).\r\n      constr = function () {};\r\n      constrMade = true;\r\n    } else {\r\n      constr = this._constr;\r\n    }\r\n\r\n    // We don't know where we're getting `constr` from --\r\n    // it might be from some supertype -- just that it has\r\n    // the right function name.  So set the `prototype`\r\n    // property each time we use it as a constructor.\r\n    constr.prototype = this;\r\n\r\n    var c = new constr;\r\n    if (constrMade)\r\n      c._constr = constr;\r\n\r\n    if (props)\r\n      _extend(c, props);\r\n\r\n    // for efficient Component instantiations, we assign\r\n    // as few things as possible here.\r\n    _defineNonEnum(c, '_super', this);\r\n    c.guid = String(UI.nextGuid++);\r\n\r\n    return c;\r\n  }\r\n});\r\n\r\n//callChainedCallback = function (comp, propName, orig) {\r\n  // Call `comp.foo`, `comp._super.foo`,\r\n  // `comp._super._super.foo`, and so on, but in reverse\r\n  // order, and only if `foo` is an \"own property\" in each\r\n  // case.  Furthermore, the passed value of `this` should\r\n  // remain `comp` for all calls (which is achieved by\r\n  // filling in `orig` when recursing).\r\n//  if (comp._super)\r\n//    callChainedCallback(comp._super, propName, orig || comp);\r\n//\r\n//  if (comp.hasOwnProperty(propName))\r\n//    comp[propName].call(orig || comp);\r\n//};\r\n\r\n\r\n// Returns 0 if the nodes are the same or either one contains the other;\r\n// otherwise, -1 if a comes before b, or else 1 if b comes before a in\r\n// document order.\r\n// Requires: `a` and `b` are element nodes in the same document tree.\r\nvar compareElementIndex = function (a, b) {\r\n  // See http://ejohn.org/blog/comparing-document-position/\r\n  if (a === b)\r\n    return 0;\r\n  if (a.compareDocumentPosition) {\r\n    var n = a.compareDocumentPosition(b);\r\n    return ((n & 0x18) ? 0 : ((n & 0x4) ? -1 : 1));\r\n  } else {\r\n    // Only old IE is known to not have compareDocumentPosition (though Safari\r\n    // originally lacked it).  Thankfully, IE gives us a way of comparing elements\r\n    // via the \"sourceIndex\" property.\r\n    if (a.contains(b) || b.contains(a))\r\n      return 0;\r\n    return (a.sourceIndex < b.sourceIndex ? -1 : 1);\r\n  }\r\n};\r\n\r\nfindComponentWithProp = function (id, comp) {\r\n  while (comp) {\r\n    if (typeof comp[id] !== 'undefined')\r\n      return comp;\r\n    comp = comp.parent;\r\n  }\r\n  return null;\r\n};\r\n\r\nfindComponentWithHelper = function (id, comp) {\r\n  while (comp) {\r\n    if (comp.__helperHost) {\r\n      if (typeof comp[id] !== 'undefined')\r\n        return comp;\r\n      else\r\n        return null;\r\n    }\r\n    comp = comp.parent;\r\n  }\r\n  return null;\r\n};\r\n\r\ngetComponentData = function (comp) {\r\n  comp = findComponentWithProp('data', comp);\r\n  return (comp ?\r\n          (typeof comp.data === 'function' ?\r\n           comp.data() : comp.data) :\r\n          null);\r\n};\r\n\r\nupdateTemplateInstance = function (comp) {\r\n  // Populate `comp.templateInstance.{firstNode,lastNode,data}`\r\n  // on demand.\r\n  var tmpl = comp.templateInstance;\r\n  tmpl.data = getComponentData(comp);\r\n\r\n  if (comp.dom && !comp.isDestroyed) {\r\n    tmpl.firstNode = comp.dom.startNode().nextSibling;\r\n    tmpl.lastNode = comp.dom.endNode().previousSibling;\r\n    // Catch the case where the DomRange is empty and we'd\r\n    // otherwise pass the out-of-order nodes (end, start)\r\n    // as (firstNode, lastNode).\r\n    if (tmpl.lastNode && tmpl.lastNode.nextSibling === tmpl.firstNode)\r\n      tmpl.lastNode = tmpl.firstNode;\r\n  } else {\r\n    // on 'created' or 'destroyed' callbacks we don't have a DomRange\r\n    tmpl.firstNode = null;\r\n    tmpl.lastNode = null;\r\n  }\r\n};\r\n\r\n_extend(UI.Component, {\r\n  // We implement the old APIs here, including how data is passed\r\n  // to helpers in `this`.\r\n  helpers: function (dict) {\r\n    _extend(this, dict);\r\n  },\r\n  events: function (dict) {\r\n    var events;\r\n    if (this.hasOwnProperty('_events'))\r\n      events = this._events;\r\n    else\r\n      events = (this._events = []);\r\n\r\n    _.each(dict, function (handler, spec) {\r\n      var clauses = spec.split(/,\\s+/);\r\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\r\n      _.each(clauses, function (clause) {\r\n        var parts = clause.split(/\\s+/);\r\n        if (parts.length === 0)\r\n          return;\r\n\r\n        var newEvents = parts.shift();\r\n        var selector = parts.join(' ');\r\n        events.push({events: newEvents,\r\n                     selector: selector,\r\n                     handler: handler});\r\n      });\r\n    });\r\n  }\r\n});\r\n\r\n// XXX we don't really want this to be a user-visible callback,\r\n// it's just a particular signal we need from DomRange.\r\nUI.Component.notifyParented = function () {\r\n  var self = this;\r\n  for (var comp = self; comp; comp = comp._super) {\r\n    var events = (comp.hasOwnProperty('_events') && comp._events) || null;\r\n    if ((! events) && comp.hasOwnProperty('events') &&\r\n        typeof comp.events === 'object') {\r\n      // Provide limited back-compat support for `.events = {...}`\r\n      // syntax.  Pass `comp.events` to the original `.events(...)`\r\n      // function.  This code must run only once per component, in\r\n      // order to not bind the handlers more than once, which is\r\n      // ensured by the fact that we only do this when `comp._events`\r\n      // is falsy, and we cause it to be set now.\r\n      UI.Component.events.call(comp, comp.events);\r\n      events = comp._events;\r\n    }\r\n    _.each(events, function (esh) { // {events, selector, handler}\r\n      // wrap the handler here, per instance of the template that\r\n      // declares the event map, so we can pass the instance to\r\n      // the event handler.\r\n      var wrappedHandler = function (event) {\r\n        var comp = UI.DomRange.getContainingComponent(event.currentTarget);\r\n        var data = comp && getComponentData(comp);\r\n        var args = _.toArray(arguments);\r\n        updateTemplateInstance(self);\r\n        return Deps.nonreactive(function () {\r\n          // put self.templateInstance as the second argument\r\n          args.splice(1, 0, self.templateInstance);\r\n          // Don't want to be in a deps context, even if we were somehow\r\n          // triggered synchronously in an existing deps context\r\n          // (the `blur` event can do this).\r\n          // XXX we should probably do what Spark did and block all\r\n          // event handling during our DOM manip.  Many apps had weird\r\n          // unanticipated bugs until we did that.\r\n          return esh.handler.apply(data === null ? {} : data, args);\r\n        });\r\n      };\r\n\r\n      self.dom.on(esh.events, esh.selector, wrappedHandler);\r\n    });\r\n  }\r\n\r\n  if (self.rendered) {\r\n    // Defer rendered callback until flush time.\r\n    Deps.afterFlush(function () {\r\n      if (! self.isDestroyed) {\r\n        updateTemplateInstance(self);\r\n        self.rendered.call(self.templateInstance);\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\n// past compat\r\nUI.Component.preserve = function () {\r\n  Meteor._debug(\"The 'preserve' method on templates is now unnecessary and deprecated.\");\r\n};\r\n\r\n// Gets the data context of the enclosing component that rendered a\r\n// given element\r\nUI.getElementData = function (el) {\r\n  var comp = UI.DomRange.getContainingComponent(el);\r\n  return comp && getComponentData(comp);\r\n};\r\n\r\nvar jsUrlsAllowed = false;\r\nUI._allowJavascriptUrls = function () {\r\n  jsUrlsAllowed = true;\r\n};\r\nUI._javascriptUrlsAllowed = function () {\r\n  return jsUrlsAllowed;\r\n};\r\n","\r\n// An AttributeHandler object is responsible for updating a particular attribute\r\n// of a particular element.  AttributeHandler subclasses implement\r\n// browser-specific logic for dealing with particular attributes across\r\n// different browsers.\r\n//\r\n// To define a new type of AttributeHandler, use\r\n// `var FooHandler = AttributeHandler.extend({ update: function ... })`\r\n// where the `update` function takes arguments `(element, oldValue, value)`.\r\n// The `element` argument is always the same between calls to `update` on\r\n// the same instance.  `oldValue` and `value` are each either `null` or\r\n// a Unicode string of the type that might be passed to the value argument\r\n// of `setAttribute` (i.e. not an HTML string with character references).\r\n// When an AttributeHandler is installed, an initial call to `update` is\r\n// always made with `oldValue = null`.  The `update` method can access\r\n// `this.name` if the AttributeHandler class is a generic one that applies\r\n// to multiple attribute names.\r\n//\r\n// AttributeHandlers can store custom properties on `this`, as long as they\r\n// don't use the names `element`, `name`, `value`, and `oldValue`.\r\n//\r\n// AttributeHandlers can't influence how attributes appear in rendered HTML,\r\n// only how they are updated after materialization as DOM.\r\n\r\nAttributeHandler = function (name, value) {\r\n  this.name = name;\r\n  this.value = value;\r\n};\r\n\r\nAttributeHandler.prototype.update = function (element, oldValue, value) {\r\n  if (value === null) {\r\n    if (oldValue !== null)\r\n      element.removeAttribute(this.name);\r\n  } else {\r\n    element.setAttribute(this.name, value);\r\n  }\r\n};\r\n\r\nAttributeHandler.extend = function (options) {\r\n  var curType = this;\r\n  var subType = function AttributeHandlerSubtype(/*arguments*/) {\r\n    AttributeHandler.apply(this, arguments);\r\n  };\r\n  subType.prototype = new curType;\r\n  subType.extend = curType.extend;\r\n  if (options)\r\n    _.extend(subType.prototype, options);\r\n  return subType;\r\n};\r\n\r\n// Extended below to support both regular and SVG elements\r\nvar BaseClassHandler = AttributeHandler.extend({\r\n  update: function (element, oldValue, value) {\r\n    if (!this.getCurrentValue || !this.setValue)\r\n      throw new Error(\"Missing methods in subclass of 'BaseClassHandler'\");\r\n\r\n    var oldClasses = oldValue ? _.compact(oldValue.split(' ')) : [];\r\n    var newClasses = value ? _.compact(value.split(' ')) : [];\r\n\r\n    // the current classes on the element, which we will mutate.\r\n    var classes = _.compact(this.getCurrentValue(element).split(' '));\r\n\r\n    // optimize this later (to be asymptotically faster) if necessary\r\n    for (var i = 0; i < oldClasses.length; i++) {\r\n      var c = oldClasses[i];\r\n      if (! _.contains(newClasses, c))\r\n        classes = _.without(classes, c);\r\n    }\r\n    for (var i = 0; i < newClasses.length; i++) {\r\n      var c = newClasses[i];\r\n      if ((! _.contains(oldClasses, c)) &&\r\n          (! _.contains(classes, c)))\r\n        classes.push(c);\r\n    }\r\n\r\n    this.setValue(element, classes.join(' '));\r\n  }\r\n});\r\n\r\nvar ClassHandler = BaseClassHandler.extend({\r\n  // @param rawValue {String}\r\n  getCurrentValue: function (element) {\r\n    return element.className;\r\n  },\r\n  setValue: function (element, className) {\r\n    element.className = className;\r\n  }\r\n});\r\n\r\nvar SVGClassHandler = BaseClassHandler.extend({\r\n  getCurrentValue: function (element) {\r\n    return element.className.baseVal;\r\n  },\r\n  setValue: function (element, className) {\r\n    element.setAttribute('class', className);\r\n  }\r\n});\r\n\r\nvar BooleanHandler = AttributeHandler.extend({\r\n  update: function (element, oldValue, value) {\r\n    var focused = this.focused(element);\r\n\r\n    if (!focused) {\r\n      var name = this.name;\r\n      if (value == null) {\r\n        if (oldValue != null)\r\n          element[name] = false;\r\n      } else {\r\n        element[name] = true;\r\n      }\r\n    }\r\n  },\r\n  // is the element part of a control which is focused?\r\n  focused: function (element) {\r\n    if (element.tagName === 'INPUT') {\r\n      return element === document.activeElement;\r\n\r\n    } else if (element.tagName === 'OPTION') {\r\n      // find the containing SELECT element, on which focus\r\n      // is actually set\r\n      var selectEl = element;\r\n      while (selectEl && selectEl.tagName !== 'SELECT')\r\n        selectEl = selectEl.parentNode;\r\n\r\n      if (selectEl)\r\n        return selectEl === document.activeElement;\r\n      else\r\n        return false;\r\n    } else {\r\n      throw new Error(\"Expected INPUT or OPTION element\");\r\n    }\r\n  }\r\n});\r\n\r\nvar ValueHandler = AttributeHandler.extend({\r\n  update: function (element, oldValue, value) {\r\n    var focused = (element === document.activeElement);\r\n\r\n    if (!focused)\r\n      element.value = value;\r\n  }\r\n});\r\n\r\n// attributes of the type 'xlink:something' should be set using\r\n// the correct namespace in order to work\r\nvar XlinkHandler = AttributeHandler.extend({\r\n  update: function(element, oldValue, value) {\r\n    var NS = 'http://www.w3.org/1999/xlink';\r\n    if (value === null) {\r\n      if (oldValue !== null)\r\n        element.removeAttributeNS(NS, this.name);\r\n    } else {\r\n      element.setAttributeNS(NS, this.name, this.value);\r\n    }\r\n  }\r\n});\r\n\r\n// cross-browser version of `instanceof SVGElement`\r\nvar isSVGElement = function (elem) {\r\n  return 'ownerSVGElement' in elem;\r\n};\r\n\r\nvar isUrlAttribute = function (tagName, attrName) {\r\n  // Compiled from http://www.w3.org/TR/REC-html40/index/attributes.html\r\n  // and\r\n  // http://www.w3.org/html/wg/drafts/html/master/index.html#attributes-1\r\n  var urlAttrs = {\r\n    FORM: ['action'],\r\n    BODY: ['background'],\r\n    BLOCKQUOTE: ['cite'],\r\n    Q: ['cite'],\r\n    DEL: ['cite'],\r\n    INS: ['cite'],\r\n    OBJECT: ['classid', 'codebase', 'data', 'usemap'],\r\n    APPLET: ['codebase'],\r\n    A: ['href'],\r\n    AREA: ['href'],\r\n    LINK: ['href'],\r\n    BASE: ['href'],\r\n    IMG: ['longdesc', 'src', 'usemap'],\r\n    FRAME: ['longdesc', 'src'],\r\n    IFRAME: ['longdesc', 'src'],\r\n    HEAD: ['profile'],\r\n    SCRIPT: ['src'],\r\n    INPUT: ['src', 'usemap', 'formaction'],\r\n    BUTTON: ['formaction'],\r\n    BASE: ['href'],\r\n    MENUITEM: ['icon'],\r\n    HTML: ['manifest'],\r\n    VIDEO: ['poster']\r\n  };\r\n\r\n  if (attrName === 'itemid') {\r\n    return true;\r\n  }\r\n\r\n  var urlAttrNames = urlAttrs[tagName] || [];\r\n  return _.contains(urlAttrNames, attrName);\r\n};\r\n\r\n// To get the protocol for a URL, we let the browser normalize it for\r\n// us, by setting it as the href for an anchor tag and then reading out\r\n// the 'protocol' property.\r\nif (Meteor.isClient) {\r\n  var anchorForNormalization = document.createElement('A');\r\n}\r\n\r\nvar normalizeUrl = function (url) {\r\n  if (Meteor.isClient) {\r\n    anchorForNormalization.href = url;\r\n    return anchorForNormalization.href;\r\n  } else {\r\n    throw new Error('normalizeUrl not implemented on the server');\r\n  }\r\n};\r\n\r\n// UrlHandler is an attribute handler for all HTML attributes that take\r\n// URL values. It disallows javascript: URLs, unless\r\n// UI._allowJavascriptUrls() has been called. To detect javascript:\r\n// urls, we set the attribute and then reads the attribute out of the\r\n// DOM, in order to avoid writing our own URL normalization code. (We\r\n// don't want to be fooled by ' javascript:alert(1)' or\r\n// 'jAvAsCrIpT:alert(1)'.) In future, when the URL interface is more\r\n// widely supported, we can use that, which will be\r\n// cleaner.  https://developer.mozilla.org/en-US/docs/Web/API/URL\r\nvar origUpdate = AttributeHandler.prototype.update;\r\nvar UrlHandler = AttributeHandler.extend({\r\n  update: function (element, oldValue, value) {\r\n    var self = this;\r\n    var args = arguments;\r\n\r\n    if (UI._javascriptUrlsAllowed()) {\r\n      origUpdate.apply(self, args);\r\n    } else {\r\n      var isJavascriptProtocol =\r\n            (normalizeUrl(value).indexOf('javascript:') === 0);\r\n      if (isJavascriptProtocol) {\r\n        Meteor._debug(\"URLs that use the 'javascript:' protocol are not \" +\r\n                      \"allowed in URL attribute values. \" +\r\n                      \"Call UI._allowJavascriptUrls() \" +\r\n                      \"to enable them.\");\r\n        origUpdate.apply(self, [element, oldValue, null]);\r\n      } else {\r\n        origUpdate.apply(self, args);\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\n// XXX make it possible for users to register attribute handlers!\r\nmakeAttributeHandler = function (elem, name, value) {\r\n  // generally, use setAttribute but certain attributes need to be set\r\n  // by directly setting a JavaScript property on the DOM element.\r\n  if (name === 'class') {\r\n    if (isSVGElement(elem)) {\r\n      return new SVGClassHandler(name, value);\r\n    } else {\r\n      return new ClassHandler(name, value);\r\n    }\r\n  } else if ((elem.tagName === 'OPTION' && name === 'selected') ||\r\n             (elem.tagName === 'INPUT' && name === 'checked')) {\r\n    return new BooleanHandler(name, value);\r\n  } else if ((elem.tagName === 'TEXTAREA' || elem.tagName === 'INPUT')\r\n             && name === 'value') {\r\n    // internally, TEXTAREAs tracks their value in the 'value'\r\n    // attribute just like INPUTs.\r\n    return new ValueHandler(name, value);\r\n  } else if (name.substring(0,6) === 'xlink:') {\r\n    return new XlinkHandler(name.substring(6), value);\r\n  } else if (isUrlAttribute(elem.tagName, name)) {\r\n    return new UrlHandler(name, value);\r\n  } else {\r\n    return new AttributeHandler(name, value);\r\n  }\r\n\r\n  // XXX will need one for 'style' on IE, though modern browsers\r\n  // seem to handle setAttribute ok.\r\n};\r\n\r\n\r\nElementAttributesUpdater = function (elem) {\r\n  this.elem = elem;\r\n  this.handlers = {};\r\n};\r\n\r\n// Update attributes on `elem` to the dictionary `attrs`, whose\r\n// values are strings.\r\nElementAttributesUpdater.prototype.update = function(newAttrs) {\r\n  var elem = this.elem;\r\n  var handlers = this.handlers;\r\n\r\n  for (var k in handlers) {\r\n    if (! newAttrs.hasOwnProperty(k)) {\r\n      // remove attributes (and handlers) for attribute names\r\n      // that don't exist as keys of `newAttrs` and so won't\r\n      // be visited when traversing it.  (Attributes that\r\n      // exist in the `newAttrs` object but are `null`\r\n      // are handled later.)\r\n      var handler = handlers[k];\r\n      var oldValue = handler.value;\r\n      handler.value = null;\r\n      handler.update(elem, oldValue, null);\r\n      delete handlers[k];\r\n    }\r\n  }\r\n\r\n  for (var k in newAttrs) {\r\n    var handler = null;\r\n    var oldValue;\r\n    var value = newAttrs[k];\r\n    if (! handlers.hasOwnProperty(k)) {\r\n      if (value !== null) {\r\n        // make new handler\r\n        handler = makeAttributeHandler(elem, k, value);\r\n        handlers[k] = handler;\r\n        oldValue = null;\r\n      }\r\n    } else {\r\n      handler = handlers[k];\r\n      oldValue = handler.value;\r\n    }\r\n    if (oldValue !== value) {\r\n      handler.value = value;\r\n      handler.update(elem, oldValue, value);\r\n      if (value === null)\r\n        delete handlers[k];\r\n    }\r\n  }\r\n};\r\n","\r\nUI.Component.instantiate = function (parent) {\r\n  var kind = this;\r\n\r\n  // check arguments\r\n  if (UI.isComponent(kind)) {\r\n    if (kind.isInited)\r\n      throw new Error(\"A component kind is required, not an instance\");\r\n  } else {\r\n    throw new Error(\"Expected Component kind\");\r\n  }\r\n\r\n  var inst = kind.extend(); // XXX args go here\r\n  inst.isInited = true;\r\n\r\n  // XXX messy to define this here\r\n  inst.templateInstance = {\r\n    findAll: function (selector) {\r\n      // XXX check that `.dom` exists here?\r\n      return inst.dom.$(selector);\r\n    },\r\n    find: function (selector) {\r\n      var result = this.findAll(selector);\r\n      return result[0] || null;\r\n    },\r\n    firstNode: null,\r\n    lastNode: null,\r\n    data: null,\r\n    __component__: inst\r\n  };\r\n  inst.templateInstance.$ = inst.templateInstance.findAll;\r\n\r\n  inst.parent = (parent || null);\r\n\r\n  if (inst.init)\r\n    inst.init();\r\n\r\n  if (inst.created) {\r\n    updateTemplateInstance(inst);\r\n    inst.created.call(inst.templateInstance);\r\n  }\r\n\r\n  return inst;\r\n};\r\n\r\nUI.Component.render = function () {\r\n  return null;\r\n};\r\n\r\nvar Box = function (func, equals) {\r\n  var self = this;\r\n\r\n  self.func = func;\r\n  self.equals = equals;\r\n\r\n  self.curResult = null;\r\n\r\n  self.dep = new Deps.Dependency;\r\n\r\n  self.resultComputation = Deps.nonreactive(function () {\r\n    return Deps.autorun(function (c) {\r\n      var func = self.func;\r\n\r\n      var newResult = func();\r\n\r\n      if (! c.firstRun) {\r\n        var equals = self.equals;\r\n        var oldResult = self.curResult;\r\n\r\n        if (equals ? equals(newResult, oldResult) :\r\n            newResult === oldResult) {\r\n          // same as last time\r\n          return;\r\n        }\r\n      }\r\n\r\n      self.curResult = newResult;\r\n      self.dep.changed();\r\n    });\r\n  });\r\n};\r\n\r\nBox.prototype.stop = function () {\r\n  this.resultComputation.stop();\r\n};\r\n\r\nBox.prototype.get = function () {\r\n  if (Deps.active && ! this.resultComputation.stopped)\r\n    this.dep.depend();\r\n\r\n  return this.curResult;\r\n};\r\n\r\n// Takes a reactive function (call it `inner`) and returns a reactive function\r\n// `outer` which is equivalent except in its reactive behavior.  Specifically,\r\n// `outer` has the following two special properties:\r\n//\r\n// 1. Isolation:  An invocation of `outer()` only invalidates its context\r\n//    when the value of `inner()` changes.  For example, `inner` may be a\r\n//    function that gets one or more Session variables and calculates a\r\n//    true/false value.  `outer` blocks invalidation signals caused by the\r\n//    Session variables changing and sends a signal out only when the value\r\n//    changes between true and false (in this example).  The value can be\r\n//    of any type, and it is compared with `===` unless an `equals` function\r\n//    is provided.\r\n//\r\n// 2. Value Sharing:  The `outer` function returned by `emboxValue` can be\r\n//    shared between different contexts, for example by assigning it to an\r\n//    object as a method that can be accessed at any time, such as by\r\n//    different templates or different parts of a template.  No matter\r\n//    how many times `outer` is called, `inner` is only called once until\r\n//    it changes.  The most recent value is stored internally.\r\n//\r\n// Conceptually, an emboxed value is much like a Session variable which is\r\n// kept up to date by an autorun.  Session variables provide storage\r\n// (value sharing) and they don't notify their listeners unless a value\r\n// actually changes (isolation).  The biggest difference is that such an\r\n// autorun would never be stopped, and the Session variable would never be\r\n// deleted even if it wasn't used any more.  An emboxed value, on the other\r\n// hand, automatically stops computing when it's not being used, and starts\r\n// again when called from a reactive context.  This means that when it stops\r\n// being used, it can be completely garbage-collected.\r\n//\r\n// If a non-function value is supplied to `emboxValue` instead of a reactive\r\n// function, then `outer` is still a function but it simply returns the value.\r\n//\r\nUI.emboxValue = function (funcOrValue, equals) {\r\n  if (typeof funcOrValue === 'function') {\r\n\r\n    var func = funcOrValue;\r\n    var box = new Box(func, equals);\r\n\r\n    var f = function () {\r\n      return box.get();\r\n    };\r\n\r\n    f.stop = function () {\r\n      box.stop();\r\n    };\r\n\r\n    return f;\r\n\r\n  } else {\r\n    var value = funcOrValue;\r\n    var result = function () {\r\n      return value;\r\n    };\r\n    result._isEmboxedConstant = true;\r\n    return result;\r\n  }\r\n};\r\n\r\n\r\nUI.namedEmboxValue = function (name, funcOrValue, equals) {\r\n  if (! Deps.active) {\r\n    var f = UI.emboxValue(funcOrValue, equals);\r\n    f.stop();\r\n    return f;\r\n  }\r\n\r\n  var c = Deps.currentComputation;\r\n  if (! c[name])\r\n    c[name] = UI.emboxValue(funcOrValue, equals);\r\n\r\n  return c[name];\r\n};\r\n\r\n////////////////////////////////////////\r\n\r\nUI.insert = function (renderedTemplate, parentElement, nextNode) {\r\n  if (! renderedTemplate.dom)\r\n    throw new Error(\"Expected template rendered with UI.render\");\r\n\r\n  UI.DomRange.insert(renderedTemplate.dom, parentElement, nextNode);\r\n};\r\n\r\n// Insert a DOM node or DomRange into a DOM element or DomRange.\r\n//\r\n// One of three things happens depending on what needs to be inserted into what:\r\n// - `range.add` (anything into DomRange)\r\n// - `UI.DomRange.insert` (DomRange into element)\r\n// - `elem.insertBefore` (node into element)\r\n//\r\n// The optional `before` argument is an existing node or id to insert before in\r\n// the parent element or DomRange.\r\nvar insert = function (nodeOrRange, parent, before) {\r\n  if (! parent)\r\n    throw new Error(\"Materialization parent required\");\r\n\r\n  if (parent instanceof UI.DomRange) {\r\n    parent.add(nodeOrRange, before);\r\n  } else if (nodeOrRange instanceof UI.DomRange) {\r\n    // parent is an element; inserting a range\r\n    UI.DomRange.insert(nodeOrRange, parent, before);\r\n  } else {\r\n    // parent is an element; inserting an element\r\n    parent.insertBefore(nodeOrRange, before || null); // `null` for IE\r\n  }\r\n};\r\n\r\nUI.render = function (kind, parentComponent) {\r\n  if (kind.isInited)\r\n    throw new Error(\"Can't render component instance, only component kind\");\r\n\r\n  var inst, content, range;\r\n\r\n  Deps.nonreactive(function () {\r\n\r\n    inst = kind.instantiate(parentComponent);\r\n\r\n    content = (inst.render && inst.render());\r\n\r\n    range = new UI.DomRange;\r\n    inst.dom = range;\r\n    range.component = inst;\r\n\r\n  });\r\n\r\n  materialize(content, range, null, inst);\r\n\r\n  range.removed = function () {\r\n    inst.isDestroyed = true;\r\n    if (inst.destroyed) {\r\n      Deps.nonreactive(function () {\r\n        updateTemplateInstance(inst);\r\n        inst.destroyed.call(inst.templateInstance);\r\n      });\r\n    }\r\n  };\r\n\r\n  return inst;\r\n};\r\n\r\nUI.renderWithData = function (kind, data, parentComponent) {\r\n  if (! UI.isComponent(kind))\r\n    throw new Error(\"Component required here\");\r\n  if (kind.isInited)\r\n    throw new Error(\"Can't render component instance, only component kind\");\r\n  if (typeof data === 'function')\r\n    throw new Error(\"Data argument can't be a function\");\r\n\r\n  return UI.render(kind.extend({data: function () { return data; }}),\r\n                   parentComponent);\r\n};\r\n\r\nvar contentEquals = function (a, b) {\r\n  if (a instanceof HTML.Raw) {\r\n    return (b instanceof HTML.Raw) && (a.value === b.value);\r\n  } else if (a == null) {\r\n    return (b == null);\r\n  } else {\r\n    return (a === b) &&\r\n      ((typeof a === 'number') || (typeof a === 'boolean') ||\r\n       (typeof a === 'string'));\r\n  }\r\n};\r\n\r\nUI.InTemplateScope = function (tmplInstance, content) {\r\n  if (! (this instanceof UI.InTemplateScope))\r\n    // called without `new`\r\n    return new UI.InTemplateScope(tmplInstance, content);\r\n\r\n  var parentPtr = tmplInstance.parent;\r\n  if (parentPtr.__isTemplateWith)\r\n    parentPtr = parentPtr.parent;\r\n\r\n  this.parentPtr = parentPtr;\r\n  this.content = content;\r\n};\r\n\r\nUI.InTemplateScope.prototype.toHTML = function (parentComponent) {\r\n  return HTML.toHTML(this.content, this.parentPtr);\r\n};\r\n\r\nUI.InTemplateScope.prototype.toText = function (textMode, parentComponent) {\r\n  return HTML.toText(this.content, textMode, this.parentPtr);\r\n};\r\n\r\n// Convert the pseudoDOM `node` into reactive DOM nodes and insert them\r\n// into the element or DomRange `parent`, before the node or id `before`.\r\nvar materialize = function (node, parent, before, parentComponent) {\r\n  // XXX should do more error-checking for the case where user is supplying the tags.\r\n  // For example, check that CharRef has `html` and `str` properties and no content.\r\n  // Check that Comment has a single string child and no attributes.  Etc.\r\n\r\n  if (node == null) {\r\n    // null or undefined.\r\n    // do nothinge.\r\n  } else if ((typeof node === 'string') || (typeof node === 'boolean') || (typeof node === 'number')) {\r\n    node = String(node);\r\n    insert(document.createTextNode(node), parent, before);\r\n  } else if (node instanceof Array) {\r\n    for (var i = 0; i < node.length; i++)\r\n      materialize(node[i], parent, before, parentComponent);\r\n  } else if (typeof node === 'function') {\r\n\r\n    var range = new UI.DomRange;\r\n    var lastContent = null;\r\n    var rangeUpdater = Deps.autorun(function (c) {\r\n      var content = node();\r\n      // normalize content a little, for easier comparison\r\n      if (HTML.isNully(content))\r\n        content = null;\r\n      else if ((content instanceof Array) && content.length === 1)\r\n        content = content[0];\r\n\r\n      // update if content is different from last time\r\n      if (! contentEquals(content, lastContent)) {\r\n        lastContent = content;\r\n\r\n        if (! c.firstRun)\r\n          range.removeAll();\r\n\r\n        materialize(content, range, null, parentComponent);\r\n      }\r\n    });\r\n    range.removed = function () {\r\n      rangeUpdater.stop();\r\n      if (node.stop)\r\n        node.stop();\r\n    };\r\n    // XXXX HACK\r\n    if (Deps.active && node.stop) {\r\n      Deps.onInvalidate(function () {\r\n        node.stop();\r\n      });\r\n    }\r\n    insert(range, parent, before);\r\n  } else if (node instanceof HTML.Tag) {\r\n    var tagName = node.tagName;\r\n    var elem;\r\n    if (HTML.isKnownSVGElement(tagName) && document.createElementNS) {\r\n      elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);\r\n    } else {\r\n      elem = document.createElement(node.tagName);\r\n    }\r\n\r\n    var rawAttrs = node.attrs;\r\n    var children = node.children;\r\n    if (node.tagName === 'textarea') {\r\n      rawAttrs = (rawAttrs || {});\r\n      rawAttrs.value = children;\r\n      children = [];\r\n    };\r\n\r\n    if (rawAttrs) {\r\n      var attrComp = Deps.autorun(function (c) {\r\n        var attrUpdater = c.updater;\r\n        if (! attrUpdater) {\r\n          attrUpdater = c.updater = new ElementAttributesUpdater(elem);\r\n        }\r\n\r\n        try {\r\n          var attrs = HTML.evaluateAttributes(rawAttrs, parentComponent);\r\n          var stringAttrs = {};\r\n          if (attrs) {\r\n            for (var k in attrs) {\r\n              stringAttrs[k] = HTML.toText(attrs[k], HTML.TEXTMODE.STRING,\r\n                                           parentComponent);\r\n            }\r\n            attrUpdater.update(stringAttrs);\r\n          }\r\n        } catch (e) {\r\n          reportUIException(e);\r\n        }\r\n      });\r\n      UI.DomBackend.onRemoveElement(elem, function () {\r\n        attrComp.stop();\r\n      });\r\n    }\r\n    materialize(children, elem, null, parentComponent);\r\n\r\n    insert(elem, parent, before);\r\n  } else if (typeof node.instantiate === 'function') {\r\n    // component\r\n    var instance = UI.render(node, parentComponent);\r\n\r\n    // Call internal callback, which may take advantage of the current\r\n    // Deps computation.\r\n    if (instance.materialized)\r\n      instance.materialized();\r\n\r\n    insert(instance.dom, parent, before);\r\n  } else if (node instanceof HTML.CharRef) {\r\n    insert(document.createTextNode(node.str), parent, before);\r\n  } else if (node instanceof HTML.Comment) {\r\n    insert(document.createComment(node.sanitizedValue), parent, before);\r\n  } else if (node instanceof HTML.Raw) {\r\n    // Get an array of DOM nodes by using the browser's HTML parser\r\n    // (like innerHTML).\r\n    var htmlNodes = UI.DomBackend.parseHTML(node.value);\r\n    for (var i = 0; i < htmlNodes.length; i++)\r\n      insert(htmlNodes[i], parent, before);\r\n  } else if (Package['html-tools'] && (node instanceof Package['html-tools'].HTMLTools.Special)) {\r\n    throw new Error(\"Can't materialize Special tag, it's just an intermediate rep\");\r\n  } else if (node instanceof UI.InTemplateScope) {\r\n    materialize(node.content, parent, before, node.parentPtr);\r\n  } else {\r\n    // can't get here\r\n    throw new Error(\"Unexpected node in htmljs: \" + node);\r\n  }\r\n};\r\n\r\n\r\n\r\n// XXX figure out the right names, and namespace, for these.\r\n// for example, maybe some of them go in the HTML package.\r\nUI.materialize = materialize;\r\n\r\nUI.body = UI.Component.extend({\r\n  kind: 'body',\r\n  contentParts: [],\r\n  render: function () {\r\n    return this.contentParts;\r\n  },\r\n  // XXX revisit how body works.\r\n  INSTANTIATED: false,\r\n  __helperHost: true\r\n});\r\n\r\nUI.block = function (renderFunc) {\r\n  return UI.Component.extend({ render: renderFunc });\r\n};\r\n\r\nUI.toHTML = function (content, parentComponent) {\r\n  return HTML.toHTML(content, parentComponent);\r\n};\r\n\r\nUI.toRawText = function (content, parentComponent) {\r\n  return HTML.toText(content, HTML.TEXTMODE.STRING, parentComponent);\r\n};\r\n","\r\nUI.If = function (argFunc, contentBlock, elseContentBlock) {\r\n  checkBlockHelperArguments('If', argFunc, contentBlock, elseContentBlock);\r\n\r\n  var f = function () {\r\n    var emboxedCondition = emboxCondition(argFunc);\r\n    f.stop = function () {\r\n      emboxedCondition.stop();\r\n    };\r\n    if (emboxedCondition())\r\n      return contentBlock;\r\n    else\r\n      return elseContentBlock || null;\r\n  };\r\n\r\n  return f;\r\n};\r\n\r\n\r\nUI.Unless = function (argFunc, contentBlock, elseContentBlock) {\r\n  checkBlockHelperArguments('Unless', argFunc, contentBlock, elseContentBlock);\r\n\r\n  var f = function () {\r\n    var emboxedCondition = emboxCondition(argFunc);\r\n    f.stop = function () {\r\n      emboxedCondition.stop();\r\n    };\r\n    if (! emboxedCondition())\r\n      return contentBlock;\r\n    else\r\n      return elseContentBlock || null;\r\n  };\r\n\r\n  return f;\r\n};\r\n\r\n// Returns true if `a` and `b` are `===`, unless they are of a mutable type.\r\n// (Because then, they may be equal references to an object that was mutated,\r\n// and we'll never know.  We save only a reference to the old object; we don't\r\n// do any deep-copying or diffing.)\r\nUI.safeEquals = function (a, b) {\r\n  if (a !== b)\r\n    return false;\r\n  else\r\n    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||\r\n            (typeof a === 'string'));\r\n};\r\n\r\n// Unlike Spacebars.With, there's no else case and no conditional logic.\r\n//\r\n// We don't do any reactive emboxing of `argFunc` here; it should be done\r\n// by the caller if efficiency and/or number of calls to the data source\r\n// is important.\r\nUI.With = function (argFunc, contentBlock) {\r\n  checkBlockHelperArguments('With', argFunc, contentBlock);\r\n\r\n  var block = contentBlock;\r\n  if ('data' in block) {\r\n    // XXX TODO: get religion about where `data` property goes\r\n    block = UI.block(function () {\r\n      return contentBlock;\r\n    });\r\n  }\r\n\r\n  block.data = function () {\r\n    throw new Error(\"Can't get data for component kind\");\r\n  };\r\n\r\n  block.init = function () {\r\n    this.data = UI.emboxValue(argFunc, UI.safeEquals);\r\n  };\r\n\r\n  block.materialized = function () {\r\n    var self = this;\r\n    if (Deps.active) {\r\n      Deps.onInvalidate(function () {\r\n        self.data.stop();\r\n      });\r\n    }\r\n  };\r\n  block.materialized.isWith = true;\r\n\r\n  return block;\r\n};\r\n\r\nUI.Each = function (argFunc, contentBlock, elseContentBlock) {\r\n  checkBlockHelperArguments('Each', argFunc, contentBlock, elseContentBlock);\r\n\r\n  return UI.EachImpl.extend({\r\n    __sequence: argFunc,\r\n    __content: contentBlock,\r\n    __elseContent: elseContentBlock\r\n  });\r\n};\r\n\r\nvar checkBlockHelperArguments = function (which, argFunc, contentBlock, elseContentBlock) {\r\n  if (typeof argFunc !== 'function')\r\n    throw new Error('First argument to ' + which + ' must be a function');\r\n  if (! UI.isComponent(contentBlock))\r\n    throw new Error('Second argument to ' + which + ' must be a template or UI.block');\r\n  if (elseContentBlock && ! UI.isComponent(elseContentBlock))\r\n    throw new Error('Third argument to ' + which + ' must be a template or UI.block if present');\r\n};\r\n\r\n// Returns a function that computes `!! conditionFunc()` except:\r\n//\r\n// - Empty array is considered falsy\r\n// - The result is UI.emboxValue'd (doesn't trigger invalidation\r\n//   as long as the condition stays truthy or stays falsy)\r\nvar emboxCondition = function (conditionFunc) {\r\n  return UI.namedEmboxValue('if/unless', function () {\r\n    // `condition` is emboxed; it is always a function,\r\n    // and it only triggers invalidation if its return\r\n    // value actually changes.  We still need to isolate\r\n    // the calculation of whether it is truthy or falsy\r\n    // in order to not re-render if it changes from one\r\n    // truthy or falsy value to another.\r\n    var cond = conditionFunc();\r\n\r\n    // empty arrays are treated as falsey values\r\n    if (cond instanceof Array && cond.length === 0)\r\n      return false;\r\n    else\r\n      return !! cond;\r\n  });\r\n};\r\n","UI.EachImpl = Component.extend({\r\n  typeName: 'Each',\r\n  render: function (modeHint) {\r\n    var self = this;\r\n    var content = self.__content;\r\n    var elseContent = self.__elseContent;\r\n\r\n    if (modeHint === 'STATIC') {\r\n      // This is a hack.  The caller gives us a hint if the\r\n      // value we return will be static (in HTML or text)\r\n      // or dynamic (materialized DOM).  The dynamic path\r\n      // returns `null` and then we populate the DOM from\r\n      // the `materialized` callback.\r\n      //\r\n      // It would be much cleaner to always return the same\r\n      // value here, and to have that value be some special\r\n      // object that encapsulates the logic for populating\r\n      // the #each using a mode-agnostic interface that\r\n      // works for HTML, text, and DOM.  Alternatively, we\r\n      // could formalize the current pattern, e.g. defining\r\n      // a method like component.populate(domRange) and one\r\n      // like renderStatic() or even renderHTML / renderText.\r\n      var parts = _.map(\r\n        ObserveSequence.fetch(self.__sequence()),\r\n        function (item) {\r\n          return content.extend({data: function () {\r\n            return item;\r\n          }});\r\n        });\r\n\r\n      if (parts.length) {\r\n        return parts;\r\n      } else {\r\n        return elseContent;\r\n      }\r\n      return parts;\r\n    } else {\r\n      return null;\r\n    }\r\n  },\r\n  materialized: function () {\r\n    var self = this;\r\n\r\n    var range = self.dom;\r\n\r\n    var content = self.__content;\r\n    var elseContent = self.__elseContent;\r\n\r\n    // if there is an else clause, keep track of the number of\r\n    // rendered items.  use this to display the else clause when count\r\n    // becomes zero, and remove it when count becomes positive.\r\n    var itemCount = 0;\r\n    var addToCount = function(delta) {\r\n      if (!elseContent) // if no else, no need to keep track of count\r\n        return;\r\n\r\n      if (itemCount + delta < 0)\r\n        throw new Error(\"count should never become negative\");\r\n\r\n      if (itemCount === 0) {\r\n        // remove else clause\r\n        range.removeAll();\r\n      }\r\n      itemCount += delta;\r\n      if (itemCount === 0) {\r\n        UI.materialize(elseContent, range, null, self);\r\n      }\r\n    };\r\n\r\n    this.observeHandle = ObserveSequence.observe(function () {\r\n      return self.__sequence();\r\n    }, {\r\n      addedAt: function (id, item, i, beforeId) {\r\n        addToCount(1);\r\n        id = LocalCollection._idStringify(id);\r\n\r\n        var data = item;\r\n        var dep = new Deps.Dependency;\r\n\r\n        // function to become `comp.data`\r\n        var dataFunc = function () {\r\n          dep.depend();\r\n          return data;\r\n        };\r\n        // Storing `$set` on `comp.data` lets us\r\n        // access it from `changed`.\r\n        dataFunc.$set = function (v) {\r\n          data = v;\r\n          dep.changed();\r\n        };\r\n\r\n        if (beforeId)\r\n          beforeId = LocalCollection._idStringify(beforeId);\r\n\r\n        var renderedItem = UI.render(content.extend({data: dataFunc}), self);\r\n        range.add(id, renderedItem.dom, beforeId);\r\n      },\r\n      removedAt: function (id, item) {\r\n        addToCount(-1);\r\n        range.remove(LocalCollection._idStringify(id));\r\n      },\r\n      movedTo: function (id, item, i, j, beforeId) {\r\n        range.moveBefore(\r\n          LocalCollection._idStringify(id),\r\n          beforeId && LocalCollection._idStringify(beforeId));\r\n      },\r\n      changedAt: function (id, newItem, atIndex) {\r\n        range.get(LocalCollection._idStringify(id)).component.data.$set(newItem);\r\n      }\r\n    });\r\n\r\n    // on initial render, display the else clause if no items\r\n    addToCount(0);\r\n  },\r\n  destroyed: function () {\r\n    if (this.__component__.observeHandle)\r\n      this.__component__.observeHandle.stop();\r\n  }\r\n});\r\n","\r\nvar global = (function () { return this; })();\r\n\r\n// Searches for the given property in `comp` or a parent,\r\n// and returns it as is (without call it if it's a function).\r\nvar lookupComponentProp = function (comp, prop) {\r\n  comp = findComponentWithProp(prop, comp);\r\n  var result = (comp ? comp.data : null);\r\n  if (typeof result === 'function')\r\n    result = _.bind(result, comp);\r\n  return result;\r\n};\r\n\r\n// Component that's a no-op when used as a block helper like\r\n// `{{#foo}}...{{/foo}}`. Prints a warning that it is deprecated.\r\nvar noOpComponent = function (name) {\r\n  return Component.extend({\r\n    kind: 'NoOp',\r\n    render: function () {\r\n      Meteor._debug(\"{{#\" + name + \"}} is now unnecessary and deprecated.\");\r\n      return this.__content;\r\n    }\r\n  });\r\n};\r\n\r\n// This map is searched first when you do something like `{{#foo}}` in\r\n// a template.\r\nvar builtInComponents = {\r\n  // for past compat:\r\n  'constant': noOpComponent(\"constant\"),\r\n  'isolate': noOpComponent(\"isolate\")\r\n};\r\n\r\n_extend(UI.Component, {\r\n  // Options:\r\n  //\r\n  // - template {Boolean} If true, look at the list of templates after\r\n  //   helpers and before data context.\r\n  lookup: function (id, opts) {\r\n    var self = this;\r\n    var template = opts && opts.template;\r\n    var result;\r\n    var comp;\r\n\r\n    if (!id)\r\n      throw new Error(\"must pass id to lookup\");\r\n\r\n    if (/^\\./.test(id)) {\r\n      // starts with a dot. must be a series of dots which maps to an\r\n      // ancestor of the appropriate height.\r\n      if (!/^(\\.)+$/.test(id)) {\r\n        throw new Error(\"id starting with dot must be a series of dots\");\r\n      }\r\n\r\n      var compWithData = findComponentWithProp('data', self);\r\n      for (var i = 1; i < id.length; i++) {\r\n        compWithData = compWithData ? findComponentWithProp('data', compWithData.parent) : null;\r\n      }\r\n\r\n      return (compWithData ? compWithData.data : null);\r\n\r\n    } else if ((comp = findComponentWithHelper(id, self))) {\r\n      // found a property or method of a component\r\n      // (`self` or one of its ancestors)\r\n      var result = comp[id];\r\n\r\n    } else if (_.has(builtInComponents, id)) {\r\n      return builtInComponents[id];\r\n\r\n    // Code to search the global namespace for capitalized names\r\n    // like component classes, `Template`, `StringUtils.foo`,\r\n    // etc.\r\n    //\r\n    // } else if (/^[A-Z]/.test(id) && (id in global)) {\r\n    //   // Only look for a global identifier if `id` is\r\n    //   // capitalized.  This avoids having `{{name}}` mean\r\n    //   // `window.name`.\r\n    //   result = global[id];\r\n    //   return function (/*arguments*/) {\r\n    //     var data = getComponentData(self);\r\n    //     if (typeof result === 'function')\r\n    //       return result.apply(data, arguments);\r\n    //     return result;\r\n    //   };\r\n    } else if (template && _.has(Template, id)) {\r\n      return Template[id];\r\n\r\n    } else if ((result = UI._globalHelper(id))) {\r\n\r\n    } else {\r\n      // Resolve id `foo` as `data.foo` (with a \"soft dot\").\r\n      return function (/*arguments*/) {\r\n        var data = getComponentData(self);\r\n        if (template && !(data && _.has(data, id)))\r\n          throw new Error(\"Can't find template, helper or data context key: \" + id);\r\n        if (! data)\r\n          return data;\r\n        var result = data[id];\r\n        if (typeof result === 'function')\r\n          return result.apply(data, arguments);\r\n        return result;\r\n      };\r\n    }\r\n\r\n    if (typeof result === 'function' && ! result._isEmboxedConstant) {\r\n      // Wrap the function `result`, binding `this` to `getComponentData(self)`.\r\n      // This creates a dependency when the result function is called.\r\n      // Don't do this if the function is really just an emboxed constant.\r\n      return function (/*arguments*/) {\r\n        var data = getComponentData(self);\r\n        return result.apply(data === null ? {} : data, arguments);\r\n      };\r\n    } else {\r\n      return result;\r\n    };\r\n  },\r\n  lookupTemplate: function (id) {\r\n    return this.lookup(id, {template: true});\r\n  },\r\n  get: function (id) {\r\n    // support `this.get()` to get the data context.\r\n    if (id === undefined)\r\n      id = \".\";\r\n\r\n    var result = this.lookup(id);\r\n    return (typeof result === 'function' ? result() : result);\r\n  },\r\n  set: function (id, value) {\r\n    var comp = findComponentWithProp(id, this);\r\n    if (! comp || ! comp[id])\r\n      throw new Error(\"Can't find field: \" + id);\r\n    if (typeof comp[id] !== 'function')\r\n      throw new Error(\"Not a settable field: \" + id);\r\n    comp[id](value);\r\n  }\r\n});\r\n","// XXX this file no longer makes sense in isolation.  take it apart as\r\n// part file reorg on the 'ui' package\r\nvar globalHelpers = {};\r\n\r\nUI.registerHelper = function (name, func) {\r\n  globalHelpers[name] = func;\r\n};\r\n\r\nUI._globalHelper = function (name) {\r\n  return globalHelpers[name];\r\n};\r\n\r\nHandlebars = {};\r\nHandlebars.registerHelper = UI.registerHelper;\r\n\r\n// Utility to HTML-escape a string.\r\nUI._escape = Handlebars._escape = (function() {\r\n  var escape_map = {\r\n    \"<\": \"&lt;\",\r\n    \">\": \"&gt;\",\r\n    '\"': \"&quot;\",\r\n    \"'\": \"&#x27;\",\r\n    \"`\": \"&#x60;\", /* IE allows backtick-delimited attributes?? */\r\n    \"&\": \"&amp;\"\r\n  };\r\n  var escape_one = function(c) {\r\n    return escape_map[c];\r\n  };\r\n\r\n  return function (x) {\r\n    return x.replace(/[&<>\"'`]/g, escape_one);\r\n  };\r\n})();\r\n\r\n// Return these from {{...}} helpers to achieve the same as returning\r\n// strings from {{{...}}} helpers\r\nHandlebars.SafeString = function(string) {\r\n  this.string = string;\r\n};\r\nHandlebars.SafeString.prototype.toString = function() {\r\n  return this.string.toString();\r\n};\r\n"]}