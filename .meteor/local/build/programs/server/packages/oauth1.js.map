{"version":3,"file":"\\packages\\oauth1.js","sources":["oauth1/oauth1_binding.js","oauth1/oauth1_server.js","oauth1/oauth1_pending_request_tokens.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,mC;AACA,6C;;AAEA,iE;AACA,6B;AACA,E;AACA,yB;AACA,+C;AACA,6C;AACA,uB;AACA,iC;AACA,8B;AACA,gC;AACA,iC;AACA,wC;AACA,wB;AACA,oB;AACA,E;;AAEA,qE;AACA,kB;;AAEA,mC;AACA,+B;AACA,K;;AAEA,sE;AACA,mD;;AAEA,uC;AACA,oB;AACA,6E;;AAEA,yC;AACA,sD;AACA,E;;AAEA,kF;AACA,kB;;AAEA,oE;AACA,wB;AACA,I;AACA,qE;AACA,mE;AACA,mC;AACA,yB;AACA,gD;;AAEA,mC;AACA,mC;AACA,wC;AACA,K;;AAEA,qE;AACA,mD;;AAEA,wC;AACA,qD;AACA,E;;AAEA,wE;AACA,kB;;AAEA,mC;AACA,iC;AACA,K;;AAEA,e;AACA,gB;AACA,G;;AAEA,4D;AACA,E;;AAEA,+D;AACA,iD;AACA,E;;AAEA,gE;AACA,kD;AACA,E;;AAEA,0D;AACA,kB;AACA,mB;AACA,iD;AACA,oD;AACA,wC;AACA,sE;AACA,wB;AACA,c;AACA,E;;AAEA,sG;AACA,kB;AACA,iE;;AAEA,sD;AACA,2B;AACA,sB;;AAEA,uB;AACA,W;AACA,4B;AACA,kC;AACA,c;;AAEA,qD;;AAEA,oD;AACA,wB;AACA,wD;;AAEA,sF;AACA,E;;AAEA,kF;AACA,kB;;AAEA,iE;AACA,iC;AACA,oB;AACA,G;;AAEA,sB;AACA,2B;AACA,6E;;AAEA,yD;AACA,sD;;AAEA,wB;AACA,O;AACA,mC;AACA,qB;AACA,gB;AACA,iC;AACA,O;AACA,iB;AACA,iB;AACA,6F;AACA,6C;AACA,G;AACA,E;;AAEA,0D;AACA,kB;AACA,oD;AACA,4D;AACA,gB;AACA,S;AACA,E;;AAEA,uD;AACA,kF;AACA,E;;AAEA,kE;AACA,kB;AACA,wD;AACA,0E;AACA,uB;AACA,E;;;;;;;;;;;;;;;;;;;ACnKA,qB;AACA,8D;;AAEA,2F;AACA,gB;AACA,oE;AACA,G;;AAEA,0B;AACA,qD;;AAEA,sC;AACA,6C;AACA,0E;AACA,0D;AACA,sD;;AAEA,gD;AACA,kD;;AAEA,uE;AACA,yC;AACA,gC;AACA,qC;AACA,M;;AAEA,wC;AACA,gC;AACA,iD;AACA,oD;AACA,Y;AACA,oF;AACA,K;;AAEA,6E;AACA,kD;AACA,c;AACA,U;AACA,gE;AACA,iE;;AAEA,oE;AACA,oE;;AAEA,gE;AACA,0C;AACA,mF;;AAEA,kE;AACA,iE;;AAEA,kD;AACA,kF;;AAEA,sC;AACA,iE;;AAEA,6C;;AAEA,iE;AACA,0C;AACA,kD;AACA,yC;AACA,6C;AACA,oC;AACA,2B;AACA,K;;AAEA,2D;AACA,wB;AACA,4D;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACxEA,E;AACA,mE;AACA,4C;AACA,E;AACA,gE;AACA,kE;AACA,2D;AACA,4D;AACA,+D;AACA,E;AACA,+D;AACA,gE;AACA,iE;AACA,E;AACA,wE;AACA,mD;AACA,E;AACA,qE;AACA,qC;;AAEA,+C;AACA,mE;AACA,oD;AACA,wC;AACA,6B;AACA,K;;AAEA,6D;AACA,sD;;;;AAIA,0D;AACA,qC;AACA,8C;AACA,8B;AACA,qD;AACA,yE;AACA,E;AACA,uE;;;AAGA,4E;AACA,oD;AACA,E;AACA,sB;AACA,+B;AACA,qC;AACA,E;AACA,6E;AACA,qB;;AAEA,uE;AACA,qE;AACA,gD;AACA,sC;AACA,Y;AACA,M;AACA,a;AACA,iD;AACA,6D;AACA,yB;AACA,K;AACA,E;;;AAGA,kF;AACA,8E;AACA,E;AACA,sB;AACA,E;AACA,8C;AACA,qB;;AAEA,8E;AACA,4B;AACA,yE;AACA,Y;AACA,uE;AACA,2C;AACA,+C;AACA,M;AACA,U;AACA,qB;AACA,G;AACA,E","sourcesContent":["var crypto = Npm.require(\"crypto\");\r\nvar querystring = Npm.require(\"querystring\");\r\n\r\n// An OAuth1 wrapper around http calls which helps get tokens and\r\n// takes care of HTTP headers\r\n//\r\n// @param config {Object}\r\n//   - consumerKey (String): oauth consumer key\r\n//   - secret (String): oauth consumer secret\r\n// @param urls {Object}\r\n//   - requestToken (String): url\r\n//   - authorize (String): url\r\n//   - accessToken (String): url\r\n//   - authenticate (String): url\r\nOAuth1Binding = function(config, urls) {\r\n  this._config = config;\r\n  this._urls = urls;\r\n};\r\n\r\nOAuth1Binding.prototype.prepareRequestToken = function(callbackUrl) {\r\n  var self = this;\r\n\r\n  var headers = self._buildHeader({\r\n    oauth_callback: callbackUrl\r\n  });\r\n\r\n  var response = self._call('POST', self._urls.requestToken, headers);\r\n  var tokens = querystring.parse(response.content);\r\n\r\n  if (!tokens.oauth_callback_confirmed)\r\n    throw new Error(\r\n      \"oauth_callback_confirmed false when requesting oauth1 token\", tokens);\r\n\r\n  self.requestToken = tokens.oauth_token;\r\n  self.requestTokenSecret = tokens.oauth_token_secret;\r\n};\r\n\r\nOAuth1Binding.prototype.prepareAccessToken = function(query, requestTokenSecret) {\r\n  var self = this;\r\n\r\n  // support implementations that use request token secrets. This is\r\n  // read by self._call.\r\n  //\r\n  // XXX make it a param to call, not something stashed on self? It's\r\n  // kinda confusing right now, everything except this is passed as\r\n  // arguments, but this is stored.\r\n  if (requestTokenSecret)\r\n    self.accessTokenSecret = requestTokenSecret;\r\n\r\n  var headers = self._buildHeader({\r\n    oauth_token: query.oauth_token,\r\n    oauth_verifier: query.oauth_verifier\r\n  });\r\n\r\n  var response = self._call('POST', self._urls.accessToken, headers);\r\n  var tokens = querystring.parse(response.content);\r\n\r\n  self.accessToken = tokens.oauth_token;\r\n  self.accessTokenSecret = tokens.oauth_token_secret;\r\n};\r\n\r\nOAuth1Binding.prototype.call = function(method, url, params, callback) {\r\n  var self = this;\r\n\r\n  var headers = self._buildHeader({\r\n    oauth_token: self.accessToken\r\n  });\r\n\r\n  if(!params) {\r\n    params = {};\r\n  }\r\n\r\n  return self._call(method, url, headers, params, callback);\r\n};\r\n\r\nOAuth1Binding.prototype.get = function(url, params, callback) {\r\n  return this.call('GET', url, params, callback);\r\n};\r\n\r\nOAuth1Binding.prototype.post = function(url, params, callback) {\r\n  return this.call('POST', url, params, callback);\r\n};\r\n\r\nOAuth1Binding.prototype._buildHeader = function(headers) {\r\n  var self = this;\r\n  return _.extend({\r\n    oauth_consumer_key: self._config.consumerKey,\r\n    oauth_nonce: Random.secret().replace(/\\W/g, ''),\r\n    oauth_signature_method: 'HMAC-SHA1',\r\n    oauth_timestamp: (new Date().valueOf()/1000).toFixed().toString(),\r\n    oauth_version: '1.0'\r\n  }, headers);\r\n};\r\n\r\nOAuth1Binding.prototype._getSignature = function(method, url, rawHeaders, accessTokenSecret, params) {\r\n  var self = this;\r\n  var headers = self._encodeHeader(_.extend(rawHeaders, params));\r\n\r\n  var parameters = _.map(headers, function(val, key) {\r\n    return key + '=' + val;\r\n  }).sort().join('&');\r\n\r\n  var signatureBase = [\r\n    method,\r\n    self._encodeString(url),\r\n    self._encodeString(parameters)\r\n  ].join('&');\r\n\r\n  var secret = OAuth.openSecret(self._config.secret);\r\n\r\n  var signingKey = self._encodeString(secret) + '&';\r\n  if (accessTokenSecret)\r\n    signingKey += self._encodeString(accessTokenSecret);\r\n\r\n  return crypto.createHmac('SHA1', signingKey).update(signatureBase).digest('base64');\r\n};\r\n\r\nOAuth1Binding.prototype._call = function(method, url, headers, params, callback) {\r\n  var self = this;\r\n\r\n  // all URLs to be functions to support parameters/customization\r\n  if(typeof url === \"function\") {\r\n    url = url(self);\r\n  }\r\n\r\n  // Get the signature\r\n  headers.oauth_signature =\r\n    self._getSignature(method, url, headers, self.accessTokenSecret, params);\r\n\r\n  // Make a authorization string according to oauth1 spec\r\n  var authString = self._getAuthHeaderString(headers);\r\n\r\n  // Make signed request\r\n  try {\r\n    return HTTP.call(method, url, {\r\n      params: params,\r\n      headers: {\r\n        Authorization: authString\r\n      }\r\n    }, callback);\r\n  } catch (err) {\r\n    throw _.extend(new Error(\"Failed to send OAuth1 request to \" + url + \". \" + err.message),\r\n                   {response: err.response});\r\n  }\r\n};\r\n\r\nOAuth1Binding.prototype._encodeHeader = function(header) {\r\n  var self = this;\r\n  return _.reduce(header, function(memo, val, key) {\r\n    memo[self._encodeString(key)] = self._encodeString(val);\r\n    return memo;\r\n  }, {});\r\n};\r\n\r\nOAuth1Binding.prototype._encodeString = function(str) {\r\n  return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\r\n};\r\n\r\nOAuth1Binding.prototype._getAuthHeaderString = function(headers) {\r\n  var self = this;\r\n  return 'OAuth ' +  _.map(headers, function(val, key) {\r\n    return self._encodeString(key) + '=\"' + self._encodeString(val) + '\"';\r\n  }).sort().join(', ');\r\n};\r\n","// connect middleware\r\nOAuth._requestHandlers['1'] = function (service, query, res) {\r\n\r\n  var config = ServiceConfiguration.configurations.findOne({service: service.serviceName});\r\n  if (!config) {\r\n    throw new ServiceConfiguration.ConfigError(service.serviceName);\r\n  }\r\n\r\n  var urls = service.urls;\r\n  var oauthBinding = new OAuth1Binding(config, urls);\r\n\r\n  if (query.requestTokenAndRedirect) {\r\n    // step 1 - get and store a request token\r\n    var callbackUrl = Meteor.absoluteUrl(\"_oauth/\" + service.serviceName +\r\n                                         \"?close&state=\" +\r\n                                         query.state);\r\n\r\n    // Get a request token to start auth process\r\n    oauthBinding.prepareRequestToken(callbackUrl);\r\n\r\n    // Keep track of request token so we can verify it on the next step\r\n    OAuth._storeRequestToken(query.state,\r\n      oauthBinding.requestToken,\r\n      oauthBinding.requestTokenSecret\r\n    );\r\n\r\n    // support for scope/name parameters\r\n    var redirectUrl = undefined;\r\n    if(typeof urls.authenticate === \"function\") {\r\n      redirectUrl = urls.authenticate(oauthBinding);\r\n    } else {\r\n      redirectUrl = urls.authenticate + '?oauth_token=' + oauthBinding.requestToken;\r\n    }\r\n\r\n    // redirect to provider login, which will redirect back to \"step 2\" below\r\n    res.writeHead(302, {'Location': redirectUrl});\r\n    res.end();\r\n  } else {\r\n    // step 2, redirected from provider login - store the result\r\n    // and close the window to allow the login handler to proceed\r\n\r\n    // Get the user's request token so we can verify it and clear it\r\n    var requestTokenInfo = OAuth._retrieveRequestToken(query.state);\r\n\r\n    // Verify user authorized access and the oauth_token matches\r\n    // the requestToken from previous step\r\n    if (query.oauth_token && query.oauth_token === requestTokenInfo.requestToken) {\r\n\r\n      // Prepare the login results before returning.  This way the\r\n      // subsequent call to the `login` method will be immediate.\r\n\r\n      // Get the access token for signing requests\r\n      oauthBinding.prepareAccessToken(query, requestTokenInfo.requestTokenSecret);\r\n\r\n      // Run service-specific handler.\r\n      var oauthResult = service.handleOauthRequest(oauthBinding);\r\n\r\n      var credentialSecret = Random.secret();\r\n\r\n      // Store the login result so it can be retrieved in another\r\n      // browser tab by the result handler\r\n      OAuth._storePendingCredential(query.state, {\r\n        serviceName: service.serviceName,\r\n        serviceData: oauthResult.serviceData,\r\n        options: oauthResult.options\r\n      }, credentialSecret);\r\n    }\r\n\r\n    // Either close the window, redirect, or render nothing\r\n    // if all else fails\r\n    OAuth._renderOauthResults(res, query, credentialSecret);\r\n  }\r\n};\r\n","//\r\n// _pendingRequestTokens are request tokens that have been received\r\n// but not yet fully authorized (processed).\r\n//\r\n// During the oauth1 authorization process, the Meteor App opens\r\n// a pop-up, requests a request token from the oauth1 service, and\r\n// redirects the browser to the oauth1 service for the user\r\n// to grant authorization.  The user is then returned to the\r\n// Meteor Apps' callback url and the request token is verified.\r\n//\r\n// When Meteor Apps run on multiple servers, it's possible that\r\n// 2 different servers may be used to generate the request token\r\n// and to verify it in the callback once the user has authorized.\r\n//\r\n// For this reason, the _pendingRequestTokens are stored in the database\r\n// so they can be shared across Meteor App servers.\r\n//\r\n// XXX This code is fairly similar to oauth/pending_credentials.js --\r\n// maybe we can combine them somehow.\r\n\r\n// Collection containing pending request tokens\r\n// Has key, requestToken, requestTokenSecret, and createdAt fields.\r\nOAuth._pendingRequestTokens = new Meteor.Collection(\r\n  \"meteor_oauth_pendingRequestTokens\", {\r\n    _preventAutopublish: true\r\n  });\r\n\r\nOAuth._pendingRequestTokens._ensureIndex('key', {unique: 1});\r\nOAuth._pendingRequestTokens._ensureIndex('createdAt');\r\n\r\n\r\n\r\n// Periodically clear old entries that never got completed\r\nvar _cleanStaleResults = function() {\r\n  // Remove request tokens older than 5 minute\r\n  var timeCutoff = new Date();\r\n  timeCutoff.setMinutes(timeCutoff.getMinutes() - 5);\r\n  OAuth._pendingRequestTokens.remove({ createdAt: { $lt: timeCutoff } });\r\n};\r\nvar _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000);\r\n\r\n\r\n// Stores the key and request token in the _pendingRequestTokens collection.\r\n// Will throw an exception if `key` is not a string.\r\n//\r\n// @param key {string}\r\n// @param requestToken {string}\r\n// @param requestTokenSecret {string}\r\n//\r\nOAuth._storeRequestToken = function (key, requestToken, requestTokenSecret) {\r\n  check(key, String);\r\n\r\n  // We do an upsert here instead of an insert in case the user happens\r\n  // to somehow send the same `state` parameter twice during an OAuth\r\n  // login; we don't want a duplicate key error.\r\n  OAuth._pendingRequestTokens.upsert({\r\n    key: key\r\n  }, {\r\n    key: key,\r\n    requestToken: OAuth.sealSecret(requestToken),\r\n    requestTokenSecret: OAuth.sealSecret(requestTokenSecret),\r\n    createdAt: new Date()\r\n  });\r\n};\r\n\r\n\r\n// Retrieves and removes a request token from the _pendingRequestTokens collection\r\n// Returns an object containing requestToken and requestTokenSecret properties\r\n//\r\n// @param key {string}\r\n//\r\nOAuth._retrieveRequestToken = function (key) {\r\n  check(key, String);\r\n\r\n  var pendingRequestToken = OAuth._pendingRequestTokens.findOne({ key: key });\r\n  if (pendingRequestToken) {\r\n    OAuth._pendingRequestTokens.remove({ _id: pendingRequestToken._id });\r\n    return {\r\n      requestToken: OAuth.openSecret(pendingRequestToken.requestToken),\r\n      requestTokenSecret: OAuth.openSecret(\r\n        pendingRequestToken.requestTokenSecret)\r\n    };\r\n  } else {\r\n    return undefined;\r\n  }\r\n};\r\n"]}