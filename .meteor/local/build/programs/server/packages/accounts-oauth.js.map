{"version":3,"file":"\\packages\\accounts-oauth.js","sources":["accounts-oauth/oauth_common.js","accounts-oauth/oauth_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,oB;;AAEA,kB;;AAEA,wD;AACA,uD;AACA,kD;AACA,4B;AACA,kD;AACA,wB;;AAEA,sB;AACA,+E;AACA,gF;AACA,gF;AACA,wB;AACA,yD;AACA,sD;AACA,G;AACA,E;;AAEA,2C;AACA,0B;AACA,E;;;;;;;;;;;;;;;;;;;ACvBA,qE;AACA,oD;AACA,kD;AACA,qB;AACA,qC;;AAEA,wB;AACA,4B;AACA,uE;AACA,mE;AACA,uE;AACA,6B;AACA,+C;AACA,K;;AAEA,sE;AACA,wE;;AAEA,gB;AACA,qE;AACA,qE;AACA,qE;AACA,qD;AACA,M;AACA,oE;AACA,iE;AACA,sD;AACA,yE;AACA,sE;AACA,qE;AACA,sB;AACA,M;AACA,mE;AACA,2B;AACA,qC;AACA,yD;AACA,oD;AACA,G;;AAEA,8B;AACA,qE;AACA,mB;AACA,iB;AACA,M;AACA,kH;AACA,G","sourcesContent":["Accounts.oauth = {};\r\n\r\nvar services = {};\r\n\r\n// Helper for registering OAuth based accounts packages.\r\n// On the server, adds an index to the user collection.\r\nAccounts.oauth.registerService = function (name) {\r\n  if (_.has(services, name))\r\n    throw new Error(\"Duplicate service: \" + name);\r\n  services[name] = true;\r\n\r\n  if (Meteor.server) {\r\n    // Accounts.updateOrCreateUserFromExternalService does a lookup by this id,\r\n    // so this should be a unique index. You might want to add indexes for other\r\n    // fields returned by your service (eg services.github.login) but you can do\r\n    // that in your app.\r\n    Meteor.users._ensureIndex('services.' + name + '.id',\r\n                              {unique: 1, sparse: 1});\r\n  }\r\n};\r\n\r\nAccounts.oauth.serviceNames = function () {\r\n  return _.keys(services);\r\n};\r\n","// Listen to calls to `login` with an oauth option set. This is where\r\n// users actually get logged in to meteor via oauth.\r\nAccounts.registerLoginHandler(function (options) {\r\n  if (!options.oauth)\r\n    return undefined; // don't handle\r\n\r\n  check(options.oauth, {\r\n    credentialToken: String,\r\n    // When an error occurs while retrieving the access token, we store\r\n    // the error in the pending credentials table, with a secret of\r\n    // null. The client can call the login method with a secret of null\r\n    // to retrieve the error.\r\n    credentialSecret: Match.OneOf(null, String)\r\n  });\r\n\r\n  var result = OAuth.retrieveCredential(options.oauth.credentialToken,\r\n                                        options.oauth.credentialSecret);\r\n\r\n  if (!result) {\r\n    // OAuth credentialToken is not recognized, which could be either\r\n    // because the popup was closed by the user before completion, or\r\n    // some sort of error where the oauth provider didn't talk to our\r\n    // server correctly and closed the popup somehow.\r\n    //\r\n    // We assume it was user canceled and report it as such, using a\r\n    // numeric code that the client recognizes (XXX this will get\r\n    // replaced by a symbolic error code at some point\r\n    // https://trello.com/c/kMkw800Z/53-official-ddp-specification). This\r\n    // will mask failures where things are misconfigured such that the\r\n    // server doesn't see the request but does close the window. This\r\n    // seems unlikely.\r\n    //\r\n    // XXX we want `type` to be the service name such as \"facebook\"\r\n    return { type: \"oauth\",\r\n             error: new Meteor.Error(\r\n               Accounts.LoginCancelledError.numericError,\r\n               \"No matching login attempt found\") };\r\n  }\r\n\r\n  if (result instanceof Error)\r\n    // We tried to login, but there was a fatal error. Report it back\r\n    // to the user.\r\n    throw result;\r\n  else\r\n    return Accounts.updateOrCreateUserFromExternalService(result.serviceName, result.serviceData, result.options);\r\n});\r\n"]}