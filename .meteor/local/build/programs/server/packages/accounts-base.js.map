{"version":3,"file":"\\packages\\accounts-base.js","sources":["accounts-base/accounts_common.js","accounts-base/accounts_server.js","accounts-base/url_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,c;;AAEA,qE;AACA,4B;AACA,uB;;AAEA,iD;AACA,uC;AACA,8E;AACA,6E;AACA,0D;AACA,mD;AACA,0D;AACA,qD;AACA,gF;AACA,S;AACA,sC;;AAEA,sE;AACA,kB;AACA,E;AACA,qE;AACA,+C;AACA,sE;AACA,oE;AACA,qD;AACA,E;AACA,iD;AACA,oC;AACA,uE;AACA,sB;AACA,0C;AACA,wD;AACA,uD;AACA,sE;AACA,mC;AACA,mC;AACA,yE;AACA,gB;AACA,E;AACA,qC;AACA,yE;AACA,6E;AACA,gF;AACA,2E;AACA,+B;AACA,wB;AACA,0D;AACA,+D;AACA,+E;AACA,sD;AACA,8E;AACA,6E;AACA,G;;AAEA,8D;AACA,oE;AACA,yC;AACA,yC;AACA,wB;AACA,uF;AACA,sC;AACA,2F;AACA,gF;AACA,gD;AACA,G;;AAEA,yB;AACA,2E;AACA,8E;AACA,0C;AACA,uC;AACA,8D;AACA,K;AACA,K;;AAEA,oC;AACA,qC;AACA,yB;AACA,qC;AACA,kE;AACA,c;AACA,8C;AACA,O;AACA,K;AACA,K;;AAEA,6E;AACA,4C;AACA,sB;AACA,oC;AACA,E;;AAEA,sB;AACA,uE;AACA,+D;AACA,uE;AACA,I;AACA,sE;AACA,4D;AACA,6B;AACA,0C;;AAEA,yD;AACA,0D;AACA,uE;AACA,+D;AACA,kE;AACA,gE;AACA,M;AACA,mE;AACA,4D;AACA,sC;AACA,wD;AACA,G;AACA,C;;AAEA,uE;AACA,kE;AACA,qD;AACA,E;AACA,+C;AACA,4B;AACA,uE;AACA,G;AACA,gE;AACA,c;;AAEA,uF;AACA,4B;AACA,4B;AACA,0D;AACA,2E;AACA,0D;AACA,G;;AAEA,sE;AACA,oC;AACA,sD;AACA,6B;AACA,E;;AAEA,6E;AACA,6E;AACA,oC;AACA,sD;AACA,qD;AACA,6E;;AAEA,kC;AACA,oD;AACA,+D;AACA,E;;AAEA,6C;AACA,2E;AACA,gC;AACA,qE;AACA,E;;AAEA,8C;AACA,gD;AACA,4D;AACA,uC;AACA,qC;AACA,uD;AACA,E;;;;;;;;;;;;;;;;;;;ACtKA,mC;;AAEA,G;AACA,gB;AACA,G;;AAEA,6B;AACA,sE;AACA,kE;AACA,oE;AACA,gE;AACA,kE;AACA,mE;AACA,kE;AACA,mE;AACA,oB;AACA,uD;AACA,yB;AACA,gH;AACA,kC;AACA,E;;AAEA,2B;AACA,+B;AACA,c;AACA,gB;AACA,sC;AACA,E;;;AAGA,G;AACA,e;AACA,G;;AAEA,2D;AACA,mC;;AAEA,kE;AACA,4B;AACA,0C;AACA,G;AACA,mC;AACA,iD;AACA,G;;AAEA,iD;AACA,0C;AACA,E;;AAEA,oC;AACA,oC;AACA,E;;AAEA,2C;AACA,2C;AACA,E;;;AAGA,mE;AACA,0C;AACA,E;AACA,iE;AACA,2C;AACA,wC;AACA,uB;AACA,E;;AAEA,oD;AACA,8C;AACA,Y;AACA,S;AACA,sE;AACA,K;AACA,e;AACA,8B;AACA,sE;AACA,uE;AACA,8C;AACA,sD;AACA,wB;AACA,kB;AACA,K;AACA,gB;AACA,8B;AACA,+D;AACA,oE;AACA,yB;AACA,iE;AACA,K;AACA,gB;AACA,K;AACA,E;;;AAGA,sD;AACA,wC;AACA,8D;AACA,gB;AACA,K;AACA,E;;AAEA,kD;AACA,+C;AACA,8D;AACA,gB;AACA,K;AACA,E;;;AAGA,G;AACA,iB;AACA,G;;AAEA,gE;AACA,mD;AACA,E;AACA,e;AACA,a;AACA,oB;AACA,E;AACA,gE;AACA,gE;AACA,kE;AACA,8B;AACA,E;AACA,sE;AACA,oB;AACA,E;AACA,E;AACA,4D;AACA,oE;AACA,U;AACA,E;AACA,U;AACA,+D;AACA,0B;AACA,E;AACA,W;AACA,sE;AACA,E;AACA,Y;AACA,8D;AACA,6C;AACA,E;AACA,a;AACA,mE;AACA,qC;AACA,E;AACA,uB;AACA,mE;AACA,gE;AACA,8B;AACA,E;AACA,oE;AACA,kE;AACA,sE;AACA,gE;AACA,uB;AACA,E;AACA,oE;AACA,kE;;;AAGA,mE;AACA,sE;AACA,qC;AACA,E;AACA,0C;AACA,a;AACA,O;AACA,kB;AACA,G;AACA,a;AACA,wB;AACA,G;;AAEA,qC;AACA,uB;;AAEA,gB;AACA,E;;;AAGA,iC;AACA,E;AACA,qE;AACA,sE;AACA,sE;AACA,kE;AACA,U;AACA,E;AACA,mE;AACA,oE;AACA,qE;AACA,2B;AACA,wE;AACA,4B;AACA,8D;AACA,0D;AACA,G;;AAEA,kE;AACA,2D;AACA,gE;AACA,yD;AACA,4D;AACA,iB;AACA,uC;AACA,4B;AACA,a;AACA,kC;AACA,uD;AACA,M;AACA,K;;AAEA,qC;;AAEA,U;AACA,e;AACA,mC;AACA,mE;AACA,I;AACA,E;;;AAGA,kE;AACA,oE;AACA,8D;AACA,E;AACA,qE;AACA,6B;AACA,E;AACA,gF;AACA,c;AACA,0C;;AAEA,8E;AACA,mE;AACA,8D;AACA,sC;AACA,wE;;AAEA,W;AACA,oB;AACA,+C;;AAEA,iB;AACA,mC;AACA,iD;AACA,2B;AACA,0C;AACA,I;AACA,mB;AACA,iC;AACA,W;AACA,wB;;AAEA,+E;AACA,+E;AACA,oC;AACA,sD;;AAEA,wB;AACA,uB;AACA,2E;AACA,0B;AACA,M;AACA,0D;AACA,e;AACA,G;AACA,Q;AACA,sD;AACA,wB;AACA,G;AACA,E;;;AAGA,sE;AACA,+D;AACA,8B;AACA,E;AACA,uF;AACA,sB;AACA,qB;AACA,e;AACA,e;AACA,4B;AACA,I;AACA,E;;;AAGA,sE;AACA,wE;AACA,oE;AACA,uE;AACA,sE;AACA,qE;AACA,yE;AACA,4F;AACA,iB;AACA,mC;AACA,mB;AACA,wB;AACA,2B;AACA,0C;AACA,I;AACA,oB;AACA,uD;;AAEA,sD;AACA,oD;AACA,wE;AACA,0B;AACA,iB;AACA,E;;;AAGA,G;AACA,kB;AACA,G;;AAEA,mC;AACA,uB;;AAEA,8D;AACA,E;AACA,oE;AACA,kE;AACA,E;AACA,oE;AACA,2D;AACA,E;AACA,uE;AACA,uE;AACA,uC;AACA,iC;;AAEA,yD;AACA,kB;AACA,mB;AACA,gB;AACA,G;AACA,qD;AACA,E;;;AAGA,+D;AACA,uE;AACA,qE;AACA,qE;AACA,wE;AACA,uE;AACA,E;AACA,kF;AACA,iE;AACA,wD;;AAEA,qE;AACA,sE;AACA,qB;AACA,6D;AACA,kD;AACA,mC;;AAEA,gC;AACA,mB;AACA,mB;AACA,+D;AACA,O;AACA,M;;AAEA,e;AACA,oB;AACA,kC;AACA,yF;AACA,G;;AAEA,U;AACA,e;AACA,0E;AACA,I;AACA,E;;AAEA,kD;AACA,E;AACA,8D;AACA,0C;AACA,E;AACA,oE;AACA,oE;AACA,sB;AACA,uD;AACA,+B;AACA,Y;AACA,sC;AACA,c;AACA,sC;AACA,+B;AACA,S;AACA,O;AACA,K;AACA,K;AACA,E;;AAEA,mE;AACA,8B;AACA,gB;AACA,2B;AACA,iE;AACA,+E;AACA,8C;AACA,4B;AACA,oB;;AAEA,6E;AACA,wC;AACA,2B;;AAEA,iD;;AAEA,0D;AACA,I;;AAEA,sB;AACA,4D;AACA,gE;AACA,6B;AACA,gD;AACA,yB;AACA,I;;AAEA,+E;AACA,0E;AACA,4E;AACA,0C;AACA,I;AACA,0B;AACA,uE;AACA,wE;AACA,qE;AACA,iE;AACA,qE;AACA,qE;AACA,iE;AACA,sE;AACA,0B;AACA,I;AACA,+D;AACA,mC;AACA,oB;AACA,kD;AACA,e;AACA,2C;AACA,O;AACA,O;AACA,e;AACA,iE;AACA,0E;AACA,+E;AACA,6E;AACA,c;AACA,oD;AACA,2D;AACA,+B;AACA,mC;AACA,e;AACA,wD;AACA,yD;AACA,U;AACA,sF;AACA,S;AACA,qC;AACA,gF;AACA,oC;AACA,0C;AACA,sD;AACA,mD;AACA,0E;AACA,6E;AACA,mB;AACA,c;AACA,8B;AACA,8D;AACA,Q;AACA,Y;AACA,uD;AACA,K;AACA,I;;AAEA,gE;AACA,wE;AACA,uE;AACA,oD;AACA,I;AACA,oB;AACA,kE;AACA,yC;AACA,4B;AACA,oB;AACA,kD;AACA,kD;AACA,O;AACA,kC;AACA,uD;AACA,K;AACA,8D;AACA,oE;AACA,uE;AACA,qB;AACA,yE;AACA,qC;AACA,uC;AACA,+B;AACA,+D;AACA,O;AACA,M;AACA,yE;AACA,oD;AACA,K;AACA,gE;AACA,oD;AACA,6D;AACA,yD;AACA,I;;AAEA,oE;AACA,gE;AACA,oC;AACA,kC;AACA,oB;AACA,wB;AACA,uD;AACA,K;AACA,mE;AACA,sC;AACA,c;AACA,6E;AACA,O;AACA,O;AACA,G;AACA,G;;AAEA,G;AACA,gB;AACA,G;;AAEA,yD;AACA,qB;;AAEA,sE;AACA,6D;AACA,2D;AACA,uC;AACA,6B;AACA,E;;AAEA,kE;AACA,uC;;AAEA,uE;AACA,kD;AACA,Y;AACA,W;;AAEA,0B;AACA,uB;AACA,M;AACA,wB;AACA,E;;AAEA,kD;AACA,wD;AACA,kC;AACA,6C;AACA,sC;AACA,K;AACA,G;;;AAGA,G;AACA,oB;AACA,G;AACA,mD;;AAEA,kD;AACA,yC;AACA,0B;AACA,+B;AACA,E;;;AAGA,uC;AACA,sD;AACA,kB;AACA,kC;AACA,+D;AACA,I;AACA,E;;;AAGA,kE;AACA,gE;AACA,S;AACA,0E;AACA,sC;AACA,qB;AACA,sB;AACA,U;AACA,kB;AACA,kD;AACA,O;AACA,I;AACA,E;;;AAGA,sB;AACA,qE;AACA,mC;AACA,W;AACA,6C;AACA,S;AACA,I;AACA,E;;;AAGA,mD;AACA,sB;AACA,W;AACA,+C;AACA,I;AACA,E;;AAEA,gE;AACA,wE;AACA,mD;AACA,oC;;AAEA,Y;AACA,oD;AACA,kD;AACA,E;;AAEA,uE;AACA,qE;AACA,c;AACA,yD;AACA,wD;AACA,2D;AACA,2B;AACA,+D;AACA,kE;AACA,kE;AACA,mE;AACA,sD;AACA,Y;AACA,sD;AACA,qB;AACA,K;AACA,G;AACA,E;;AAEA,mD;AACA,8D;AACA,E;;AAEA,8B;AACA,mE;AACA,2C;AACA,kE;;AAEA,iB;AACA,wE;AACA,qE;AACA,wE;AACA,qE;AACA,8B;AACA,M;AACA,sE;AACA,uE;AACA,2D;AACA,wE;AACA,wE;AACA,wE;AACA,qD;AACA,qD;AACA,8B;AACA,4B;AACA,qE;AACA,kE;AACA,gE;AACA,uC;AACA,oB;AACA,2D;AACA,iD;AACA,4B;AACA,mC;AACA,U;AACA,8B;AACA,6B;AACA,kE;AACA,uE;AACA,0B;AACA,S;AACA,S;;AAEA,4E;AACA,4E;AACA,qD;AACA,Q;AACA,0E;AACA,gF;AACA,yE;AACA,+E;AACA,8D;AACA,uB;AACA,e;AACA,O;;AAEA,+D;AACA,iE;AACA,4E;AACA,O;;AAEA,0D;;AAEA,gC;AACA,0E;AACA,wE;AACA,wE;AACA,uE;AACA,6D;AACA,2B;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,mC;AACA,2D;AACA,sB;AACA,qB;;AAEA,gC;;AAEA,6D;;AAEA,mE;AACA,sE;AACA,a;AACA,kC;AACA,8D;;AAEA,e;AACA,qE;AACA,oE;AACA,kE;AACA,qE;AACA,2B;AACA,iC;AACA,Y;AACA,iE;AACA,6D;AACA,O;AACA,O;AACA,G;;AAEA,a;AACA,Y;AACA,gG;AACA,M;;AAEA,+D;AACA,mE;AACA,oB;AACA,4B;AACA,yE;AACA,6C;AACA,K;AACA,c;AACA,kC;AACA,U;AACA,uE;AACA,4C;AACA,O;AACA,iC;AACA,G;;AAEA,2D;AACA,iC;AACA,Y;AACA,uB;AACA,oF;AACA,M;;AAEA,oE;AACA,8B;AACA,oE;AACA,mE;AACA,kE;AACA,oE;AACA,qC;AACA,wB;AACA,O;AACA,sB;AACA,2D;AACA,Q;AACA,mB;AACA,wC;AACA,qC;AACA,4B;AACA,S;AACA,Q;AACA,M;;AAEA,mE;AACA,sE;AACA,0D;AACA,mC;AACA,c;AACA,kE;AACA,O;AACA,O;AACA,G;;AAEA,U;AACA,qB;AACA,wB;AACA,4B;AACA,sB;AACA,K;AACA,I;AACA,G;;AAEA,mD;AACA,E;AACA,mD;AACA,oD;AACA,E;;AAEA,G;AACA,oB;AACA,G;;AAEA,wB;;AAEA,2E;AACA,gC;AACA,E;AACA,2D;AACA,qE;AACA,sE;AACA,4B;AACA,gF;AACA,6C;;AAEA,0E;AACA,qE;AACA,+E;AACA,G;;AAEA,sC;AACA,6C;AACA,+C;;;AAGA,+E;AACA,2B;AACA,4C;AACA,U;AACA,uE;AACA,uE;AACA,K;AACA,O;AACA,Y;AACA,sC;AACA,c;AACA,6C;AACA,6C;AACA,S;AACA,O;AACA,K;AACA,sB;AACA,0E;AACA,oB;AACA,E;;AAEA,6C;AACA,0D;AACA,yD;AACA,4B;AACA,8C;AACA,+B;AACA,G;AACA,E;;AAEA,sD;AACA,oE;;;AAGA,G;AACA,4B;AACA,G;;AAEA,iG;;;AAGA,wC;AACA,0D;AACA,E;;;AAGA,sE;AACA,sE;AACA,kE;AACA,sE;AACA,gE;AACA,wB;AACA,E;AACA,+D;AACA,8C;AACA,iC;AACA,2D;AACA,wE;AACA,6B;AACA,K;AACA,E;;;AAGA,qE;AACA,S;AACA,E;AACA,kE;AACA,qE;AACA,kE;AACA,kE;AACA,mD;;AAEA,4B;AACA,8B;AACA,W;;AAEA,4B;AACA,0D;;AAEA,oD;AACA,kC;AACA,8C;AACA,U;AACA,+B;AACA,iD;AACA,mB;AACA,iB;AACA,qD;AACA,W;AACA,Q;AACA,O;AACA,G;;;AAGA,G;AACA,qB;AACA,G;;AAEA,4B;AACA,yC;AACA,uB;AACA,uD;AACA,M;AACA,4B;AACA,E;;AAEA,4E;AACA,oC;AACA,sD;AACA,sB;AACA,mC;AACA,c;AACA,E;;AAEA,8B;AACA,mD;AACA,wD;AACA,8B;AACA,mE;AACA,4C;AACA,I;AACA,oE;AACA,iD;AACA,mE;AACA,iE;AACA,kE;AACA,iE;AACA,iB;AACA,mE;;AAEA,oB;AACA,kD;AACA,sD;AACA,O;;AAEA,e;AACA,yB;AACA,+C;;AAEA,2E;AACA,yE;AACA,iE;AACA,yC;AACA,sD;AACA,U;AACA,oD;AACA,G;;AAEA,gD;AACA,wB;AACA,4D;AACA,K;;AAEA,a;AACA,O;AACA,2C;AACA,e;AACA,sC;AACA,yE;AACA,yC;AACA,0E;AACA,wB;AACA,mD;AACA,2D;AACA,4C;AACA,8D;AACA,yE;AACA,Y;AACA,G;AACA,gB;AACA,E;;AAEA,8B;AACA,4C;AACA,kC;AACA,E;;AAEA,oD;AACA,+D;AACA,+D;AACA,gC;AACA,gD;AACA,E;;AAEA,6E;AACA,qB;AACA,wC;AACA,+D;AACA,mB;AACA,8C;AACA,0B;AACA,oE;AACA,E;;AAEA,sE;AACA,0C;AACA,+D;AACA,c;AACA,gB;;AAEA,0B;AACA,gC;AACA,uD;AACA,4C;AACA,O;AACA,yC;AACA,iD;AACA,2D;AACA,6D;AACA,O;AACA,G;;AAEA,kB;AACA,gB;;AAEA,yB;AACA,kE;AACA,M;AACA,qE;AACA,G;;AAEA,G;AACA,yB;AACA,G;;AAEA,oE;AACA,E;AACA,0D;AACA,iE;AACA,iE;AACA,mE;AACA,2E;AACA,uB;AACA,mE;AACA,gC;AACA,E;AACA,0D;AACA,sC;AACA,mC;;AAEA,6D;AACA,oB;AACA,8E;AACA,uB;AACA,gC;AACA,oB;AACA,sE;;AAEA,0D;AACA,oB;AACA,uD;;AAEA,yD;AACA,wE;AACA,wE;AACA,qE;AACA,4E;AACA,6E;AACA,sE;AACA,4D;AACA,8B;AACA,sD;AACA,oE;AACA,U;AACA,4C;AACA,G;;AAEA,4C;;AAEA,a;AACA,oD;;AAEA,6E;AACA,yE;AACA,6D;AACA,mE;AACA,0B;AACA,sB;AACA,8C;AACA,8D;AACA,O;;AAEA,6E;AACA,2B;AACA,oD;AACA,Y;AACA,wB;AACA,sB;AACA,M;AACA,U;AACA,6E;AACA,qB;AACA,0B;AACA,6C;AACA,Y;AACA,wB;AACA,mD;AACA,M;AACA,G;AACA,E;;;AAGA,G;AACA,mB;AACA,G;;AAEA,mD;AACA,iC;AACA,oB;AACA,6B;AACA,yB;AACA,sD;AACA,U;AACA,gB;AACA,G;AACA,oD;;AAEA,iE;AACA,wD;AACA,qE;AACA,iE;AACA,kE;AACA,yB;AACA,kD;AACA,qC;AACA,E;;AAEA,6D;AACA,gE;AACA,8C;AACA,E;AACA,6B;AACA,8E;AACA,qF;AACA,gD;AACA,4C;AACA,0D;AACA,0C;AACA,sD;AACA,E;;AAEA,0B;AACA,+D;AACA,0B;AACA,8B;AACA,2D;AACA,4C;AACA,qD;AACA,0B;AACA,U;AACA,M;;AAEA,6C;AACA,wB;AACA,iC;AACA,6B;AACA,qE;AACA,c;AACA,oB;AACA,O;AACA,wD;;AAEA,gF;AACA,8E;AACA,6E;AACA,+E;AACA,gE;AACA,6C;AACA,mB;AACA,sB;AACA,6C;AACA,U;AACA,sB;;AAEA,+B;AACA,iB;AACA,iE;AACA,wD;AACA,K;AACA,C;;AAEA,oE;AACA,gE;AACA,4B;AACA,0D;AACA,6E;AACA,2E;;AAEA,oE;AACA,wD;AACA,gB;AACA,+C;AACA,6D;AACA,0E;AACA,yE;AACA,wB;AACA,2E;AACA,wE;AACA,0B;AACA,wB;AACA,2E;AACA,qD;AACA,K;;AAEA,8B;AACA,4D;AACA,gF;AACA,wF;;AAEA,2D;AACA,4D;;AAEA,wD;AACA,G;AACA,G;;;AAGA,G;AACA,sC;AACA,G;;AAEA,oB;AACA,oE;AACA,kB;AACA,qD;AACA,iC;AACA,4B;AACA,mB;;AAEA,iE;AACA,sE;AACA,0B;AACA,uD;AACA,mB;;AAEA,gB;AACA,I;AACA,wC;AACA,G;;AAEA,4B;AACA,8D;AACA,oE;AACA,oE;AACA,kD;AACA,8D;AACA,kD;AACA,6E;AACA,gB;AACA,oE;AACA,yC;AACA,4B;AACA,6E;;AAEA,G;AACA,qC;AACA,G;;AAEA,2D;AACA,uB;AACA,iC;AACA,e;AACA,qD;AACA,gD;AACA,Q;AACA,iB;AACA,qD;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,4B;AACA,6E;AACA,2E;AACA,gF;AACA,gF;AACA,0E;AACA,Y;AACA,iC;AACA,mD;AACA,M;AACA,4C;AACA,K;AACA,iC;AACA,0E;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;ACx0CA,oD;;AAEA,mB;;AAEA,gD;AACA,yD;AACA,E;;AAEA,8C;AACA,uD;AACA,E;;AAEA,gD;AACA,yD;AACA,E","sourcesContent":["Accounts = {};\r\n\r\n// Currently this is read directly by packages like accounts-password\r\n// and accounts-ui-unstyled.\r\nAccounts._options = {};\r\n\r\n// how long (in days) until a login token expires\r\nvar DEFAULT_LOGIN_EXPIRATION_DAYS = 90;\r\n// Clients don't try to auto-login with a token that is going to expire within\r\n// .1 * DEFAULT_LOGIN_EXPIRATION_DAYS, capped at MIN_TOKEN_LIFETIME_CAP_SECS.\r\n// Tries to avoid abrupt disconnects from expiring tokens.\r\nvar MIN_TOKEN_LIFETIME_CAP_SECS = 3600; // one hour\r\n// how often (in milliseconds) we check for expired tokens\r\nEXPIRE_TOKENS_INTERVAL_MS = 600 * 1000; // 10 minutes\r\n// how long we wait before logging out clients when Meteor.logoutOtherClients is\r\n// called\r\nCONNECTION_CLOSE_DELAY_MS = 10 * 1000;\r\n\r\n// Set up config for the accounts system. Call this on both the client\r\n// and the server.\r\n//\r\n// XXX we should add some enforcement that this is called on both the\r\n// client and the server. Otherwise, a user can\r\n// 'forbidClientAccountCreation' only on the client and while it looks\r\n// like their app is secure, the server will still accept createUser\r\n// calls. https://github.com/meteor/meteor/issues/828\r\n//\r\n// @param options {Object} an object with fields:\r\n// - sendVerificationEmail {Boolean}\r\n//     Send email address verification emails to new users created from\r\n//     client signups.\r\n// - forbidClientAccountCreation {Boolean}\r\n//     Do not allow clients to create accounts directly.\r\n// - restrictCreationByEmailDomain {Function or String}\r\n//     Require created users to have an email matching the function or\r\n//     having the string as domain.\r\n// - loginExpirationInDays {Number}\r\n//     Number of days since login until a user is logged out (login token\r\n//     expires).\r\n//\r\nAccounts.config = function(options) {\r\n  // We don't want users to accidentally only call Accounts.config on the\r\n  // client, where some of the options will have partial effects (eg removing\r\n  // the \"create account\" button from accounts-ui if forbidClientAccountCreation\r\n  // is set, or redirecting Google login to a specific-domain page) without\r\n  // having their full effects.\r\n  if (Meteor.isServer) {\r\n    __meteor_runtime_config__.accountsConfigCalled = true;\r\n  } else if (!__meteor_runtime_config__.accountsConfigCalled) {\r\n    // XXX would be nice to \"crash\" the client and replace the UI with an error\r\n    // message, but there's no trivial way to do this.\r\n    Meteor._debug(\"Accounts.config was called on the client but not on the \" +\r\n                  \"server; some configuration options may not take effect.\");\r\n  }\r\n\r\n  // We need to validate the oauthSecretKey option at the time\r\n  // Accounts.config is called. We also deliberately don't store the\r\n  // oauthSecretKey in Accounts._options.\r\n  if (_.has(options, \"oauthSecretKey\")) {\r\n    if (Meteor.isClient)\r\n      throw new Error(\"The oauthSecretKey option may only be specified on the server\");\r\n    if (! Package[\"oauth-encryption\"])\r\n      throw new Error(\"The oauth-encryption package must be loaded to set oauthSecretKey\");\r\n    Package[\"oauth-encryption\"].OAuthEncryption.loadKey(options.oauthSecretKey);\r\n    options = _.omit(options, \"oauthSecretKey\");\r\n  }\r\n\r\n  // validate option keys\r\n  var VALID_KEYS = [\"sendVerificationEmail\", \"forbidClientAccountCreation\",\r\n                    \"restrictCreationByEmailDomain\", \"loginExpirationInDays\"];\r\n  _.each(_.keys(options), function (key) {\r\n    if (!_.contains(VALID_KEYS, key)) {\r\n      throw new Error(\"Accounts.config: Invalid key: \" + key);\r\n    }\r\n  });\r\n\r\n  // set values in Accounts._options\r\n  _.each(VALID_KEYS, function (key) {\r\n    if (key in options) {\r\n      if (key in Accounts._options) {\r\n        throw new Error(\"Can't set `\" + key + \"` more than once\");\r\n      } else {\r\n        Accounts._options[key] = options[key];\r\n      }\r\n    }\r\n  });\r\n\r\n  // If the user set loginExpirationInDays to null, then we need to clear the\r\n  // timer that periodically expires tokens.\r\n  if (Meteor.isServer)\r\n    maybeStopExpireTokensInterval();\r\n};\r\n\r\nif (Meteor.isClient) {\r\n  // The connection used by the Accounts system. This is the connection\r\n  // that will get logged in by Meteor.login(), and this is the\r\n  // connection whose login state will be reflected by Meteor.userId().\r\n  //\r\n  // It would be much preferable for this to be in accounts_client.js,\r\n  // but it has to be here because it's needed to create the\r\n  // Meteor.users collection.\r\n  Accounts.connection = Meteor.connection;\r\n\r\n  if (typeof __meteor_runtime_config__ !== \"undefined\" &&\r\n      __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL) {\r\n    // Temporary, internal hook to allow the server to point the client\r\n    // to a different authentication server. This is for a very\r\n    // particular use case that comes up when implementing a oauth\r\n    // server. Unsupported and may go away at any point in time.\r\n    //\r\n    // We will eventually provide a general way to use account-base\r\n    // against any DDP connection, not just one special one.\r\n    Accounts.connection = DDP.connect(\r\n      __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL)\r\n  }\r\n}\r\n\r\n// Users table. Don't use the normal autopublish, since we want to hide\r\n// some fields. Code to autopublish this is in accounts_server.js.\r\n// XXX Allow users to configure this collection name.\r\n//\r\nMeteor.users = new Meteor.Collection(\"users\", {\r\n  _preventAutopublish: true,\r\n  connection: Meteor.isClient ? Accounts.connection : Meteor.connection\r\n});\r\n// There is an allow call in accounts_server that restricts this\r\n// collection.\r\n\r\n// loginServiceConfiguration and ConfigError are maintained for backwards compatibility\r\nMeteor.startup(function () {\r\n  var ServiceConfiguration =\r\n    Package['service-configuration'].ServiceConfiguration;\r\n  Accounts.loginServiceConfiguration = ServiceConfiguration.configurations;\r\n  Accounts.ConfigError = ServiceConfiguration.ConfigError;\r\n});\r\n\r\n// Thrown when the user cancels the login process (eg, closes an oauth\r\n// popup, declines retina scan, etc)\r\nAccounts.LoginCancelledError = function(description) {\r\n  this.message = description;\r\n};\r\n\r\n// This is used to transmit specific subclass errors over the wire. We should\r\n// come up with a more generic way to do this (eg, with some sort of symbolic\r\n// error code rather than a number).\r\nAccounts.LoginCancelledError.numericError = 0x8acdc2f;\r\nAccounts.LoginCancelledError.prototype = new Error();\r\nAccounts.LoginCancelledError.prototype.name = 'Accounts.LoginCancelledError';\r\n\r\ngetTokenLifetimeMs = function () {\r\n  return (Accounts._options.loginExpirationInDays ||\r\n          DEFAULT_LOGIN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\r\n};\r\n\r\nAccounts._tokenExpiration = function (when) {\r\n  // We pass when through the Date constructor for backwards compatibility;\r\n  // `when` used to be a number.\r\n  return new Date((new Date(when)).getTime() + getTokenLifetimeMs());\r\n};\r\n\r\nAccounts._tokenExpiresSoon = function (when) {\r\n  var minLifetimeMs = .1 * getTokenLifetimeMs();\r\n  var minLifetimeCapMs = MIN_TOKEN_LIFETIME_CAP_SECS * 1000;\r\n  if (minLifetimeMs > minLifetimeCapMs)\r\n    minLifetimeMs = minLifetimeCapMs;\r\n  return new Date() > (new Date(when) - minLifetimeMs);\r\n};\r\n","var crypto = Npm.require('crypto');\r\n\r\n///\r\n/// CURRENT USER\r\n///\r\n\r\nMeteor.userId = function () {\r\n  // This function only works if called inside a method. In theory, it\r\n  // could also be called from publish statements, since they also\r\n  // have a userId associated with them. However, given that publish\r\n  // functions aren't reactive, using any of the infomation from\r\n  // Meteor.user() in a publish function will always use the value\r\n  // from when the function first runs. This is likely not what the\r\n  // user expects. The way to make this work in a publish is to do\r\n  // Meteor.find(this.userId()).observe and recompute when the user\r\n  // record changes.\r\n  var currentInvocation = DDP._CurrentInvocation.get();\r\n  if (!currentInvocation)\r\n    throw new Error(\"Meteor.userId can only be invoked in method calls. Use this.userId in publish functions.\");\r\n  return currentInvocation.userId;\r\n};\r\n\r\nMeteor.user = function () {\r\n  var userId = Meteor.userId();\r\n  if (!userId)\r\n    return null;\r\n  return Meteor.users.findOne(userId);\r\n};\r\n\r\n\r\n///\r\n/// LOGIN HOOKS\r\n///\r\n\r\n// Exceptions inside the hook callback are passed up to us.\r\nvar validateLoginHook = new Hook();\r\n\r\n// Callback exceptions are printed with Meteor._debug and ignored.\r\nvar onLoginHook = new Hook({\r\n  debugPrintExceptions: \"onLogin callback\"\r\n});\r\nvar onLoginFailureHook = new Hook({\r\n  debugPrintExceptions: \"onLoginFailure callback\"\r\n});\r\n\r\nAccounts.validateLoginAttempt = function (func) {\r\n  return validateLoginHook.register(func);\r\n};\r\n\r\nAccounts.onLogin = function (func) {\r\n  return onLoginHook.register(func);\r\n};\r\n\r\nAccounts.onLoginFailure = function (func) {\r\n  return onLoginFailureHook.register(func);\r\n};\r\n\r\n\r\n// Give each login hook callback a fresh cloned copy of the attempt\r\n// object, but don't clone the connection.\r\n//\r\nvar cloneAttemptWithConnection = function (connection, attempt) {\r\n  var clonedAttempt = EJSON.clone(attempt);\r\n  clonedAttempt.connection = connection;\r\n  return clonedAttempt;\r\n};\r\n\r\nvar validateLogin = function (connection, attempt) {\r\n  validateLoginHook.each(function (callback) {\r\n    var ret;\r\n    try {\r\n      ret = callback(cloneAttemptWithConnection(connection, attempt));\r\n    }\r\n    catch (e) {\r\n      attempt.allowed = false;\r\n      // XXX this means the last thrown error overrides previous error\r\n      // messages. Maybe this is surprising to users and we should make\r\n      // overriding errors more explicit. (see\r\n      // https://github.com/meteor/meteor/issues/1960)\r\n      attempt.error = e;\r\n      return true;\r\n    }\r\n    if (! ret) {\r\n      attempt.allowed = false;\r\n      // don't override a specific error provided by a previous\r\n      // validator or the initial attempt (eg \"incorrect password\").\r\n      if (!attempt.error)\r\n        attempt.error = new Meteor.Error(403, \"Login forbidden\");\r\n    }\r\n    return true;\r\n  });\r\n};\r\n\r\n\r\nvar successfulLogin = function (connection, attempt) {\r\n  onLoginHook.each(function (callback) {\r\n    callback(cloneAttemptWithConnection(connection, attempt));\r\n    return true;\r\n  });\r\n};\r\n\r\nvar failedLogin = function (connection, attempt) {\r\n  onLoginFailureHook.each(function (callback) {\r\n    callback(cloneAttemptWithConnection(connection, attempt));\r\n    return true;\r\n  });\r\n};\r\n\r\n\r\n///\r\n/// LOGIN METHODS\r\n///\r\n\r\n// Login methods return to the client an object containing these\r\n// fields when the user was logged in successfully:\r\n//\r\n//   id: userId\r\n//   token: *\r\n//   tokenExpires: *\r\n//\r\n// tokenExpires is optional and intends to provide a hint to the\r\n// client as to when the token will expire. If not provided, the\r\n// client will call Accounts._tokenExpiration, passing it the date\r\n// that it received the token.\r\n//\r\n// The login method will throw an error back to the client if the user\r\n// failed to log in.\r\n//\r\n//\r\n// Login handlers and service specific login methods such as\r\n// `createUser` internally return a `result` object containing these\r\n// fields:\r\n//\r\n//   type:\r\n//     optional string; the service name, overrides the handler\r\n//     default if present.\r\n//\r\n//   error:\r\n//     exception; if the user is not allowed to login, the reason why.\r\n//\r\n//   userId:\r\n//     string; the user id of the user attempting to login (if\r\n//     known), required for an allowed login.\r\n//\r\n//   options:\r\n//     optional object merged into the result returned by the login\r\n//     method; used by HAMK from SRP.\r\n//\r\n//   stampedLoginToken:\r\n//     optional object with `token` and `when` indicating the login\r\n//     token is already present in the database, returned by the\r\n//     \"resume\" login handler.\r\n//\r\n// For convenience, login methods can also throw an exception, which\r\n// is converted into an {error} result.  However, if the id of the\r\n// user attempting the login is known, a {userId, error} result should\r\n// be returned instead since the user id is not captured when an\r\n// exception is thrown.\r\n//\r\n// This internal `result` object is automatically converted into the\r\n// public {id, token, tokenExpires} object returned to the client.\r\n\r\n\r\n// Try a login method, converting thrown exceptions into an {error}\r\n// result.  The `type` argument is a default, inserted into the result\r\n// object if not explicitly returned.\r\n//\r\nvar tryLoginMethod = function (type, fn) {\r\n  var result;\r\n  try {\r\n    result = fn();\r\n  }\r\n  catch (e) {\r\n    result = {error: e};\r\n  }\r\n\r\n  if (result && !result.type && type)\r\n    result.type = type;\r\n\r\n  return result;\r\n};\r\n\r\n\r\n// Log in a user on a connection.\r\n//\r\n// We use the method invocation to set the user id on the connection,\r\n// not the connection object directly. setUserId is tied to methods to\r\n// enforce clear ordering of method application (using wait methods on\r\n// the client, and a no setUserId after unblock restriction on the\r\n// server)\r\n//\r\n// The `stampedLoginToken` parameter is optional.  When present, it\r\n// indicates that the login token has already been inserted into the\r\n// database and doesn't need to be inserted again.  (It's used by the\r\n// \"resume\" login handler).\r\nvar loginUser = function (methodInvocation, userId, stampedLoginToken) {\r\n  if (! stampedLoginToken) {\r\n    stampedLoginToken = Accounts._generateStampedLoginToken();\r\n    Accounts._insertLoginToken(userId, stampedLoginToken);\r\n  }\r\n\r\n  // This order (and the avoidance of yields) is important to make\r\n  // sure that when publish functions are rerun, they see a\r\n  // consistent view of the world: the userId is set and matches\r\n  // the login token on the connection (not that there is\r\n  // currently a public API for reading the login token on a\r\n  // connection).\r\n  Meteor._noYieldsAllowed(function () {\r\n    Accounts._setLoginToken(\r\n      userId,\r\n      methodInvocation.connection,\r\n      Accounts._hashLoginToken(stampedLoginToken.token)\r\n    );\r\n  });\r\n\r\n  methodInvocation.setUserId(userId);\r\n\r\n  return {\r\n    id: userId,\r\n    token: stampedLoginToken.token,\r\n    tokenExpires: Accounts._tokenExpiration(stampedLoginToken.when)\r\n  };\r\n};\r\n\r\n\r\n// After a login method has completed, call the login hooks.  Note\r\n// that `attemptLogin` is called for *all* login attempts, even ones\r\n// which aren't successful (such as an invalid password, etc).\r\n//\r\n// If the login is allowed and isn't aborted by a validate login hook\r\n// callback, log in the user.\r\n//\r\nvar attemptLogin = function (methodInvocation, methodName, methodArgs, result) {\r\n  if (!result)\r\n    throw new Error(\"result is required\");\r\n\r\n  // XXX A programming error in a login handler can lead to this occuring, and\r\n  // then we don't call onLogin or onLoginFailure callbacks. Should\r\n  // tryLoginMethod catch this case and turn it into an error?\r\n  if (!result.userId && !result.error)\r\n    throw new Error(\"A login method must specify a userId or an error\");\r\n\r\n  var user;\r\n  if (result.userId)\r\n    user = Meteor.users.findOne(result.userId);\r\n\r\n  var attempt = {\r\n    type: result.type || \"unknown\",\r\n    allowed: !! (result.userId && !result.error),\r\n    methodName: methodName,\r\n    methodArguments: _.toArray(methodArgs)\r\n  };\r\n  if (result.error)\r\n    attempt.error = result.error;\r\n  if (user)\r\n    attempt.user = user;\r\n\r\n  // validateLogin may mutate `attempt` by adding an error and changing allowed\r\n  // to false, but that's the only change it can make (and the user's callbacks\r\n  // only get a clone of `attempt`).\r\n  validateLogin(methodInvocation.connection, attempt);\r\n\r\n  if (attempt.allowed) {\r\n    var ret = _.extend(\r\n      loginUser(methodInvocation, result.userId, result.stampedLoginToken),\r\n      result.options || {}\r\n    );\r\n    successfulLogin(methodInvocation.connection, attempt);\r\n    return ret;\r\n  }\r\n  else {\r\n    failedLogin(methodInvocation.connection, attempt);\r\n    throw attempt.error;\r\n  }\r\n};\r\n\r\n\r\n// All service specific login methods should go through this function.\r\n// Ensure that thrown exceptions are caught and that login hook\r\n// callbacks are still called.\r\n//\r\nAccounts._loginMethod = function (methodInvocation, methodName, methodArgs, type, fn) {\r\n  return attemptLogin(\r\n    methodInvocation,\r\n    methodName,\r\n    methodArgs,\r\n    tryLoginMethod(type, fn)\r\n  );\r\n};\r\n\r\n\r\n// Report a login attempt failed outside the context of a normal login\r\n// method. This is for use in the case where there is a multi-step login\r\n// procedure (eg SRP based password login). If a method early in the\r\n// chain fails, it should call this function to report a failure. There\r\n// is no corresponding method for a successful login; methods that can\r\n// succeed at logging a user in should always be actual login methods\r\n// (using either Accounts._loginMethod or Accounts.registerLoginHandler).\r\nAccounts._reportLoginFailure = function (methodInvocation, methodName, methodArgs, result) {\r\n  var attempt = {\r\n    type: result.type || \"unknown\",\r\n    allowed: false,\r\n    error: result.error,\r\n    methodName: methodName,\r\n    methodArguments: _.toArray(methodArgs)\r\n  };\r\n  if (result.userId)\r\n    attempt.user = Meteor.users.findOne(result.userId);\r\n\r\n  validateLogin(methodInvocation.connection, attempt);\r\n  failedLogin(methodInvocation.connection, attempt);\r\n  // validateLogin may mutate attempt to set a new error message. Return\r\n  // the modified version.\r\n  return attempt;\r\n};\r\n\r\n\r\n///\r\n/// LOGIN HANDLERS\r\n///\r\n\r\n// list of all registered handlers.\r\nvar loginHandlers = [];\r\n\r\n// The main entry point for auth packages to hook in to login.\r\n//\r\n// A login handler is a login method which can return `undefined` to\r\n// indicate that the login request is not handled by this handler.\r\n//\r\n// @param name {String} Optional.  The service name, used by default\r\n// if a specific service name isn't returned in the result.\r\n//\r\n// @param handler {Function} A function that receives an options object\r\n// (as passed as an argument to the `login` method) and returns one of:\r\n// - `undefined`, meaning don't handle;\r\n// - a login method result object\r\n\r\nAccounts.registerLoginHandler = function(name, handler) {\r\n  if (! handler) {\r\n    handler = name;\r\n    name = null;\r\n  }\r\n  loginHandlers.push({name: name, handler: handler});\r\n};\r\n\r\n\r\n// Checks a user's credentials against all the registered login\r\n// handlers, and returns a login token if the credentials are valid. It\r\n// is like the login method, except that it doesn't set the logged-in\r\n// user on the connection. Throws a Meteor.Error if logging in fails,\r\n// including the case where none of the login handlers handled the login\r\n// request. Otherwise, returns {id: userId, token: *, tokenExpires: *}.\r\n//\r\n// For example, if you want to login with a plaintext password, `options` could be\r\n//   { user: { username: <username> }, password: <password> }, or\r\n//   { user: { email: <email> }, password: <password> }.\r\n\r\n// Try all of the registered login handlers until one of them doesn't\r\n// return `undefined`, meaning it handled this call to `login`. Return\r\n// that return value.\r\nvar runLoginHandlers = function (methodInvocation, options) {\r\n  for (var i = 0; i < loginHandlers.length; ++i) {\r\n    var handler = loginHandlers[i];\r\n\r\n    var result = tryLoginMethod(\r\n      handler.name,\r\n      function () {\r\n        return handler.handler.call(methodInvocation, options);\r\n      }\r\n    );\r\n\r\n    if (result)\r\n      return result;\r\n    else if (result !== undefined)\r\n      throw new Meteor.Error(400, \"A login handler should return a result or undefined\");\r\n  }\r\n\r\n  return {\r\n    type: null,\r\n    error: new Meteor.Error(400, \"Unrecognized options for login request\")\r\n  };\r\n};\r\n\r\n// Deletes the given loginToken from the database.\r\n//\r\n// For new-style hashed token, this will cause all connections\r\n// associated with the token to be closed.\r\n//\r\n// Any connections associated with old-style unhashed tokens will be\r\n// in the process of becoming associated with hashed tokens and then\r\n// they'll get closed.\r\nAccounts.destroyToken = function (userId, loginToken) {\r\n  Meteor.users.update(userId, {\r\n    $pull: {\r\n      \"services.resume.loginTokens\": {\r\n        $or: [\r\n          { hashedToken: loginToken },\r\n          { token: loginToken }\r\n        ]\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n// Actual methods for login and logout. This is the entry point for\r\n// clients to actually log in.\r\nMeteor.methods({\r\n  // @returns {Object|null}\r\n  //   If successful, returns {token: reconnectToken, id: userId}\r\n  //   If unsuccessful (for example, if the user closed the oauth login popup),\r\n  //     throws an error describing the reason\r\n  login: function(options) {\r\n    var self = this;\r\n\r\n    // Login handlers should really also check whatever field they look at in\r\n    // options, but we don't enforce it.\r\n    check(options, Object);\r\n\r\n    var result = runLoginHandlers(self, options);\r\n\r\n    return attemptLogin(self, \"login\", arguments, result);\r\n  },\r\n\r\n  logout: function() {\r\n    var token = Accounts._getLoginToken(this.connection.id);\r\n    Accounts._setLoginToken(this.userId, this.connection, null);\r\n    if (token && this.userId)\r\n      Accounts.destroyToken(this.userId, token);\r\n    this.setUserId(null);\r\n  },\r\n\r\n  // Delete all the current user's tokens and close all open connections logged\r\n  // in as this user. Returns a fresh new login token that this client can\r\n  // use. Tests set Accounts._noConnectionCloseDelayForTest to delete tokens\r\n  // immediately instead of using a delay.\r\n  //\r\n  // XXX COMPAT WITH 0.7.2\r\n  // This single `logoutOtherClients` method has been replaced with two\r\n  // methods, one that you call to get a new token, and another that you\r\n  // call to remove all tokens except your own. The new design allows\r\n  // clients to know when other clients have actually been logged\r\n  // out. (The `logoutOtherClients` method guarantees the caller that\r\n  // the other clients will be logged out at some point, but makes no\r\n  // guarantees about when.) This method is left in for backwards\r\n  // compatibility, especially since application code might be calling\r\n  // this method directly.\r\n  //\r\n  // @returns {Object} Object with token and tokenExpires keys.\r\n  logoutOtherClients: function () {\r\n    var self = this;\r\n    var user = Meteor.users.findOne(self.userId, {\r\n      fields: {\r\n        \"services.resume.loginTokens\": true\r\n      }\r\n    });\r\n    if (user) {\r\n      // Save the current tokens in the database to be deleted in\r\n      // CONNECTION_CLOSE_DELAY_MS ms. This gives other connections in the\r\n      // caller's browser time to find the fresh token in localStorage. We save\r\n      // the tokens in the database in case we crash before actually deleting\r\n      // them.\r\n      var tokens = user.services.resume.loginTokens;\r\n      var newToken = Accounts._generateStampedLoginToken();\r\n      var userId = self.userId;\r\n      Meteor.users.update(userId, {\r\n        $set: {\r\n          \"services.resume.loginTokensToDelete\": tokens,\r\n          \"services.resume.haveLoginTokensToDelete\": true\r\n        },\r\n        $push: { \"services.resume.loginTokens\": Accounts._hashStampedToken(newToken) }\r\n      });\r\n      Meteor.setTimeout(function () {\r\n        // The observe on Meteor.users will take care of closing the connections\r\n        // associated with `tokens`.\r\n        deleteSavedTokens(userId, tokens);\r\n      }, Accounts._noConnectionCloseDelayForTest ? 0 :\r\n                        CONNECTION_CLOSE_DELAY_MS);\r\n      // We do not set the login token on this connection, but instead the\r\n      // observe closes the connection and the client will reconnect with the\r\n      // new token.\r\n      return {\r\n        token: newToken.token,\r\n        tokenExpires: Accounts._tokenExpiration(newToken.when)\r\n      };\r\n    } else {\r\n      throw new Meteor.Error(\"You are not logged in.\");\r\n    }\r\n  },\r\n\r\n  // Generates a new login token with the same expiration as the\r\n  // connection's current token and saves it to the database. Associates\r\n  // the connection with this new token and returns it. Throws an error\r\n  // if called on a connection that isn't logged in.\r\n  //\r\n  // @returns Object\r\n  //   If successful, returns { token: <new token>, id: <user id>,\r\n  //   tokenExpires: <expiration date> }.\r\n  getNewToken: function () {\r\n    var self = this;\r\n    var user = Meteor.users.findOne(self.userId, {\r\n      fields: { \"services.resume.loginTokens\": 1 }\r\n    });\r\n    if (! self.userId || ! user) {\r\n      throw new Meteor.Error(\"You are not logged in.\");\r\n    }\r\n    // Be careful not to generate a new token that has a later\r\n    // expiration than the curren token. Otherwise, a bad guy with a\r\n    // stolen token could use this method to stop his stolen token from\r\n    // ever expiring.\r\n    var currentHashedToken = Accounts._getLoginToken(self.connection.id);\r\n    var currentStampedToken = _.find(\r\n      user.services.resume.loginTokens,\r\n      function (stampedToken) {\r\n        return stampedToken.hashedToken === currentHashedToken;\r\n      }\r\n    );\r\n    if (! currentStampedToken) { // safety belt: this should never happen\r\n      throw new Meteor.Error(\"Invalid login token\");\r\n    }\r\n    var newStampedToken = Accounts._generateStampedLoginToken();\r\n    newStampedToken.when = currentStampedToken.when;\r\n    Accounts._insertLoginToken(self.userId, newStampedToken);\r\n    return loginUser(self, self.userId, newStampedToken);\r\n  },\r\n\r\n  // Removes all tokens except the token associated with the current\r\n  // connection. Throws an error if the connection is not logged\r\n  // in. Returns nothing on success.\r\n  removeOtherTokens: function () {\r\n    var self = this;\r\n    if (! self.userId) {\r\n      throw new Meteor.Error(\"You are not logged in.\");\r\n    }\r\n    var currentToken = Accounts._getLoginToken(self.connection.id);\r\n    Meteor.users.update(self.userId, {\r\n      $pull: {\r\n        \"services.resume.loginTokens\": { hashedToken: { $ne: currentToken } }\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n///\r\n/// ACCOUNT DATA\r\n///\r\n\r\n// connectionId -> {connection, loginToken, srpChallenge}\r\nvar accountData = {};\r\n\r\n// HACK: This is used by 'meteor-accounts' to get the loginToken for a\r\n// connection. Maybe there should be a public way to do that.\r\nAccounts._getAccountData = function (connectionId, field) {\r\n  var data = accountData[connectionId];\r\n  return data && data[field];\r\n};\r\n\r\nAccounts._setAccountData = function (connectionId, field, value) {\r\n  var data = accountData[connectionId];\r\n\r\n  // safety belt. shouldn't happen. accountData is set in onConnection,\r\n  // we don't have a connectionId until it is set.\r\n  if (!data)\r\n    return;\r\n\r\n  if (value === undefined)\r\n    delete data[field];\r\n  else\r\n    data[field] = value;\r\n};\r\n\r\nMeteor.server.onConnection(function (connection) {\r\n  accountData[connection.id] = {connection: connection};\r\n  connection.onClose(function () {\r\n    removeTokenFromConnection(connection.id);\r\n    delete accountData[connection.id];\r\n  });\r\n});\r\n\r\n\r\n///\r\n/// RECONNECT TOKENS\r\n///\r\n/// support reconnecting using a meteor login token\r\n\r\nAccounts._hashLoginToken = function (loginToken) {\r\n  var hash = crypto.createHash('sha256');\r\n  hash.update(loginToken);\r\n  return hash.digest('base64');\r\n};\r\n\r\n\r\n// {token, when} => {hashedToken, when}\r\nAccounts._hashStampedToken = function (stampedToken) {\r\n  return _.extend(\r\n    _.omit(stampedToken, 'token'),\r\n    {hashedToken: Accounts._hashLoginToken(stampedToken.token)}\r\n  );\r\n};\r\n\r\n\r\n// Using $addToSet avoids getting an index error if another client\r\n// logging in simultaneously has already inserted the new hashed\r\n// token.\r\nAccounts._insertHashedLoginToken = function (userId, hashedToken, query) {\r\n  query = query ? _.clone(query) : {};\r\n  query._id = userId;\r\n  Meteor.users.update(\r\n    query,\r\n    { $addToSet: {\r\n        \"services.resume.loginTokens\": hashedToken\r\n    } }\r\n  );\r\n};\r\n\r\n\r\n// Exported for tests.\r\nAccounts._insertLoginToken = function (userId, stampedToken, query) {\r\n  Accounts._insertHashedLoginToken(\r\n    userId,\r\n    Accounts._hashStampedToken(stampedToken),\r\n    query\r\n  );\r\n};\r\n\r\n\r\nAccounts._clearAllLoginTokens = function (userId) {\r\n  Meteor.users.update(\r\n    userId,\r\n    {$set: {'services.resume.loginTokens': []}}\r\n  );\r\n};\r\n\r\n// connection id -> observe handle for the login token that this\r\n// connection is currently associated with, or null. Null indicates that\r\n// we are in the process of setting up the observe.\r\nvar userObservesForConnections = {};\r\n\r\n// test hook\r\nAccounts._getUserObserve = function (connectionId) {\r\n  return userObservesForConnections[connectionId];\r\n};\r\n\r\n// Clean up this connection's association with the token: that is, stop\r\n// the observe that we started when we associated the connection with\r\n// this token.\r\nvar removeTokenFromConnection = function (connectionId) {\r\n  if (_.has(userObservesForConnections, connectionId)) {\r\n    var observe = userObservesForConnections[connectionId];\r\n    if (observe === null) {\r\n      // We're in the process of setting up an observe for this\r\n      // connection. We can't clean up that observe yet, but if we\r\n      // delete the null placeholder for this connection, then the\r\n      // observe will get cleaned up as soon as it has been set up.\r\n      delete userObservesForConnections[connectionId];\r\n    } else {\r\n      delete userObservesForConnections[connectionId];\r\n      observe.stop();\r\n    }\r\n  }\r\n};\r\n\r\nAccounts._getLoginToken = function (connectionId) {\r\n  return Accounts._getAccountData(connectionId, 'loginToken');\r\n};\r\n\r\n// newToken is a hashed token.\r\nAccounts._setLoginToken = function (userId, connection, newToken) {\r\n  removeTokenFromConnection(connection.id);\r\n  Accounts._setAccountData(connection.id, 'loginToken', newToken);\r\n\r\n  if (newToken) {\r\n    // Set up an observe for this token. If the token goes away, we need\r\n    // to close the connection.  We defer the observe because there's\r\n    // no need for it to be on the critical path for login; we just need\r\n    // to ensure that the connection will get closed at some point if\r\n    // the token gets deleted.\r\n    //\r\n    // Initially, we set the observe for this connection to null; this\r\n    // signifies to other code (which might run while we yield) that we\r\n    // are in the process of setting up an observe for this\r\n    // connection. Once the observe is ready to go, we replace null with\r\n    // the real observe handle (unless the placeholder has been deleted,\r\n    // signifying that the connection was closed already -- in this case\r\n    // we just clean up the observe that we started).\r\n    userObservesForConnections[connection.id] = null;\r\n    Meteor.defer(function () {\r\n      var foundMatchingUser;\r\n      // Because we upgrade unhashed login tokens to hashed tokens at\r\n      // login time, sessions will only be logged in with a hashed\r\n      // token. Thus we only need to observe hashed tokens here.\r\n      var observe = Meteor.users.find({\r\n        _id: userId,\r\n        'services.resume.loginTokens.hashedToken': newToken\r\n      }, { fields: { _id: 1 } }).observeChanges({\r\n        added: function () {\r\n          foundMatchingUser = true;\r\n        },\r\n        removed: function () {\r\n          connection.close();\r\n          // The onClose callback for the connection takes care of\r\n          // cleaning up the observe handle and any other state we have\r\n          // lying around.\r\n        }\r\n      });\r\n\r\n      // If the user ran another login or logout command we were waiting for\r\n      // the defer or added to fire, then we let the later one win (start an\r\n      // observe, etc) and just stop our observe now.\r\n      //\r\n      // Similarly, if the connection was already closed, then the onClose\r\n      // callback would have called removeTokenFromConnection and there won't be\r\n      // an entry in userObservesForConnections. We can stop the observe.\r\n      if (Accounts._getAccountData(connection.id, 'loginToken') !== newToken ||\r\n          !_.has(userObservesForConnections, connection.id)) {\r\n        observe.stop();\r\n        return;\r\n      }\r\n\r\n      if (userObservesForConnections[connection.id] !== null) {\r\n        throw new Error(\"Non-null user observe for connection \" +\r\n                        connection.id + \" while observe was being set up?\");\r\n      }\r\n\r\n      userObservesForConnections[connection.id] = observe;\r\n\r\n      if (! foundMatchingUser) {\r\n        // We've set up an observe on the user associated with `newToken`,\r\n        // so if the new token is removed from the database, we'll close\r\n        // the connection. But the token might have already been deleted\r\n        // before we set up the observe, which wouldn't have closed the\r\n        // connection because the observe wasn't running yet.\r\n        connection.close();\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\n// Login handler for resume tokens.\r\nAccounts.registerLoginHandler(\"resume\", function(options) {\r\n  if (!options.resume)\r\n    return undefined;\r\n\r\n  check(options.resume, String);\r\n\r\n  var hashedToken = Accounts._hashLoginToken(options.resume);\r\n\r\n  // First look for just the new-style hashed login token, to avoid\r\n  // sending the unhashed token to the database in a query if we don't\r\n  // need to.\r\n  var user = Meteor.users.findOne(\r\n    {\"services.resume.loginTokens.hashedToken\": hashedToken});\r\n\r\n  if (! user) {\r\n    // If we didn't find the hashed login token, try also looking for\r\n    // the old-style unhashed token.  But we need to look for either\r\n    // the old-style token OR the new-style token, because another\r\n    // client connection logging in simultaneously might have already\r\n    // converted the token.\r\n    user = Meteor.users.findOne({\r\n      $or: [\r\n        {\"services.resume.loginTokens.hashedToken\": hashedToken},\r\n        {\"services.resume.loginTokens.token\": options.resume}\r\n      ]\r\n    });\r\n  }\r\n\r\n  if (! user)\r\n    return {\r\n      error: new Meteor.Error(403, \"You've been logged out by the server. Please log in again.\")\r\n    };\r\n\r\n  // Find the token, which will either be an object with fields\r\n  // {hashedToken, when} for a hashed token or {token, when} for an\r\n  // unhashed token.\r\n  var oldUnhashedStyleToken;\r\n  var token = _.find(user.services.resume.loginTokens, function (token) {\r\n    return token.hashedToken === hashedToken;\r\n  });\r\n  if (token) {\r\n    oldUnhashedStyleToken = false;\r\n  } else {\r\n    token = _.find(user.services.resume.loginTokens, function (token) {\r\n      return token.token === options.resume;\r\n    });\r\n    oldUnhashedStyleToken = true;\r\n  }\r\n\r\n  var tokenExpires = Accounts._tokenExpiration(token.when);\r\n  if (new Date() >= tokenExpires)\r\n    return {\r\n      userId: user._id,\r\n      error: new Meteor.Error(403, \"Your session has expired. Please log in again.\")\r\n    };\r\n\r\n  // Update to a hashed token when an unhashed token is encountered.\r\n  if (oldUnhashedStyleToken) {\r\n    // Only add the new hashed token if the old unhashed token still\r\n    // exists (this avoids resurrecting the token if it was deleted\r\n    // after we read it).  Using $addToSet avoids getting an index\r\n    // error if another client logging in simultaneously has already\r\n    // inserted the new hashed token.\r\n    Meteor.users.update(\r\n      {\r\n        _id: user._id,\r\n        \"services.resume.loginTokens.token\": options.resume\r\n      },\r\n      {$addToSet: {\r\n        \"services.resume.loginTokens\": {\r\n          \"hashedToken\": hashedToken,\r\n          \"when\": token.when\r\n        }\r\n      }}\r\n    );\r\n\r\n    // Remove the old token *after* adding the new, since otherwise\r\n    // another client trying to login between our removing the old and\r\n    // adding the new wouldn't find a token to login with.\r\n    Meteor.users.update(user._id, {\r\n      $pull: {\r\n        \"services.resume.loginTokens\": { \"token\": options.resume }\r\n      }\r\n    });\r\n  }\r\n\r\n  return {\r\n    userId: user._id,\r\n    stampedLoginToken: {\r\n      token: options.resume,\r\n      when: token.when\r\n    }\r\n  };\r\n});\r\n\r\n// (Also used by Meteor Accounts server and tests).\r\n//\r\nAccounts._generateStampedLoginToken = function () {\r\n  return {token: Random.secret(), when: (new Date)};\r\n};\r\n\r\n///\r\n/// TOKEN EXPIRATION\r\n///\r\n\r\nvar expireTokenInterval;\r\n\r\n// Deletes expired tokens from the database and closes all open connections\r\n// associated with these tokens.\r\n//\r\n// Exported for tests. Also, the arguments are only used by\r\n// tests. oldestValidDate is simulate expiring tokens without waiting\r\n// for them to actually expire. userId is used by tests to only expire\r\n// tokens for the test user.\r\nvar expireTokens = Accounts._expireTokens = function (oldestValidDate, userId) {\r\n  var tokenLifetimeMs = getTokenLifetimeMs();\r\n\r\n  // when calling from a test with extra arguments, you must specify both!\r\n  if ((oldestValidDate && !userId) || (!oldestValidDate && userId)) {\r\n    throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\r\n  }\r\n\r\n  oldestValidDate = oldestValidDate ||\r\n    (new Date(new Date() - tokenLifetimeMs));\r\n  var userFilter = userId ? {_id: userId} : {};\r\n\r\n\r\n  // Backwards compatible with older versions of meteor that stored login token\r\n  // timestamps as numbers.\r\n  Meteor.users.update(_.extend(userFilter, {\r\n    $or: [\r\n      { \"services.resume.loginTokens.when\": { $lt: oldestValidDate } },\r\n      { \"services.resume.loginTokens.when\": { $lt: +oldestValidDate } }\r\n    ]\r\n  }), {\r\n    $pull: {\r\n      \"services.resume.loginTokens\": {\r\n        $or: [\r\n          { when: { $lt: oldestValidDate } },\r\n          { when: { $lt: +oldestValidDate } }\r\n        ]\r\n      }\r\n    }\r\n  }, { multi: true });\r\n  // The observe on Meteor.users will take care of closing connections for\r\n  // expired tokens.\r\n};\r\n\r\nmaybeStopExpireTokensInterval = function () {\r\n  if (_.has(Accounts._options, \"loginExpirationInDays\") &&\r\n      Accounts._options.loginExpirationInDays === null &&\r\n      expireTokenInterval) {\r\n    Meteor.clearInterval(expireTokenInterval);\r\n    expireTokenInterval = null;\r\n  }\r\n};\r\n\r\nexpireTokenInterval = Meteor.setInterval(expireTokens,\r\n                                         EXPIRE_TOKENS_INTERVAL_MS);\r\n\r\n\r\n///\r\n/// OAuth Encryption Support\r\n///\r\n\r\nvar OAuthEncryption = Package[\"oauth-encryption\"] && Package[\"oauth-encryption\"].OAuthEncryption;\r\n\r\n\r\nvar usingOAuthEncryption = function () {\r\n  return OAuthEncryption && OAuthEncryption.keyIsLoaded();\r\n};\r\n\r\n\r\n// OAuth service data is temporarily stored in the pending credentials\r\n// collection during the oauth authentication process.  Sensitive data\r\n// such as access tokens are encrypted without the user id because\r\n// we don't know the user id yet.  We re-encrypt these fields with the\r\n// user id included when storing the service data permanently in\r\n// the users collection.\r\n//\r\nvar pinEncryptedFieldsToUser = function (serviceData, userId) {\r\n  _.each(_.keys(serviceData), function (key) {\r\n    var value = serviceData[key];\r\n    if (OAuthEncryption && OAuthEncryption.isSealed(value))\r\n      value = OAuthEncryption.seal(OAuthEncryption.open(value), userId);\r\n    serviceData[key] = value;\r\n  });\r\n};\r\n\r\n\r\n// Encrypt unencrypted login service secrets when oauth-encryption is\r\n// added.\r\n//\r\n// XXX For the oauthSecretKey to be available here at startup, the\r\n// developer must call Accounts.config({oauthSecretKey: ...}) at load\r\n// time, instead of in a Meteor.startup block, because the startup\r\n// block in the app code will run after this accounts-base startup\r\n// block.  Perhaps we need a post-startup callback?\r\n\r\nMeteor.startup(function () {\r\n  if (!usingOAuthEncryption())\r\n    return;\r\n\r\n  var ServiceConfiguration =\r\n    Package['service-configuration'].ServiceConfiguration;\r\n\r\n  ServiceConfiguration.configurations.find( {$and: [\r\n      { secret: {$exists: true} },\r\n      { \"secret.algorithm\": {$exists: false} }\r\n    ] } ).\r\n    forEach(function (config) {\r\n      ServiceConfiguration.configurations.update(\r\n        config._id,\r\n        { $set: {\r\n          secret: OAuthEncryption.seal(config.secret)\r\n        } }\r\n      );\r\n    });\r\n});\r\n\r\n\r\n///\r\n/// CREATE USER HOOKS\r\n///\r\n\r\nvar onCreateUserHook = null;\r\nAccounts.onCreateUser = function (func) {\r\n  if (onCreateUserHook)\r\n    throw new Error(\"Can only call onCreateUser once\");\r\n  else\r\n    onCreateUserHook = func;\r\n};\r\n\r\n// XXX see comment on Accounts.createUser in passwords_server about adding a\r\n// second \"server options\" argument.\r\nvar defaultCreateUserHook = function (options, user) {\r\n  if (options.profile)\r\n    user.profile = options.profile;\r\n  return user;\r\n};\r\n\r\n// Called by accounts-password\r\nAccounts.insertUserDoc = function (options, user) {\r\n  // - clone user document, to protect from modification\r\n  // - add createdAt timestamp\r\n  // - prepare an _id, so that you can modify other collections (eg\r\n  // create a first task for every new user)\r\n  //\r\n  // XXX If the onCreateUser or validateNewUser hooks fail, we might\r\n  // end up having modified some other collection\r\n  // inappropriately. The solution is probably to have onCreateUser\r\n  // accept two callbacks - one that gets called before inserting\r\n  // the user document (in which you can modify its contents), and\r\n  // one that gets called after (in which you should change other\r\n  // collections)\r\n  user = _.extend({createdAt: new Date(), _id: Random.id()}, user);\r\n\r\n  if (user.services)\r\n    _.each(user.services, function (serviceData) {\r\n      pinEncryptedFieldsToUser(serviceData, user._id);\r\n    });\r\n\r\n  var fullUser;\r\n  if (onCreateUserHook) {\r\n    fullUser = onCreateUserHook(options, user);\r\n\r\n    // This is *not* part of the API. We need this because we can't isolate\r\n    // the global server environment between tests, meaning we can't test\r\n    // both having a create user hook set and not having one set.\r\n    if (fullUser === 'TEST DEFAULT HOOK')\r\n      fullUser = defaultCreateUserHook(options, user);\r\n  } else {\r\n    fullUser = defaultCreateUserHook(options, user);\r\n  }\r\n\r\n  _.each(validateNewUserHooks, function (hook) {\r\n    if (!hook(fullUser))\r\n      throw new Meteor.Error(403, \"User validation failed\");\r\n  });\r\n\r\n  var userId;\r\n  try {\r\n    userId = Meteor.users.insert(fullUser);\r\n  } catch (e) {\r\n    // XXX string parsing sucks, maybe\r\n    // https://jira.mongodb.org/browse/SERVER-3069 will get fixed one day\r\n    if (e.name !== 'MongoError') throw e;\r\n    var match = e.err.match(/^E11000 duplicate key error index: ([^ ]+)/);\r\n    if (!match) throw e;\r\n    if (match[1].indexOf('$emails.address') !== -1)\r\n      throw new Meteor.Error(403, \"Email already exists.\");\r\n    if (match[1].indexOf('username') !== -1)\r\n      throw new Meteor.Error(403, \"Username already exists.\");\r\n    // XXX better error reporting for services.facebook.id duplicate, etc\r\n    throw e;\r\n  }\r\n  return userId;\r\n};\r\n\r\nvar validateNewUserHooks = [];\r\nAccounts.validateNewUser = function (func) {\r\n  validateNewUserHooks.push(func);\r\n};\r\n\r\n// XXX Find a better place for this utility function\r\n// Like Perl's quotemeta: quotes all regexp metacharacters. See\r\n//   https://github.com/substack/quotemeta/blob/master/index.js\r\nvar quotemeta = function (str) {\r\n    return String(str).replace(/(\\W)/g, '\\\\$1');\r\n};\r\n\r\n// Helper function: returns false if email does not match company domain from\r\n// the configuration.\r\nvar testEmailDomain = function (email) {\r\n  var domain = Accounts._options.restrictCreationByEmailDomain;\r\n  return !domain ||\r\n    (_.isFunction(domain) && domain(email)) ||\r\n    (_.isString(domain) &&\r\n      (new RegExp('@' + quotemeta(domain) + '$', 'i')).test(email));\r\n};\r\n\r\n// Validate new user's email or Google/Facebook/GitHub account's email\r\nAccounts.validateNewUser(function (user) {\r\n  var domain = Accounts._options.restrictCreationByEmailDomain;\r\n  if (!domain)\r\n    return true;\r\n\r\n  var emailIsGood = false;\r\n  if (!_.isEmpty(user.emails)) {\r\n    emailIsGood = _.any(user.emails, function (email) {\r\n      return testEmailDomain(email.address);\r\n    });\r\n  } else if (!_.isEmpty(user.services)) {\r\n    // Find any email of any service and check it\r\n    emailIsGood = _.any(user.services, function (service) {\r\n      return service.email && testEmailDomain(service.email);\r\n    });\r\n  }\r\n\r\n  if (emailIsGood)\r\n    return true;\r\n\r\n  if (_.isString(domain))\r\n    throw new Meteor.Error(403, \"@\" + domain + \" email required\");\r\n  else\r\n    throw new Meteor.Error(403, \"Email doesn't match the criteria.\");\r\n});\r\n\r\n///\r\n/// MANAGING USER OBJECTS\r\n///\r\n\r\n// Updates or creates a user after we authenticate with a 3rd party.\r\n//\r\n// @param serviceName {String} Service name (eg, twitter).\r\n// @param serviceData {Object} Data to store in the user's record\r\n//        under services[serviceName]. Must include an \"id\" field\r\n//        which is a unique identifier for the user in the service.\r\n// @param options {Object, optional} Other options to pass to insertUserDoc\r\n//        (eg, profile)\r\n// @returns {Object} Object with token and id keys, like the result\r\n//        of the \"login\" method.\r\n//\r\nAccounts.updateOrCreateUserFromExternalService = function(\r\n  serviceName, serviceData, options) {\r\n  options = _.clone(options || {});\r\n\r\n  if (serviceName === \"password\" || serviceName === \"resume\")\r\n    throw new Error(\r\n      \"Can't use updateOrCreateUserFromExternalService with internal service \"\r\n        + serviceName);\r\n  if (!_.has(serviceData, 'id'))\r\n    throw new Error(\r\n      \"Service data for service \" + serviceName + \" must include id\");\r\n\r\n  // Look for a user with the appropriate service user id.\r\n  var selector = {};\r\n  var serviceIdKey = \"services.\" + serviceName + \".id\";\r\n\r\n  // XXX Temporary special case for Twitter. (Issue #629)\r\n  //   The serviceData.id will be a string representation of an integer.\r\n  //   We want it to match either a stored string or int representation.\r\n  //   This is to cater to earlier versions of Meteor storing twitter\r\n  //   user IDs in number form, and recent versions storing them as strings.\r\n  //   This can be removed once migration technology is in place, and twitter\r\n  //   users stored with integer IDs have been migrated to string IDs.\r\n  if (serviceName === \"twitter\" && !isNaN(serviceData.id)) {\r\n    selector[\"$or\"] = [{},{}];\r\n    selector[\"$or\"][0][serviceIdKey] = serviceData.id;\r\n    selector[\"$or\"][1][serviceIdKey] = parseInt(serviceData.id, 10);\r\n  } else {\r\n    selector[serviceIdKey] = serviceData.id;\r\n  }\r\n\r\n  var user = Meteor.users.findOne(selector);\r\n\r\n  if (user) {\r\n    pinEncryptedFieldsToUser(serviceData, user._id);\r\n\r\n    // We *don't* process options (eg, profile) for update, but we do replace\r\n    // the serviceData (eg, so that we keep an unexpired access token and\r\n    // don't cache old email addresses in serviceData.email).\r\n    // XXX provide an onUpdateUser hook which would let apps update\r\n    //     the profile too\r\n    var setAttrs = {};\r\n    _.each(serviceData, function(value, key) {\r\n      setAttrs[\"services.\" + serviceName + \".\" + key] = value;\r\n    });\r\n\r\n    // XXX Maybe we should re-use the selector above and notice if the update\r\n    //     touches nothing?\r\n    Meteor.users.update(user._id, {$set: setAttrs});\r\n    return {\r\n      type: serviceName,\r\n      userId: user._id\r\n    };\r\n  } else {\r\n    // Create a new user with the service data. Pass other options through to\r\n    // insertUserDoc.\r\n    user = {services: {}};\r\n    user.services[serviceName] = serviceData;\r\n    return {\r\n      type: serviceName,\r\n      userId: Accounts.insertUserDoc(options, user)\r\n    };\r\n  }\r\n};\r\n\r\n\r\n///\r\n/// PUBLISHING DATA\r\n///\r\n\r\n// Publish the current user's record to the client.\r\nMeteor.publish(null, function() {\r\n  if (this.userId) {\r\n    return Meteor.users.find(\r\n      {_id: this.userId},\r\n      {fields: {profile: 1, username: 1, emails: 1}});\r\n  } else {\r\n    return null;\r\n  }\r\n}, /*suppress autopublish warning*/{is_auto: true});\r\n\r\n// If autopublish is on, publish these user fields. Login service\r\n// packages (eg accounts-google) add to these by calling\r\n// Accounts.addAutopublishFields Notably, this isn't implemented with\r\n// multiple publishes since DDP only merges only across top-level\r\n// fields, not subfields (such as 'services.facebook.accessToken')\r\nvar autopublishFields = {\r\n  loggedInUser: ['profile', 'username', 'emails'],\r\n  otherUsers: ['profile', 'username']\r\n};\r\n\r\n// Add to the list of fields or subfields to be automatically\r\n// published if autopublish is on. Must be called from top-level\r\n// code (ie, before Meteor.startup hooks run).\r\n//\r\n// @param opts {Object} with:\r\n//   - forLoggedInUser {Array} Array of fields published to the logged-in user\r\n//   - forOtherUsers {Array} Array of fields published to users that aren't logged in\r\nAccounts.addAutopublishFields = function(opts) {\r\n  autopublishFields.loggedInUser.push.apply(\r\n    autopublishFields.loggedInUser, opts.forLoggedInUser);\r\n  autopublishFields.otherUsers.push.apply(\r\n    autopublishFields.otherUsers, opts.forOtherUsers);\r\n};\r\n\r\nif (Package.autopublish) {\r\n  // Use Meteor.startup to give other packages a chance to call\r\n  // addAutopublishFields.\r\n  Meteor.startup(function () {\r\n    // ['profile', 'username'] -> {profile: 1, username: 1}\r\n    var toFieldSelector = function(fields) {\r\n      return _.object(_.map(fields, function(field) {\r\n        return [field, 1];\r\n      }));\r\n    };\r\n\r\n    Meteor.server.publish(null, function () {\r\n      if (this.userId) {\r\n        return Meteor.users.find(\r\n          {_id: this.userId},\r\n          {fields: toFieldSelector(autopublishFields.loggedInUser)});\r\n      } else {\r\n        return null;\r\n      }\r\n    }, /*suppress autopublish warning*/{is_auto: true});\r\n\r\n    // XXX this publish is neither dedup-able nor is it optimized by our special\r\n    // treatment of queries on a specific _id. Therefore this will have O(n^2)\r\n    // run-time performance every time a user document is changed (eg someone\r\n    // logging in). If this is a problem, we can instead write a manual publish\r\n    // function which filters out fields based on 'this.userId'.\r\n    Meteor.server.publish(null, function () {\r\n      var selector;\r\n      if (this.userId)\r\n        selector = {_id: {$ne: this.userId}};\r\n      else\r\n        selector = {};\r\n\r\n      return Meteor.users.find(\r\n        selector,\r\n        {fields: toFieldSelector(autopublishFields.otherUsers)});\r\n    }, /*suppress autopublish warning*/{is_auto: true});\r\n  });\r\n}\r\n\r\n// Publish all login service configuration fields other than secret.\r\nMeteor.publish(\"meteor.loginServiceConfiguration\", function () {\r\n  var ServiceConfiguration =\r\n    Package['service-configuration'].ServiceConfiguration;\r\n  return ServiceConfiguration.configurations.find({}, {fields: {secret: 0}});\r\n}, {is_auto: true}); // not techincally autopublish, but stops the warning.\r\n\r\n// Allow a one-time configuration for a login service. Modifications\r\n// to this collection are also allowed in insecure mode.\r\nMeteor.methods({\r\n  \"configureLoginService\": function (options) {\r\n    check(options, Match.ObjectIncluding({service: String}));\r\n    // Don't let random users configure a service we haven't added yet (so\r\n    // that when we do later add it, it's set up with their configuration\r\n    // instead of ours).\r\n    // XXX if service configuration is oauth-specific then this code should\r\n    //     be in accounts-oauth; if it's not then the registry should be\r\n    //     in this package\r\n    if (!(Accounts.oauth\r\n          && _.contains(Accounts.oauth.serviceNames(), options.service))) {\r\n      throw new Meteor.Error(403, \"Service unknown\");\r\n    }\r\n\r\n    var ServiceConfiguration =\r\n      Package['service-configuration'].ServiceConfiguration;\r\n    if (ServiceConfiguration.configurations.findOne({service: options.service}))\r\n      throw new Meteor.Error(403, \"Service \" + options.service + \" already configured\");\r\n\r\n    if (_.has(options, \"secret\") && usingOAuthEncryption())\r\n      options.secret = OAuthEncryption.seal(options.secret);\r\n\r\n    ServiceConfiguration.configurations.insert(options);\r\n  }\r\n});\r\n\r\n\r\n///\r\n/// RESTRICTING WRITES TO USER OBJECTS\r\n///\r\n\r\nMeteor.users.allow({\r\n  // clients can modify the profile field of their own document, and\r\n  // nothing else.\r\n  update: function (userId, user, fields, modifier) {\r\n    // make sure it is our record\r\n    if (user._id !== userId)\r\n      return false;\r\n\r\n    // user can only modify the 'profile' field. sets to multiple\r\n    // sub-keys (eg profile.foo and profile.bar) are merged into entry\r\n    // in the fields list.\r\n    if (fields.length !== 1 || fields[0] !== 'profile')\r\n      return false;\r\n\r\n    return true;\r\n  },\r\n  fetch: ['_id'] // we only look at _id.\r\n});\r\n\r\n/// DEFAULT INDEXES ON USERS\r\nMeteor.users._ensureIndex('username', {unique: 1, sparse: 1});\r\nMeteor.users._ensureIndex('emails.address', {unique: 1, sparse: 1});\r\nMeteor.users._ensureIndex('services.resume.loginTokens.hashedToken',\r\n                          {unique: 1, sparse: 1});\r\nMeteor.users._ensureIndex('services.resume.loginTokens.token',\r\n                          {unique: 1, sparse: 1});\r\n// For taking care of logoutOtherClients calls that crashed before the tokens\r\n// were deleted.\r\nMeteor.users._ensureIndex('services.resume.haveLoginTokensToDelete',\r\n                          { sparse: 1 });\r\n// For expiring login tokens\r\nMeteor.users._ensureIndex(\"services.resume.loginTokens.when\", { sparse: 1 });\r\n\r\n///\r\n/// CLEAN UP FOR `logoutOtherClients`\r\n///\r\n\r\nvar deleteSavedTokens = function (userId, tokensToDelete) {\r\n  if (tokensToDelete) {\r\n    Meteor.users.update(userId, {\r\n      $unset: {\r\n        \"services.resume.haveLoginTokensToDelete\": 1,\r\n        \"services.resume.loginTokensToDelete\": 1\r\n      },\r\n      $pullAll: {\r\n        \"services.resume.loginTokens\": tokensToDelete\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\nMeteor.startup(function () {\r\n  // If we find users who have saved tokens to delete on startup, delete them\r\n  // now. It's possible that the server could have crashed and come back up\r\n  // before new tokens are found in localStorage, but this shouldn't happen very\r\n  // often. We shouldn't put a delay here because that would give a lot of power\r\n  // to an attacker with a stolen login token and the ability to crash the\r\n  // server.\r\n  var users = Meteor.users.find({\r\n    \"services.resume.haveLoginTokensToDelete\": true\r\n  }, {\r\n    \"services.resume.loginTokensToDelete\": 1\r\n  });\r\n  users.forEach(function (user) {\r\n    deleteSavedTokens(user._id, user.services.resume.loginTokensToDelete);\r\n  });\r\n});\r\n","// XXX These should probably not actually be public?\r\n\r\nAccounts.urls = {};\r\n\r\nAccounts.urls.resetPassword = function (token) {\r\n  return Meteor.absoluteUrl('#/reset-password/' + token);\r\n};\r\n\r\nAccounts.urls.verifyEmail = function (token) {\r\n  return Meteor.absoluteUrl('#/verify-email/' + token);\r\n};\r\n\r\nAccounts.urls.enrollAccount = function (token) {\r\n  return Meteor.absoluteUrl('#/enroll-account/' + token);\r\n};\r\n"]}