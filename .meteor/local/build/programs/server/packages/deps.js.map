{"version":3,"file":"\\packages\\deps.js","sources":["deps/deps.js","deps/deprecated.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,kD;AACA,kD;AACA,kD;;AAEA,U;;AAEA,sC;AACA,oB;;AAEA,kD;AACA,+B;;AAEA,0C;AACA,8B;AACA,qB;AACA,E;;AAEA,0D;AACA,4D;AACA,O;AACA,sD;AACA,mC;AACA,sB;AACA,qC;AACA,sB;AACA,G;AACA,a;AACA,E;;AAEA,8B;AACA,+D;AACA,yD;AACA,4D;AACA,mE;AACA,4B;AACA,E;;AAEA,sC;AACA,wB;AACA,Y;AACA,U;AACA,8D;AACA,uC;AACA,G;AACA,E;;AAEA,wE;AACA,mE;AACA,iE;AACA,wC;AACA,kD;AACA,2D;AACA,Y;AACA,U;AACA,yC;AACA,c;AACA,O;AACA,G;AACA,E;;AAEA,e;AACA,4D;AACA,6B;AACA,sE;AACA,sB;AACA,qC;AACA,oB;AACA,kE;AACA,+D;AACA,kE;AACA,iD;AACA,sB;AACA,oE;AACA,oE;AACA,qE;AACA,iE;AACA,U;AACA,4B;;AAEA,6B;;AAEA,gC;AACA,oB;AACA,8B;AACA,qB;AACA,G;AACA,E;;AAEA,sD;AACA,0C;AACA,oC;;AAEA,E;AACA,2C;AACA,E;AACA,yC;AACA,gC;AACA,oB;AACA,mE;AACA,kC;;AAEA,kB;;AAEA,gD;AACA,uB;;AAEA,oD;AACA,2B;;AAEA,iD;AACA,uB;;AAEA,sB;AACA,mC;AACA,yD;AACA,2D;AACA,wB;AACA,iB;AACA,4B;;AAEA,qB;AACA,O;AACA,oB;AACA,oB;AACA,a;AACA,0B;AACA,gB;AACA,kB;AACA,G;AACA,E;;AAEA,qC;;AAEA,qD;AACA,8B;AACA,oB;;AAEA,gC;AACA,0D;;AAEA,2B;AACA,oC;AACA,yC;AACA,S;AACA,Y;AACA,0C;AACA,K;AACA,I;;AAEA,mD;AACA,2B;AACA,oB;AACA,6B;AACA,0D;AACA,yD;AACA,kD;AACA,uB;AACA,uC;AACA,O;;AAEA,8B;;AAEA,+C;AACA,mC;AACA,kE;AACA,sC;AACA,2C;AACA,W;AACA,O;AACA,uC;AACA,K;AACA,I;;AAEA,6C;AACA,qB;AACA,yB;AACA,0B;AACA,wB;AACA,K;AACA,I;;AAEA,yB;AACA,oB;AACA,6B;;AAEA,2C;AACA,gC;AACA,sC;AACA,qB;AACA,S;AACA,gD;AACA,e;AACA,sC;AACA,wB;AACA,K;AACA,I;;AAEA,2B;AACA,oB;;AAEA,6B;AACA,S;AACA,kD;AACA,a;AACA,0B;AACA,qB;AACA,sC;AACA,S;AACA,kE;AACA,mE;AACA,oC;AACA,U;AACA,oE;AACA,iB;AACA,O;AACA,e;AACA,gC;AACA,K;AACA,G;AACA,G;;AAEA,E;AACA,0C;AACA,E;AACA,+B;AACA,4B;AACA,E;;AAEA,oC;AACA,8C;AACA,I;AACA,wD;AACA,wE;AACA,oE;AACA,uC;AACA,kC;AACA,wB;AACA,wB;AACA,qB;;AAEA,4C;AACA,K;AACA,oB;AACA,6B;AACA,yC;AACA,6C;AACA,4C;AACA,wC;AACA,S;AACA,kB;AACA,K;AACA,iB;AACA,I;;AAEA,+C;AACA,wB;AACA,oB;AACA,wC;AACA,4C;AACA,I;;AAEA,qD;AACA,8B;AACA,oB;AACA,uC;AACA,kB;AACA,iB;AACA,G;AACA,G;;AAEA,e;AACA,uC;AACA,2B;AACA,sE;AACA,kB;AACA,M;AACA,kE;AACA,+D;AACA,8D;AACA,8D;AACA,iE;AACA,2C;AACA,M;AACA,wD;AACA,gB;AACA,8D;;AAEA,kB;AACA,yD;;AAEA,mB;AACA,qB;AACA,2D;;AAEA,4B;AACA,S;AACA,0C;AACA,0C;;AAEA,6C;AACA,4C;AACA,iD;AACA,4B;AACA,S;;AAEA,yC;AACA,oD;AACA,yC;AACA,iD;AACA,e;AACA,mB;AACA,uB;AACA,kD;AACA,W;AACA,S;AACA,O;AACA,yB;AACA,e;AACA,0B;AACA,yB;AACA,sE;AACA,iE;AACA,O;AACA,wB;AACA,sB;AACA,K;AACA,I;;AAEA,yC;AACA,I;AACA,4D;AACA,yB;AACA,I;AACA,0D;AACA,I;AACA,qD;AACA,qE;AACA,yB;AACA,gC;AACA,mE;;AAEA,mC;AACA,6D;;AAEA,oB;AACA,qC;AACA,iB;AACA,S;;AAEA,a;AACA,I;;AAEA,6C;AACA,I;AACA,oE;AACA,kE;AACA,yE;AACA,oC;AACA,6B;AACA,2C;AACA,gC;AACA,S;AACA,iB;AACA,e;AACA,sC;AACA,K;AACA,I;;AAEA,8C;AACA,8B;AACA,sB;AACA,yE;;AAEA,4C;AACA,I;;AAEA,4C;AACA,4B;AACA,gC;AACA,mB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC7XA,wC;;AAEA,uE;AACA,gB;AACA,wB;AACA,0B;AACA,8B;;AAEA,+E;AACA,sC;AACA,wB;AACA,oC;;AAEA,mD;AACA,wB;AACA,4B;AACA,oB;AACA,E","sourcesContent":["//////////////////////////////////////////////////\r\n// Package docs at http://docs.meteor.com/#deps //\r\n//////////////////////////////////////////////////\r\n\r\nDeps = {};\r\n\r\n// http://docs.meteor.com/#deps_active\r\nDeps.active = false;\r\n\r\n// http://docs.meteor.com/#deps_currentcomputation\r\nDeps.currentComputation = null;\r\n\r\nvar setCurrentComputation = function (c) {\r\n  Deps.currentComputation = c;\r\n  Deps.active = !! c;\r\n};\r\n\r\n// _assign is like _.extend or the upcoming Object.assign.\r\n// Copy src's own, enumerable properties onto tgt and return\r\n// tgt.\r\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\r\nvar _assign = function (tgt, src) {\r\n  for (var k in src) {\r\n    if (_hasOwnProperty.call(src, k))\r\n      tgt[k] = src[k];\r\n  }\r\n  return tgt;\r\n};\r\n\r\nvar _debugFunc = function () {\r\n  // lazy evaluation because `Meteor` does not exist right away\r\n  return (typeof Meteor !== \"undefined\" ? Meteor._debug :\r\n          ((typeof console !== \"undefined\") && console.log ?\r\n           function () { console.log.apply(console, arguments); } :\r\n           function () {}));\r\n};\r\n\r\nvar _throwOrLog = function (from, e) {\r\n  if (throwFirstError) {\r\n    throw e;\r\n  } else {\r\n    _debugFunc()(\"Exception from Deps \" + from + \" function:\",\r\n                 e.stack || e.message);\r\n  }\r\n};\r\n\r\n// Like `Meteor._noYieldsAllowed(function () { f(comp); })` but shorter,\r\n// and doesn't clutter the stack with an extra frame on the client,\r\n// where `_noYieldsAllowed` is a no-op.  `f` may be a computation\r\n// function or an onInvalidate callback.\r\nvar callWithNoYieldsAllowed = function (f, comp) {\r\n  if ((typeof Meteor === 'undefined') || Meteor.isClient) {\r\n    f(comp);\r\n  } else {\r\n    Meteor._noYieldsAllowed(function () {\r\n      f(comp);\r\n    });\r\n  }\r\n};\r\n\r\nvar nextId = 1;\r\n// computations whose callbacks we should call at flush time\r\nvar pendingComputations = [];\r\n// `true` if a Deps.flush is scheduled, or if we are in Deps.flush now\r\nvar willFlush = false;\r\n// `true` if we are in Deps.flush now\r\nvar inFlush = false;\r\n// `true` if we are computing a computation now, either first time\r\n// or recompute.  This matches Deps.active unless we are inside\r\n// Deps.nonreactive, which nullfies currentComputation even though\r\n// an enclosing computation may still be running.\r\nvar inCompute = false;\r\n// `true` if the `_throwFirstError` option was passed in to the call\r\n// to Deps.flush that we are in. When set, throw rather than log the\r\n// first error encountered while flushing. Before throwing the error,\r\n// finish flushing (from a finally block), logging any subsequent\r\n// errors.\r\nvar throwFirstError = false;\r\n\r\nvar afterFlushCallbacks = [];\r\n\r\nvar requireFlush = function () {\r\n  if (! willFlush) {\r\n    setTimeout(Deps.flush, 0);\r\n    willFlush = true;\r\n  }\r\n};\r\n\r\n// Deps.Computation constructor is visible but private\r\n// (throws an error if you try to call it)\r\nvar constructingComputation = false;\r\n\r\n//\r\n// http://docs.meteor.com/#deps_computation\r\n//\r\nDeps.Computation = function (f, parent) {\r\n  if (! constructingComputation)\r\n    throw new Error(\r\n      \"Deps.Computation constructor is private; use Deps.autorun\");\r\n  constructingComputation = false;\r\n\r\n  var self = this;\r\n\r\n  // http://docs.meteor.com/#computation_stopped\r\n  self.stopped = false;\r\n\r\n  // http://docs.meteor.com/#computation_invalidated\r\n  self.invalidated = false;\r\n\r\n  // http://docs.meteor.com/#computation_firstrun\r\n  self.firstRun = true;\r\n\r\n  self._id = nextId++;\r\n  self._onInvalidateCallbacks = [];\r\n  // the plan is at some point to use the parent relation\r\n  // to constrain the order that computations are processed\r\n  self._parent = parent;\r\n  self._func = f;\r\n  self._recomputing = false;\r\n\r\n  var errored = true;\r\n  try {\r\n    self._compute();\r\n    errored = false;\r\n  } finally {\r\n    self.firstRun = false;\r\n    if (errored)\r\n      self.stop();\r\n  }\r\n};\r\n\r\n_assign(Deps.Computation.prototype, {\r\n\r\n  // http://docs.meteor.com/#computation_oninvalidate\r\n  onInvalidate: function (f) {\r\n    var self = this;\r\n\r\n    if (typeof f !== 'function')\r\n      throw new Error(\"onInvalidate requires a function\");\r\n\r\n    if (self.invalidated) {\r\n      Deps.nonreactive(function () {\r\n        callWithNoYieldsAllowed(f, self);\r\n      });\r\n    } else {\r\n      self._onInvalidateCallbacks.push(f);\r\n    }\r\n  },\r\n\r\n  // http://docs.meteor.com/#computation_invalidate\r\n  invalidate: function () {\r\n    var self = this;\r\n    if (! self.invalidated) {\r\n      // if we're currently in _recompute(), don't enqueue\r\n      // ourselves, since we'll rerun immediately anyway.\r\n      if (! self._recomputing && ! self.stopped) {\r\n        requireFlush();\r\n        pendingComputations.push(this);\r\n      }\r\n\r\n      self.invalidated = true;\r\n\r\n      // callbacks can't add callbacks, because\r\n      // self.invalidated === true.\r\n      for(var i = 0, f; f = self._onInvalidateCallbacks[i]; i++) {\r\n        Deps.nonreactive(function () {\r\n          callWithNoYieldsAllowed(f, self);\r\n        });\r\n      }\r\n      self._onInvalidateCallbacks = [];\r\n    }\r\n  },\r\n\r\n  // http://docs.meteor.com/#computation_stop\r\n  stop: function () {\r\n    if (! this.stopped) {\r\n      this.stopped = true;\r\n      this.invalidate();\r\n    }\r\n  },\r\n\r\n  _compute: function () {\r\n    var self = this;\r\n    self.invalidated = false;\r\n\r\n    var previous = Deps.currentComputation;\r\n    setCurrentComputation(self);\r\n    var previousInCompute = inCompute;\r\n    inCompute = true;\r\n    try {\r\n      callWithNoYieldsAllowed(self._func, self);\r\n    } finally {\r\n      setCurrentComputation(previous);\r\n      inCompute = false;\r\n    }\r\n  },\r\n\r\n  _recompute: function () {\r\n    var self = this;\r\n\r\n    self._recomputing = true;\r\n    try {\r\n      while (self.invalidated && ! self.stopped) {\r\n        try {\r\n          self._compute();\r\n        } catch (e) {\r\n          _throwOrLog(\"recompute\", e);\r\n        }\r\n        // If _compute() invalidated us, we run again immediately.\r\n        // A computation that invalidates itself indefinitely is an\r\n        // infinite loop, of course.\r\n        //\r\n        // We could put an iteration counter here and catch run-away\r\n        // loops.\r\n      }\r\n    } finally {\r\n      self._recomputing = false;\r\n    }\r\n  }\r\n});\r\n\r\n//\r\n// http://docs.meteor.com/#deps_dependency\r\n//\r\nDeps.Dependency = function () {\r\n  this._dependentsById = {};\r\n};\r\n\r\n_assign(Deps.Dependency.prototype, {\r\n  // http://docs.meteor.com/#dependency_depend\r\n  //\r\n  // Adds `computation` to this set if it is not already\r\n  // present.  Returns true if `computation` is a new member of the set.\r\n  // If no argument, defaults to currentComputation, or does nothing\r\n  // if there is no currentComputation.\r\n  depend: function (computation) {\r\n    if (! computation) {\r\n      if (! Deps.active)\r\n        return false;\r\n\r\n      computation = Deps.currentComputation;\r\n    }\r\n    var self = this;\r\n    var id = computation._id;\r\n    if (! (id in self._dependentsById)) {\r\n      self._dependentsById[id] = computation;\r\n      computation.onInvalidate(function () {\r\n        delete self._dependentsById[id];\r\n      });\r\n      return true;\r\n    }\r\n    return false;\r\n  },\r\n\r\n  // http://docs.meteor.com/#dependency_changed\r\n  changed: function () {\r\n    var self = this;\r\n    for (var id in self._dependentsById)\r\n      self._dependentsById[id].invalidate();\r\n  },\r\n\r\n  // http://docs.meteor.com/#dependency_hasdependents\r\n  hasDependents: function () {\r\n    var self = this;\r\n    for(var id in self._dependentsById)\r\n      return true;\r\n    return false;\r\n  }\r\n});\r\n\r\n_assign(Deps, {\r\n  // http://docs.meteor.com/#deps_flush\r\n  flush: function (_opts) {\r\n    // XXX What part of the comment below is still true? (We no longer\r\n    // have Spark)\r\n    //\r\n    // Nested flush could plausibly happen if, say, a flush causes\r\n    // DOM mutation, which causes a \"blur\" event, which runs an\r\n    // app event handler that calls Deps.flush.  At the moment\r\n    // Spark blocks event handlers during DOM mutation anyway,\r\n    // because the LiveRange tree isn't valid.  And we don't have\r\n    // any useful notion of a nested flush.\r\n    //\r\n    // https://app.asana.com/0/159908330244/385138233856\r\n    if (inFlush)\r\n      throw new Error(\"Can't call Deps.flush while flushing\");\r\n\r\n    if (inCompute)\r\n      throw new Error(\"Can't flush inside Deps.autorun\");\r\n\r\n    inFlush = true;\r\n    willFlush = true;\r\n    throwFirstError = !! (_opts && _opts._throwFirstError);\r\n\r\n    var finishedTry = false;\r\n    try {\r\n      while (pendingComputations.length ||\r\n             afterFlushCallbacks.length) {\r\n\r\n        // recompute all pending computations\r\n        while (pendingComputations.length) {\r\n          var comp = pendingComputations.shift();\r\n          comp._recompute();\r\n        }\r\n\r\n        if (afterFlushCallbacks.length) {\r\n          // call one afterFlush callback, which may\r\n          // invalidate more computations\r\n          var func = afterFlushCallbacks.shift();\r\n          try {\r\n            func();\r\n          } catch (e) {\r\n            _throwOrLog(\"afterFlush function\", e);\r\n          }\r\n        }\r\n      }\r\n      finishedTry = true;\r\n    } finally {\r\n      if (! finishedTry) {\r\n        // we're erroring\r\n        inFlush = false; // needed before calling `Deps.flush()` again\r\n        Deps.flush({_throwFirstError: false}); // finish flushing\r\n      }\r\n      willFlush = false;\r\n      inFlush = false;\r\n    }\r\n  },\r\n\r\n  // http://docs.meteor.com/#deps_autorun\r\n  //\r\n  // Run f(). Record its dependencies. Rerun it whenever the\r\n  // dependencies change.\r\n  //\r\n  // Returns a new Computation, which is also passed to f.\r\n  //\r\n  // Links the computation to the current computation\r\n  // so that it is stopped if the current computation is invalidated.\r\n  autorun: function (f) {\r\n    if (typeof f !== 'function')\r\n      throw new Error('Deps.autorun requires a function argument');\r\n\r\n    constructingComputation = true;\r\n    var c = new Deps.Computation(f, Deps.currentComputation);\r\n\r\n    if (Deps.active)\r\n      Deps.onInvalidate(function () {\r\n        c.stop();\r\n      });\r\n\r\n    return c;\r\n  },\r\n\r\n  // http://docs.meteor.com/#deps_nonreactive\r\n  //\r\n  // Run `f` with no current computation, returning the return value\r\n  // of `f`.  Used to turn off reactivity for the duration of `f`,\r\n  // so that reactive data sources accessed by `f` will not result in any\r\n  // computations being invalidated.\r\n  nonreactive: function (f) {\r\n    var previous = Deps.currentComputation;\r\n    setCurrentComputation(null);\r\n    try {\r\n      return f();\r\n    } finally {\r\n      setCurrentComputation(previous);\r\n    }\r\n  },\r\n\r\n  // http://docs.meteor.com/#deps_oninvalidate\r\n  onInvalidate: function (f) {\r\n    if (! Deps.active)\r\n      throw new Error(\"Deps.onInvalidate requires a currentComputation\");\r\n\r\n    Deps.currentComputation.onInvalidate(f);\r\n  },\r\n\r\n  // http://docs.meteor.com/#deps_afterflush\r\n  afterFlush: function (f) {\r\n    afterFlushCallbacks.push(f);\r\n    requireFlush();\r\n  }\r\n});\r\n","// Deprecated (Deps-recated?) functions.\r\n\r\n// These functions used to be on the Meteor object (and worked slightly\r\n// differently).\r\n// XXX COMPAT WITH 0.5.7\r\nMeteor.flush = Deps.flush;\r\nMeteor.autorun = Deps.autorun;\r\n\r\n// We used to require a special \"autosubscribe\" call to reactively subscribe to\r\n// things. Now, it works with autorun.\r\n// XXX COMPAT WITH 0.5.4\r\nMeteor.autosubscribe = Deps.autorun;\r\n\r\n// This Deps API briefly existed in 0.5.8 and 0.5.9\r\n// XXX COMPAT WITH 0.5.9\r\nDeps.depend = function (d) {\r\n  return d.depend();\r\n};\r\n"]}