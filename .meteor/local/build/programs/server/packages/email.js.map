{"version":3,"file":"\\packages\\email.js","sources":["email/email.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,0C;AACA,mC;AACA,4D;;AAEA,W;AACA,e;;AAEA,yC;AACA,+C;AACA,mC;AACA,qD;AACA,wD;;AAEA,6B;AACA,mB;AACA,qB;AACA,2C;AACA,2D;AACA,4D;AACA,G;;AAEA,6C;AACA,yC;AACA,4B;AACA,iD;AACA,uC;AACA,mD;AACA,oB;;AAEA,2E;AACA,c;AACA,E;;AAEA,iE;AACA,yC;AACA,iC;AACA,uB;;AAEA,2B;AACA,0E;AACA,oB;AACA,sB;AACA,2D;AACA,8D;AACA,sC;AACA,e;AACA,mD;AACA,sB;AACA,c;AACA,6B;AACA,kC;AACA,O;AACA,G;;AAEA,+B;AACA,E;;AAEA,6B;AACA,mC;;AAEA,gB;AACA,oD;AACA,2B;AACA,yB;AACA,E;;AAEA,6C;AACA,iC;AACA,E;;AAEA,iC;AACA,+C;;AAEA,2E;AACA,2E;AACA,e;AACA,6B;;AAEA,8E;AACA,sE;AACA,uE;AACA,2C;AACA,qB;AACA,gC;AACA,0B;AACA,4B;AACA,sE;AACA,uB;AACA,K;AACA,gB;AACA,E;;AAEA,oC;AACA,2C;AACA,E;;AAEA,G;AACA,uE;AACA,E;AACA,sE;AACA,mE;AACA,yB;AACA,G;AACA,mB;AACA,mC;AACA,oB;AACA,E;;AAEA,G;AACA,iB;AACA,E;AACA,sE;AACA,4E;AACA,2E;AACA,kC;AACA,E;AACA,iB;AACA,uD;AACA,gE;AACA,gE;AACA,kE;AACA,2E;AACA,0D;AACA,8D;AACA,wD;AACA,sE;AACA,G;AACA,iC;AACA,4C;AACA,gC;AACA,a;;AAEA,8B;;AAEA,uB;AACA,4E;AACA,sB;AACA,uB;AACA,uB;AACA,mB;AACA,mB;AACA,qB;AACA,6B;AACA,6B;AACA,uB;AACA,sB;AACA,K;;AAEA,kD;AACA,8B;AACA,K;;AAEA,uB;AACA,a;AACA,uB;AACA,U;AACA,oB;AACA,G;AACA,E","sourcesContent":["var Future = Npm.require('fibers/future');\r\nvar urlModule = Npm.require('url');\r\nvar MailComposer = Npm.require('mailcomposer').MailComposer;\r\n\r\nEmail = {};\r\nEmailTest = {};\r\n\r\nvar makePool = function (mailUrlString) {\r\n  var mailUrl = urlModule.parse(mailUrlString);\r\n  if (mailUrl.protocol !== 'smtp:')\r\n    throw new Error(\"Email protocol in $MAIL_URL (\" +\r\n                    mailUrlString + \") must be 'smtp'\");\r\n\r\n  var port = +(mailUrl.port);\r\n  var auth = false;\r\n  if (mailUrl.auth) {\r\n    var parts = mailUrl.auth.split(':', 2);\r\n    auth = {user: parts[0] && decodeURIComponent(parts[0]),\r\n            pass: parts[1] && decodeURIComponent(parts[1])};\r\n  }\r\n\r\n  var simplesmtp = Npm.require('simplesmtp');\r\n  var pool = simplesmtp.createClientPool(\r\n    port,  // Defaults to 25\r\n    mailUrl.hostname,  // Defaults to \"localhost\"\r\n    { secureConnection: (port === 465),\r\n      // XXX allow maxConnections to be configured?\r\n      auth: auth });\r\n\r\n  pool._future_wrapped_sendMail = _.bind(Future.wrap(pool.sendMail), pool);\r\n  return pool;\r\n};\r\n\r\n// We construct smtpPool at the first call to Email.send, so that\r\n// Meteor.startup code can set $MAIL_URL.\r\nvar smtpPoolFuture = new Future;;\r\nvar configured = false;\r\n\r\nvar getPool = function () {\r\n  // We check MAIL_URL in case someone else set it in Meteor.startup code.\r\n  if (!configured) {\r\n    configured = true;\r\n    AppConfig.configurePackage('email', function (config) {\r\n      // XXX allow reconfiguration when the app config changes\r\n      if (smtpPoolFuture.isResolved())\r\n        return;\r\n      var url = config.url || process.env.MAIL_URL;\r\n      var pool = null;\r\n      if (url)\r\n        pool = makePool(url);\r\n      smtpPoolFuture.return(pool);\r\n    });\r\n  }\r\n\r\n  return smtpPoolFuture.wait();\r\n};\r\n\r\nvar next_devmode_mail_id = 0;\r\nvar output_stream = process.stdout;\r\n\r\n// Testing hooks\r\nEmailTest.overrideOutputStream = function (stream) {\r\n  next_devmode_mail_id = 0;\r\n  output_stream = stream;\r\n};\r\n\r\nEmailTest.restoreOutputStream = function () {\r\n  output_stream = process.stdout;\r\n};\r\n\r\nvar devModeSend = function (mc) {\r\n  var devmode_mail_id = next_devmode_mail_id++;\r\n\r\n  // Make sure we use whatever stream was set at the time of the Email.send\r\n  // call even in the 'end' callback, in case there are multiple concurrent\r\n  // test runs.\r\n  var stream = output_stream;\r\n\r\n  // This approach does not prevent other writers to stdout from interleaving.\r\n  stream.write(\"====== BEGIN MAIL #\" + devmode_mail_id + \" ======\\n\");\r\n  stream.write(\"(Mail not sent; to enable sending, set the MAIL_URL \" +\r\n               \"environment variable.)\\n\");\r\n  mc.streamMessage();\r\n  mc.pipe(stream, {end: false});\r\n  var future = new Future;\r\n  mc.on('end', function () {\r\n    stream.write(\"====== END MAIL #\" + devmode_mail_id + \" ======\\n\");\r\n    future['return']();\r\n  });\r\n  future.wait();\r\n};\r\n\r\nvar smtpSend = function (pool, mc) {\r\n  pool._future_wrapped_sendMail(mc).wait();\r\n};\r\n\r\n/**\r\n * Mock out email sending (eg, during a test.) This is private for now.\r\n *\r\n * f receives the arguments to Email.send and should return true to go\r\n * ahead and send the email (or at least, try subsequent hooks), or\r\n * false to skip sending.\r\n */\r\nvar sendHooks = [];\r\nEmailTest.hookSend = function (f) {\r\n  sendHooks.push(f);\r\n};\r\n\r\n/**\r\n * Send an email.\r\n *\r\n * Connects to the mail server configured via the MAIL_URL environment\r\n * variable. If unset, prints formatted message to stdout. The \"from\" option\r\n * is required, and at least one of \"to\", \"cc\", and \"bcc\" must be provided;\r\n * all other options are optional.\r\n *\r\n * @param options\r\n * @param options.from {String} RFC5322 \"From:\" address\r\n * @param options.to {String|String[]} RFC5322 \"To:\" address[es]\r\n * @param options.cc {String|String[]} RFC5322 \"Cc:\" address[es]\r\n * @param options.bcc {String|String[]} RFC5322 \"Bcc:\" address[es]\r\n * @param options.replyTo {String|String[]} RFC5322 \"Reply-To:\" address[es]\r\n * @param options.subject {String} RFC5322 \"Subject:\" line\r\n * @param options.text {String} RFC5322 mail body (plain text)\r\n * @param options.html {String} RFC5322 mail body (HTML)\r\n * @param options.headers {Object} custom RFC5322 headers (dictionary)\r\n */\r\nEmail.send = function (options) {\r\n  for (var i = 0; i < sendHooks.length; i++)\r\n    if (! sendHooks[i](options))\r\n      return;\r\n\r\n  var mc = new MailComposer();\r\n\r\n  // setup message data\r\n  // XXX support attachments (once we have a client/server-compatible binary\r\n  //     Buffer class)\r\n  mc.setMessageOption({\r\n    from: options.from,\r\n    to: options.to,\r\n    cc: options.cc,\r\n    bcc: options.bcc,\r\n    replyTo: options.replyTo,\r\n    subject: options.subject,\r\n    text: options.text,\r\n    html: options.html\r\n  });\r\n\r\n  _.each(options.headers, function (value, name) {\r\n    mc.addHeader(name, value);\r\n  });\r\n\r\n  var pool = getPool();\r\n  if (pool) {\r\n    smtpSend(pool, mc);\r\n  } else {\r\n    devModeSend(mc);\r\n  }\r\n};\r\n"]}