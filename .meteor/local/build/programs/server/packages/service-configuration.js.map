{"version":3,"file":"\\packages\\service-configuration.js","sources":["service-configuration/service_configuration_common.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,kD;AACA,4B;AACA,C;;;AAGA,iE;AACA,gB;AACA,4D;AACA,gD;AACA,8B;AACA,yE;AACA,K;AACA,wE;AACA,uE;AACA,mE;AACA,qE;AACA,Q;;;AAGA,oE;AACA,2D;AACA,+D;AACA,gE;AACA,2B;AACA,gE;AACA,U;AACA,4C;AACA,G;AACA,E;AACA,yD;AACA,qF","sourcesContent":["if (typeof ServiceConfiguration === 'undefined') {\r\n  ServiceConfiguration = {};\r\n}\r\n\r\n\r\n// Table containing documents with configuration options for each\r\n// login service\r\nServiceConfiguration.configurations = new Meteor.Collection(\r\n  \"meteor_accounts_loginServiceConfiguration\", {\r\n    _preventAutopublish: true,\r\n    connection: Meteor.isClient ? Accounts.connection : Meteor.connection\r\n  });\r\n// Leave this collection open in insecure mode. In theory, someone could\r\n// hijack your oauth connect requests to a different endpoint or appId,\r\n// but you did ask for 'insecure'. The advantage is that it is much\r\n// easier to write a configuration wizard that works only in insecure\r\n// mode.\r\n\r\n\r\n// Thrown when trying to use a login service which is not configured\r\nServiceConfiguration.ConfigError = function (serviceName) {\r\n  if (Meteor.isClient && !Accounts.loginServicesConfigured()) {\r\n    this.message = \"Login service configuration not yet loaded\";\r\n  } else if (serviceName) {\r\n    this.message = \"Service \" + serviceName + \" not configured\";\r\n  } else {\r\n    this.message = \"Service not configured\";\r\n  }\r\n};\r\nServiceConfiguration.ConfigError.prototype = new Error();\r\nServiceConfiguration.ConfigError.prototype.name = 'ServiceConfiguration.ConfigError';\r\n"]}