{"version":3,"file":"\\packages\\oauth.js","sources":["oauth/oauth_server.js","oauth/pending_credentials.js","oauth/deprecated.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,kC;AACA,6B;;AAEA,W;AACA,e;;AAEA,2C;;AAEA,4B;;AAEA,+D;AACA,sE;AACA,iB;AACA,E;AACA,4B;;;AAGA,sE;AACA,sE;AACA,mE;AACA,c;AACA,E;AACA,iD;AACA,iD;AACA,4D;AACA,2D;AACA,uF;AACA,yE;AACA,uB;AACA,yE;AACA,8C;AACA,wD;AACA,E;AACA,4E;AACA,+B;AACA,yE;;AAEA,8B;AACA,sB;AACA,qB;AACA,e;AACA,0C;AACA,I;AACA,E;;AAEA,oB;AACA,+C;AACA,kC;AACA,E;;;AAGA,wE;AACA,6E;AACA,E;;;AAGA,yC;AACA,qD;AACA,gF;AACA,mD;AACA,qB;AACA,+B;AACA,W;AACA,G;;AAEA,wC;AACA,mE;AACA,e;AACA,O;AACA,4C;AACA,uB;AACA,uD;AACA,a;AACA,a;AACA,K;;AAEA,kD;;AAEA,wE;AACA,iB;AACA,iE;;AAEA,iC;AACA,kC;;AAEA,0D;AACA,iB;AACA,qE;AACA,qC;AACA,iB;AACA,oE;AACA,8D;AACA,M;AACA,oE;AACA,sE;AACA,iE;AACA,iD;AACA,kD;AACA,4D;AACA,4D;AACA,qB;AACA,uE;AACA,qE;AACA,gF;AACA,2C;AACA,O;AACA,K;;AAEA,+D;AACA,iE;AACA,4B;AACA,gD;AACA,kE;AACA,iD;AACA,oE;AACA,M;AACA,8D;AACA,+D;AACA,4C;AACA,oB;AACA,G;AACA,E;;AAEA,kC;;AAEA,uD;AACA,E;AACA,mE;AACA,gB;AACA,uC;AACA,sD;AACA,4D;AACA,sC;;AAEA,yD;AACA,iB;AACA,gC;AACA,gB;;AAEA,8B;AACA,iC;AACA,qB;AACA,E;;AAEA,6B;AACA,8C;AACA,6E;AACA,iD;AACA,G;AACA,E;;AAEA,mD;AACA,oE;AACA,qE;AACA,kD;AACA,wE;AACA,uE;AACA,6D;AACA,8C;AACA,sD;AACA,uC;AACA,2B;AACA,sD;AACA,oB;AACA,gF;AACA,mD;AACA,8B;AACA,4D;AACA,yD;AACA,qE;AACA,wE;AACA,8D;AACA,+D;AACA,2C;AACA,+E;AACA,0E;AACA,uD;AACA,Y;AACA,yB;AACA,K;AACA,c;AACA,U;AACA,sD;AACA,yB;AACA,G;AACA,E;;AAEA,yD;;AAEA,iC;AACA,4D;AACA,mB;AACA,uC;AACA,sC;AACA,I;;AAEA,oD;AACA,6E;AACA,sE;AACA,6E;AACA,wB;AACA,+B;AACA,+E;AACA,+C;AACA,oE;AACA,6E;AACA,G;AACA,e;AACA,gC;AACA,6B;AACA,gD;AACA,4B;AACA,E;;;AAGA,iG;;AAEA,wC;AACA,0D;AACA,E;;AAEA,8D;AACA,oE;AACA,gE;AACA,E;AACA,mE;AACA,mE;AACA,qE;AACA,sE;AACA,uC;AACA,E;AACA,yC;AACA,6B;AACA,2C;AACA,M;AACA,qB;AACA,C;;AAEA,4D;AACA,gD;AACA,E;AACA,sE;AACA,sE;AACA,E;AACA,mD;AACA,6E;AACA,uB;;AAEA,mD;AACA,E;;AAEA,+C;AACA,E;AACA,oD;AACA,kB;AACA,8C;AACA,6D;AACA,K;AACA,gB;AACA,E;;;;;;;;;;;;;;;;;;;ACnQA,E;AACA,mE;AACA,+D;AACA,6D;AACA,oC;AACA,E;AACA,iE;AACA,gC;AACA,E;;;AAGA,yE;AACA,6C;AACA,kD;AACA,sC;AACA,6B;AACA,K;;AAEA,2D;AACA,2D;AACA,oD;;;;AAIA,2D;AACA,qC;AACA,2C;AACA,8B;AACA,qD;AACA,uE;AACA,E;AACA,uE;;;AAGA,uE;AACA,oD;AACA,E;AACA,sB;AACA,uD;AACA,sE;AACA,qD;AACA,E;AACA,8E;AACA,qB;AACA,kD;;AAEA,oC;AACA,2C;AACA,U;AACA,8C;AACA,G;;AAEA,uE;AACA,qE;AACA,gD;AACA,oC;AACA,Y;AACA,M;AACA,a;AACA,2B;AACA,+C;AACA,yB;AACA,K;AACA,E;;;AAGA,6E;AACA,E;AACA,sB;AACA,mC;AACA,E;AACA,qE;AACA,qB;;AAEA,6D;AACA,a;AACA,8C;AACA,K;AACA,0B;AACA,qE;AACA,2C;AACA,+D;AACA,Q;AACA,4D;AACA,U;AACA,qB;AACA,G;AACA,E;;;AAGA,8D;AACA,0D;AACA,8D;AACA,qC;AACA,uB;AACA,2D;AACA,kC;AACA,K;;AAEA,8C;AACA,qC;AACA,sC;AACA,G;;AAEA,gC;AACA,E;;AAEA,wD;AACA,wC;AACA,Y;;AAEA,6B;AACA,+B;AACA,gC;AACA,U;AACA,wB;AACA,G;;AAEA,8D;AACA,+B;AACA,K;;AAEA,e;AACA,E;;;;;;;;;;;;;;;;;;;AC3HA,wB;;AAEA,c","sourcesContent":["var Fiber = Npm.require('fibers');\r\nvar url = Npm.require('url');\r\n\r\nOAuth = {};\r\nOAuthTest = {};\r\n\r\nRoutePolicy.declare('/_oauth/', 'network');\r\n\r\nvar registeredServices = {};\r\n\r\n// Internal: Maps from service version to handler function. The\r\n// 'oauth1' and 'oauth2' packages manipulate this directly to register\r\n// for callbacks.\r\n//\r\nOAuth._requestHandlers = {};\r\n\r\n\r\n// Register a handler for an OAuth service. The handler will be called\r\n// when we get an incoming http request on /_oauth/{serviceName}. This\r\n// handler should use that information to fetch data about the user\r\n// logging in.\r\n//\r\n// @param name {String} e.g. \"google\", \"facebook\"\r\n// @param version {Number} OAuth version (1 or 2)\r\n// @param urls   For OAuth1 only, specify the service's urls\r\n// @param handleOauthRequest {Function(oauthBinding|query)}\r\n//   - (For OAuth1 only) oauthBinding {OAuth1Binding} bound to the appropriate provider\r\n//   - (For OAuth2 only) query {Object} parameters passed in query string\r\n//   - return value is:\r\n//     - {serviceData:, (optional options:)} where serviceData should end\r\n//       up in the user's services[name] field\r\n//     - `null` if the user declined to give permissions\r\n//\r\nOAuth.registerService = function (name, version, urls, handleOauthRequest) {\r\n  if (registeredServices[name])\r\n    throw new Error(\"Already registered the \" + name + \" OAuth service\");\r\n\r\n  registeredServices[name] = {\r\n    serviceName: name,\r\n    version: version,\r\n    urls: urls,\r\n    handleOauthRequest: handleOauthRequest\r\n  };\r\n};\r\n\r\n// For test cleanup.\r\nOAuthTest.unregisterService = function (name) {\r\n  delete registeredServices[name];\r\n};\r\n\r\n\r\nOAuth.retrieveCredential = function(credentialToken, credentialSecret) {\r\n  return OAuth._retrievePendingCredential(credentialToken, credentialSecret);\r\n};\r\n\r\n\r\n// Listen to incoming OAuth http requests\r\nWebApp.connectHandlers.use(function(req, res, next) {\r\n  // Need to create a Fiber since we're using synchronous http calls and nothing\r\n  // else is wrapping this in a fiber automatically\r\n  Fiber(function () {\r\n    middleware(req, res, next);\r\n  }).run();\r\n});\r\n\r\nmiddleware = function (req, res, next) {\r\n  // Make sure to catch any exceptions because otherwise we'd crash\r\n  // the runner\r\n  try {\r\n    var serviceName = oauthServiceName(req);\r\n    if (!serviceName) {\r\n      // not an oauth request. pass to next middleware.\r\n      next();\r\n      return;\r\n    }\r\n\r\n    var service = registeredServices[serviceName];\r\n\r\n    // Skip everything if there's no service set by the oauth middleware\r\n    if (!service)\r\n      throw new Error(\"Unexpected OAuth service \" + serviceName);\r\n\r\n    // Make sure we're configured\r\n    ensureConfigured(serviceName);\r\n\r\n    var handler = OAuth._requestHandlers[service.version];\r\n    if (!handler)\r\n      throw new Error(\"Unexpected OAuth version \" + service.version);\r\n    handler(service, req.query, res);\r\n  } catch (err) {\r\n    // if we got thrown an error, save it off, it will get passed to\r\n    // the appropriate login call (if any) and reported there.\r\n    //\r\n    // The other option would be to display it in the popup tab that\r\n    // is still open at this point, ignoring the 'close' or 'redirect'\r\n    // we were passed. But then the developer wouldn't be able to\r\n    // style the error or react to it in any way.\r\n    if (req.query.state && err instanceof Error) {\r\n      try { // catch any exceptions to avoid crashing runner\r\n        OAuth._storePendingCredential(req.query.state, err);\r\n      } catch (err) {\r\n        // Ignore the error and just give up. If we failed to store the\r\n        // error, then the login will just fail with a generic error.\r\n        Log.warn(\"Error in OAuth Server while storing pending login result.\\n\" +\r\n                 err.stack || err.message);\r\n      }\r\n    }\r\n\r\n    // XXX the following is actually wrong. if someone wants to\r\n    // redirect rather than close once we are done with the OAuth\r\n    // flow, as supported by\r\n    // Oauth_renderOauthResults, this will still\r\n    // close the popup instead. Once we fully support the redirect\r\n    // flow (by supporting that in places such as\r\n    // packages/facebook/facebook_client.js) we should revisit this.\r\n    //\r\n    // close the popup. because nobody likes them just hanging\r\n    // there.  when someone sees this multiple times they might\r\n    // think to check server logs (we hope?)\r\n    closePopup(res);\r\n  }\r\n};\r\n\r\nOAuthTest.middleware = middleware;\r\n\r\n// Handle /_oauth/* paths and extract the service name.\r\n//\r\n// @returns {String|null} e.g. \"facebook\", or null if this isn't an\r\n// oauth request\r\nvar oauthServiceName = function (req) {\r\n  // req.url will be \"/_oauth/<service name>?<action>\"\r\n  var barePath = req.url.substring(0, req.url.indexOf('?'));\r\n  var splitPath = barePath.split('/');\r\n\r\n  // Any non-oauth request will continue down the default\r\n  // middlewares.\r\n  if (splitPath[1] !== '_oauth')\r\n    return null;\r\n\r\n  // Find service based on url\r\n  var serviceName = splitPath[2];\r\n  return serviceName;\r\n};\r\n\r\n// Make sure we're configured\r\nvar ensureConfigured = function(serviceName) {\r\n  if (!ServiceConfiguration.configurations.findOne({service: serviceName})) {\r\n    throw new ServiceConfiguration.ConfigError();\r\n  }\r\n};\r\n\r\n// Internal: used by the oauth1 and oauth2 packages\r\nOAuth._renderOauthResults = function(res, query, credentialSecret) {\r\n  // We support ?close and ?redirect=URL. Any other query should just\r\n  // serve a blank page. For tests, we support the\r\n  // `only_credential_secret_for_test` parameter, which just returns the\r\n  // credential secret without any surrounding HTML. (The test needs to\r\n  // be able to easily grab the secret and use it to log in.)\r\n  if (query.only_credential_secret_for_test) {\r\n    res.writeHead(200, {'Content-Type': 'text/html'});\r\n    res.end(credentialSecret, 'utf-8');\r\n  } else if (query.error) {\r\n    Log.warn(\"Error in OAuth Server: \" + query.error);\r\n    closePopup(res);\r\n  } else if ('close' in query) { // check with 'in' because we don't set a value\r\n    closePopup(res, query.state, credentialSecret);\r\n  } else if (query.redirect) {\r\n    // Only redirect to URLs on the same domain as this app.\r\n    // XXX No code in core uses this code path right now.\r\n    // XXX In order for the redirect flow to be fully supported, we'd\r\n    // have to communicate the credentialSecret back to the app somehow.\r\n    var redirectHostname = url.parse(query.redirect).hostname;\r\n    var appHostname = url.parse(Meteor.absoluteUrl()).hostname;\r\n    if (appHostname === redirectHostname) {\r\n      // We rely on node to make sure the header is really only a single header\r\n      // (not, for example, a url with a newline and then another header).\r\n      res.writeHead(302, {'Location': query.redirect});\r\n    } else {\r\n      res.writeHead(400);\r\n    }\r\n    res.end();\r\n  } else {\r\n    res.writeHead(200, {'Content-Type': 'text/html'});\r\n    res.end('', 'utf-8');\r\n  }\r\n};\r\n\r\nvar closePopup = function(res, state, credentialSecret) {\r\n\r\n  var isSafe = function (value) {\r\n    // This matches strings generated by `Random.secret` and\r\n    // `Random.id`.\r\n    return typeof value === \"string\" &&\r\n      /^[a-zA-Z0-9\\-_]+$/.test(value);\r\n  };\r\n\r\n  res.writeHead(200, {'Content-Type': 'text/html'});\r\n  // If we have a credentialSecret, report it back to the parent window, with\r\n  // the corresponding state (which we sanitize because it came from a\r\n  // query parameter). The parent window uses the state and credential secret\r\n  // to log in over DDP.\r\n  var setCredentialSecret = '';\r\n  if (state && credentialSecret && isSafe(state) && isSafe(credentialSecret)) {\r\n    setCredentialSecret = 'window.opener && ' +\r\n      'window.opener.Package.oauth.OAuth._handleCredentialSecret(' +\r\n      JSON.stringify(state) + ', ' + JSON.stringify(credentialSecret) + ');';\r\n  }\r\n  var content =\r\n        '<html><head><script>' +\r\n        setCredentialSecret +\r\n        'window.close()</script></head></html>';\r\n  res.end(content, 'utf-8');\r\n};\r\n\r\n\r\nvar OAuthEncryption = Package[\"oauth-encryption\"] && Package[\"oauth-encryption\"].OAuthEncryption;\r\n\r\nvar usingOAuthEncryption = function () {\r\n  return OAuthEncryption && OAuthEncryption.keyIsLoaded();\r\n};\r\n\r\n// Encrypt sensitive service data such as access tokens if the\r\n// \"oauth-encryption\" package is loaded and the oauth secret key has\r\n// been specified.  Returns the unencrypted plaintext otherwise.\r\n//\r\n// The user id is not specified because the user isn't known yet at\r\n// this point in the oauth authentication process.  After the oauth\r\n// authentication process completes the encrypted service data fields\r\n// will be re-encrypted with the user id included before inserting the\r\n// service data into the user document.\r\n//\r\nOAuth.sealSecret = function (plaintext) {\r\n  if (usingOAuthEncryption())\r\n    return OAuthEncryption.seal(plaintext);\r\n  else\r\n    return plaintext;\r\n}\r\n\r\n// Unencrypt a service data field, if the \"oauth-encryption\"\r\n// package is loaded and the field is encrypted.\r\n//\r\n// Throws an error if the \"oauth-encryption\" package is loaded and the\r\n// field is encrypted, but the oauth secret key hasn't been specified.\r\n//\r\nOAuth.openSecret = function (maybeSecret, userId) {\r\n  if (!Package[\"oauth-encryption\"] || !OAuthEncryption.isSealed(maybeSecret))\r\n    return maybeSecret;\r\n\r\n  return OAuthEncryption.open(maybeSecret, userId);\r\n};\r\n\r\n// Unencrypt fields in the service data object.\r\n//\r\nOAuth.openSecrets = function (serviceData, userId) {\r\n  var result = {};\r\n  _.each(_.keys(serviceData), function (key) {\r\n    result[key] = OAuth.openSecret(serviceData[key], userId);\r\n  });\r\n  return result;\r\n};\r\n","//\r\n// When an oauth request is made, Meteor receives oauth credentials\r\n// in one browser tab, and temporarily persists them while that\r\n// tab is closed, then retrieves them in the browser tab that\r\n// initiated the credential request.\r\n//\r\n// _pendingCredentials is the storage mechanism used to share the\r\n// credential between the 2 tabs\r\n//\r\n\r\n\r\n// Collection containing pending credentials of oauth credential requests\r\n// Has key, credential, and createdAt fields.\r\nOAuth._pendingCredentials = new Meteor.Collection(\r\n  \"meteor_oauth_pendingCredentials\", {\r\n    _preventAutopublish: true\r\n  });\r\n\r\nOAuth._pendingCredentials._ensureIndex('key', {unique: 1});\r\nOAuth._pendingCredentials._ensureIndex('credentialSecret');\r\nOAuth._pendingCredentials._ensureIndex('createdAt');\r\n\r\n\r\n\r\n// Periodically clear old entries that were never retrieved\r\nvar _cleanStaleResults = function() {\r\n  // Remove credentials older than 1 minute\r\n  var timeCutoff = new Date();\r\n  timeCutoff.setMinutes(timeCutoff.getMinutes() - 1);\r\n  OAuth._pendingCredentials.remove({ createdAt: { $lt: timeCutoff } });\r\n};\r\nvar _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000);\r\n\r\n\r\n// Stores the key and credential in the _pendingCredentials collection.\r\n// Will throw an exception if `key` is not a string.\r\n//\r\n// @param key {string}\r\n// @param credential {Object}   The credential to store\r\n// @param credentialSecret {string} A secret that must be presented in\r\n//   addition to the `key` to retrieve the credential\r\n//\r\nOAuth._storePendingCredential = function (key, credential, credentialSecret) {\r\n  check(key, String);\r\n  check(credentialSecret, Match.Optional(String));\r\n\r\n  if (credential instanceof Error) {\r\n    credential = storableError(credential);\r\n  } else {\r\n    credential = OAuth.sealSecret(credential);\r\n  }\r\n\r\n  // We do an upsert here instead of an insert in case the user happens\r\n  // to somehow send the same `state` parameter twice during an OAuth\r\n  // login; we don't want a duplicate key error.\r\n  OAuth._pendingCredentials.upsert({\r\n    key: key\r\n  }, {\r\n    key: key,\r\n    credential: credential,\r\n    credentialSecret: credentialSecret || null,\r\n    createdAt: new Date()\r\n  });\r\n};\r\n\r\n\r\n// Retrieves and removes a credential from the _pendingCredentials collection\r\n//\r\n// @param key {string}\r\n// @param credentialSecret {string}\r\n//\r\nOAuth._retrievePendingCredential = function (key, credentialSecret) {\r\n  check(key, String);\r\n\r\n  var pendingCredential = OAuth._pendingCredentials.findOne({\r\n    key: key,\r\n    credentialSecret: credentialSecret || null\r\n  });\r\n  if (pendingCredential) {\r\n    OAuth._pendingCredentials.remove({ _id: pendingCredential._id });\r\n    if (pendingCredential.credential.error)\r\n      return recreateError(pendingCredential.credential.error);\r\n    else\r\n      return OAuth.openSecret(pendingCredential.credential);\r\n  } else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\n\r\n// Convert an Error into an object that can be stored in mongo\r\n// Note: A Meteor.Error is reconstructed as a Meteor.Error\r\n// All other error classes are reconstructed as a plain Error.\r\nvar storableError = function(error) {\r\n  var plainObject = {};\r\n  Object.getOwnPropertyNames(error).forEach(function(key) {\r\n    plainObject[key] = error[key];\r\n  });\r\n\r\n  // Keep track of whether it's a Meteor.Error\r\n  if(error instanceof Meteor.Error) {\r\n    plainObject['meteorError'] = true;\r\n  }\r\n\r\n  return { error: plainObject };\r\n};\r\n\r\n// Create an error from the error format stored in mongo\r\nvar recreateError = function(errorDoc) {\r\n  var error;\r\n\r\n  if (errorDoc.meteorError) {\r\n    error = new Meteor.Error();\r\n    delete errorDoc.meteorError;\r\n  } else {\r\n    error = new Error();\r\n  }\r\n\r\n  Object.getOwnPropertyNames(errorDoc).forEach(function(key) {\r\n    error[key] = errorDoc[key];\r\n  });\r\n\r\n  return error;\r\n};\r\n","// XXX COMPAT WITH 0.8.0\r\n\r\nOauth = OAuth;\r\n"]}