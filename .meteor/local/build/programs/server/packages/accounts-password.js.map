{"version":3,"file":"\\packages\\accounts-password.js","sources":["accounts-password/email_templates.js","accounts-password/password_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,2B;AACA,gD;AACA,gF;;AAEA,kB;AACA,6B;AACA,iF;AACA,M;AACA,+B;AACA,0D;AACA,4D;AACA,4B;AACA,c;AACA,kE;AACA,c;AACA,oB;AACA,c;AACA,sB;AACA,K;AACA,I;AACA,gB;AACA,6B;AACA,kF;AACA,M;AACA,+B;AACA,0D;AACA,4D;AACA,4B;AACA,c;AACA,wE;AACA,c;AACA,oB;AACA,c;AACA,sB;AACA,K;AACA,I;AACA,kB;AACA,6B;AACA,0F;AACA,M;AACA,+B;AACA,0D;AACA,4D;AACA,4B;AACA,c;AACA,sE;AACA,c;AACA,oB;AACA,c;AACA,sB;AACA,K;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACpDA,G;AACA,S;AACA,G;;AAEA,8D;AACA,iE;AACA,+D;;AAEA,6C;AACA,c;AACA,0B;AACA,yB;AACA,qC;AACA,sB;AACA,0C;AACA,oE;AACA,E;;AAEA,8C;AACA,+C;AACA,mB;AACA,sB;AACA,G;;AAEA,sD;AACA,e;AACA,uC;AACA,6C;AACA,yC;AACA,K;AACA,gC;AACA,uE;AACA,c;AACA,G;;AAEA,iE;AACA,qE;AACA,oE;AACA,oE;AACA,oC;AACA,E;AACA,uC;AACA,6E;AACA,kE;AACA,iC;AACA,+B;AACA,2B;AACA,8D;AACA,2D;AACA,kB;AACA,O;AACA,oB;AACA,+B;AACA,e;AACA,O;AACA,uD;;AAEA,8C;AACA,c;AACA,oD;;AAEA,oD;AACA,oC;AACA,8D;;AAEA,8C;AACA,uC;AACA,uD;;AAEA,iB;AACA,wE;AACA,sE;AACA,kE;AACA,mE;AACA,+C;AACA,sE;AACA,0F;AACA,uB;AACA,iB;AACA,8B;AACA,O;AACA,wB;AACA,G;;AAEA,8C;AACA,8D;AACA,kD;AACA,I;AACA,mB;AACA,I;;AAEA,sE;AACA,yB;AACA,8D;AACA,mB;AACA,qC;AACA,kC;;AAEA,qE;AACA,a;AACA,uD;AACA,6F;AACA,oD;AACA,Y;AACA,8C;AACA,wD;AACA,M;AACA,kC;AACA,uF;;AAEA,iC;AACA,0C;AACA,4D;AACA,Y;AACA,Y;AACA,qB;AACA,oD;AACA,M;;AAEA,U;AACA,mB;AACA,oC;AACA,I;AACA,G;;AAEA,4C;AACA,E;AACA,sE;AACA,oE;AACA,iD;AACA,E;AACA,qE;AACA,yD;AACA,8D;AACA,yC;AACA,qC;;AAEA,+D;;AAEA,qD;AACA,4C;AACA,Y;AACA,kD;;AAEA,kD;AACA,kC;AACA,Y;AACA,uB;AACA,8D;AACA,M;;AAEA,mE;AACA,mD;AACA,4C;AACA,4D;AACA,uD;;AAEA,iD;AACA,Y;AACA,uB;AACA,wD;AACA,M;;AAEA,4B;AACA,G;;;AAGA,G;AACA,Y;AACA,G;;AAEA,8D;AACA,+D;AACA,oD;AACA,mB;AACA,qD;AACA,kB;AACA,6E;AACA,+E;AACA,gB;AACA,c;AACA,2C;AACA,oC;AACA,K;;AAEA,gF;AACA,gD;AACA,sD;AACA,wC;AACA,0B;AACA,sD;AACA,kC;AACA,0E;;AAEA,6B;AACA,sC;AACA,sD;AACA,G;AACA,gB;AACA,oD;;AAEA,wE;AACA,wE;AACA,wE;AACA,wC;AACA,iE;AACA,sB;AACA,yB;AACA,K;AACA,kD;AACA,c;AACA,6E;AACA,O;AACA,K;AACA,I;;AAEA,oC;AACA,iB;AACA,+B;AACA,a;AACA,I;;;AAGA,mC;AACA,uD;AACA,0C;AACA,Y;AACA,kD;AACA,sD;;AAEA,wC;AACA,mD;AACA,E;;;AAGA,G;AACA,uB;AACA,G;;AAEA,qE;AACA,kC;AACA,oD;AACA,kC;;AAEA,qE;AACA,Y;AACA,kD;;AAEA,2D;AACA,I;;AAEA,sE;AACA,mD;AACA,E;AACA,4D;AACA,oE;AACA,0C;AACA,Y;AACA,uC;AACA,wD;AACA,8C;AACA,mC;AACA,oC;AACA,0E;AACA,+C;;AAEA,8B;AACA,wB;AACA,sC;AACA,gC;AACA,mB;AACA,mB;AACA,gB;AACA,K;AACA,M;;AAEA,4D;;AAEA,iB;AACA,c;AACA,uC;AACA,iE;AACA,4E;AACA,I;;AAEA,uE;AACA,kB;AACA,yE;;AAEA,sB;AACA,E;;AAEA,6E;AACA,6E;AACA,0E;AACA,2E;AACA,E;AACA,sE;AACA,iC;AACA,E;AACA,yD;AACA,yE;;AAEA,gE;AACA,0C;AACA,Y;AACA,uC;AACA,wD;AACA,8C;AACA,mC;AACA,oC;AACA,0E;AACA,+C;;;AAGA,8B;AACA,wB;AACA,sC;AACA,gC;AACA,mB;AACA,mB;AACA,gB;AACA,K;AACA,M;;AAEA,4D;;AAEA,iB;AACA,c;AACA,uC;AACA,iE;AACA,4E;AACA,I;;AAEA,uE;AACA,kB;AACA,yE;;AAEA,sB;AACA,E;;;AAGA,wE;AACA,uC;AACA,8D;AACA,kB;AACA,+B;AACA,S;AACA,oB;AACA,c;AACA,e;AACA,iB;AACA,2B;AACA,4C;;AAEA,uC;AACA,oD;AACA,gB;AACA,qD;AACA,qD;AACA,mE;AACA,gB;AACA,2B;AACA,yE;AACA,U;;AAEA,4E;AACA,uE;AACA,2E;AACA,kD;AACA,iE;AACA,+D;AACA,yC;AACA,qE;AACA,Q;;AAEA,W;AACA,qC;AACA,0D;AACA,gE;AACA,gF;AACA,kD;AACA,W;AACA,0B;AACA,oC;AACA,kD;AACA,Y;AACA,uD;AACA,6C;AACA,oD;AACA,kC;AACA,kB;AACA,6B;AACA,yD;AACA,Y;AACA,qB;AACA,0B;AACA,kB;AACA,O;;AAEA,+D;AACA,uD;AACA,8C;;AAEA,gC;AACA,K;AACA,I;AACA,I;;AAEA,G;AACA,sB;AACA,G;;;AAGA,iE;AACA,sB;AACA,E;AACA,6D;AACA,iE;AACA,mE;AACA,kB;;AAEA,sE;AACA,0C;AACA,Y;AACA,uC;AACA,uE;AACA,iB;AACA,yC;AACA,6D;AACA,oC;AACA,G;AACA,sC;AACA,8E;AACA,uD;;;AAGA,qB;AACA,2B;AACA,qB;AACA,sB;AACA,sB;AACA,kB;AACA,iE;;AAEA,oE;;AAEA,iB;AACA,gB;AACA,uC;AACA,+D;AACA,wE;AACA,I;;AAEA,qE;AACA,kB;AACA,qE;;AAEA,sB;AACA,E;;AAEA,qE;AACA,mB;AACA,+C;AACA,kB;AACA,+B;AACA,S;AACA,kB;AACA,c;AACA,e;AACA,iB;AACA,2B;;AAEA,sC;AACA,4D;AACA,gB;AACA,iE;;AAEA,sE;AACA,6C;AACA,yD;AACA,kC;AACA,uB;AACA,gB;AACA,2B;AACA,mE;AACA,U;;AAEA,2D;AACA,gD;AACA,S;AACA,wB;AACA,gB;AACA,2B;AACA,kF;AACA,U;;AAEA,4E;AACA,yE;AACA,mB;AACA,yF;AACA,sE;AACA,0B;AACA,uB;AACA,gD;AACA,2C;AACA,wE;;AAEA,gC;AACA,K;AACA,I;AACA,I;;;;AAIA,G;AACA,kB;AACA,G;;AAEA,qE;AACA,qE;AACA,kC;AACA,E;AACA,sB;AACA,qC;AACA,wE;AACA,a;AACA,wC;AACA,qC;AACA,kC;AACA,qC;AACA,0C;AACA,M;;AAEA,kC;AACA,4B;AACA,0B;AACA,mE;;AAEA,iE;AACA,kE;AACA,2B;AACA,yB;AACA,oB;AACA,iF;AACA,yD;AACA,G;;AAEA,4B;AACA,kB;AACA,yE;AACA,e;AACA,6B;AACA,Y;AACA,sD;;AAEA,+C;AACA,E;;AAEA,yD;AACA,gD;AACA,kB;AACA,+B;AACA,S;AACA,iB;AACA,c;AACA,e;AACA,iB;AACA,+C;AACA,6B;AACA,wD;AACA,gB;AACA,2D;AACA,U;;AAEA,mD;AACA,uC;AACA,8E;AACA,mE;AACA,mB;AACA,gE;;AAEA,sE;AACA,mE;AACA,sB;AACA,mE;AACA,8D;;AAEA,0D;AACA,8B;AACA,K;AACA,I;AACA,I;;AAEA,sC;AACA,E;AACA,mE;AACA,kB;AACA,E;AACA,uD;AACA,E;AACA,8E;AACA,4E;AACA,8E;AACA,gD;AACA,E;AACA,oD;AACA,6B;;AAEA,oC;AACA,iB;AACA,0F;AACA,G;;AAEA,6B;AACA,E;;AAEA,G;AACA,sC;AACA,G;AACA,0D;AACA,kD;AACA,0D;AACA,kD","sourcesContent":["Accounts.emailTemplates = {\r\n  from: \"Meteor Accounts <no-reply@meteor.com>\",\r\n  siteName: Meteor.absoluteUrl().replace(/^https?:\\/\\//, '').replace(/\\/$/, ''),\r\n\r\n  resetPassword: {\r\n    subject: function(user) {\r\n      return \"How to reset your password on \" + Accounts.emailTemplates.siteName;\r\n    },\r\n    text: function(user, url) {\r\n      var greeting = (user.profile && user.profile.name) ?\r\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\r\n      return greeting + \"\\n\"\r\n        + \"\\n\"\r\n        + \"To reset your password, simply click the link below.\\n\"\r\n        + \"\\n\"\r\n        + url + \"\\n\"\r\n        + \"\\n\"\r\n        + \"Thanks.\\n\";\r\n    }\r\n  },\r\n  verifyEmail: {\r\n    subject: function(user) {\r\n      return \"How to verify email address on \" + Accounts.emailTemplates.siteName;\r\n    },\r\n    text: function(user, url) {\r\n      var greeting = (user.profile && user.profile.name) ?\r\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\r\n      return greeting + \"\\n\"\r\n        + \"\\n\"\r\n        + \"To verify your account email, simply click the link below.\\n\"\r\n        + \"\\n\"\r\n        + url + \"\\n\"\r\n        + \"\\n\"\r\n        + \"Thanks.\\n\";\r\n    }\r\n  },\r\n  enrollAccount: {\r\n    subject: function(user) {\r\n      return \"An account has been created for you on \" + Accounts.emailTemplates.siteName;\r\n    },\r\n    text: function(user, url) {\r\n      var greeting = (user.profile && user.profile.name) ?\r\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\r\n      return greeting + \"\\n\"\r\n        + \"\\n\"\r\n        + \"To start using the service, simply click the link below.\\n\"\r\n        + \"\\n\"\r\n        + url + \"\\n\"\r\n        + \"\\n\"\r\n        + \"Thanks.\\n\";\r\n    }\r\n  }\r\n};\r\n","///\r\n/// LOGIN\r\n///\r\n\r\n// Users can specify various keys to identify themselves with.\r\n// @param user {Object} with one of `id`, `username`, or `email`.\r\n// @returns A selector to pass to mongo to get the user record.\r\n\r\nvar selectorFromUserQuery = function (user) {\r\n  if (user.id)\r\n    return {_id: user.id};\r\n  else if (user.username)\r\n    return {username: user.username};\r\n  else if (user.email)\r\n    return {\"emails.address\": user.email};\r\n  throw new Error(\"shouldn't happen (validation missed something)\");\r\n};\r\n\r\n// XXX maybe this belongs in the check package\r\nvar NonEmptyString = Match.Where(function (x) {\r\n  check(x, String);\r\n  return x.length > 0;\r\n});\r\n\r\nvar userQueryValidator = Match.Where(function (user) {\r\n  check(user, {\r\n    id: Match.Optional(NonEmptyString),\r\n    username: Match.Optional(NonEmptyString),\r\n    email: Match.Optional(NonEmptyString)\r\n  });\r\n  if (_.keys(user).length !== 1)\r\n    throw new Match.Error(\"User property must have exactly one field\");\r\n  return true;\r\n});\r\n\r\n// Step 1 of SRP password exchange. This puts an `M` value in the\r\n// session data for this connection. If a client later sends the same\r\n// `M` value to a method on this connection, it proves they know the\r\n// password for this user. We can then prove we know the password to\r\n// them by sending our `HAMK` value.\r\n//\r\n// @param request {Object} with fields:\r\n//   user: either {username: (username)}, {email: (email)}, or {id: (userId)}\r\n//   A: hex encoded int. the client's public key for this exchange\r\n// @returns {Object} with fields:\r\n//   identity: random string ID\r\n//   salt: random string ID\r\n//   B: hex encoded int. server's public key for this exchange\r\nMeteor.methods({beginPasswordExchange: function (request) {\r\n  var self = this;\r\n  try {\r\n    check(request, {\r\n      user: userQueryValidator,\r\n      A: String\r\n    });\r\n    var selector = selectorFromUserQuery(request.user);\r\n\r\n    var user = Meteor.users.findOne(selector);\r\n    if (!user)\r\n      throw new Meteor.Error(403, \"User not found\");\r\n\r\n    if (!user.services || !user.services.password ||\r\n        !user.services.password.srp)\r\n      throw new Meteor.Error(403, \"User has no password set\");\r\n\r\n    var verifier = user.services.password.srp;\r\n    var srp = new SRP.Server(verifier);\r\n    var challenge = srp.issueChallenge({A: request.A});\r\n\r\n  } catch (err) {\r\n    // Report login failure if the method fails, so that login hooks are\r\n    // called. If the method succeeds, login hooks will be called when\r\n    // the second step method ('login') is called. If a user calls\r\n    // 'beginPasswordExchange' but then never calls the second step\r\n    // 'login' method, no login hook will fire.\r\n    // The validate login hooks can mutate the exception to be thrown.\r\n    var attempt = Accounts._reportLoginFailure(self, 'beginPasswordExchange', arguments, {\r\n      type: 'password',\r\n      error: err,\r\n      userId: user && user._id\r\n    });\r\n    throw attempt.error;\r\n  }\r\n\r\n  // Save results so we can verify them later.\r\n  Accounts._setAccountData(this.connection.id, 'srpChallenge',\r\n    { userId: user._id, M: srp.M, HAMK: srp.HAMK }\r\n  );\r\n  return challenge;\r\n}});\r\n\r\n// Handler to login with password via SRP. Checks the `M` value set by\r\n// beginPasswordExchange.\r\nAccounts.registerLoginHandler(\"password\", function (options) {\r\n  if (!options.srp)\r\n    return undefined; // don't handle\r\n  check(options.srp, {M: String});\r\n\r\n  // we're always called from within a 'login' method, so this should\r\n  // be safe.\r\n  var currentInvocation = DDP._CurrentInvocation.get();\r\n  var serialized = Accounts._getAccountData(currentInvocation.connection.id, 'srpChallenge');\r\n  if (!serialized || serialized.M !== options.srp.M)\r\n    return {\r\n      userId: serialized && serialized.userId,\r\n      error: new Meteor.Error(403, \"Incorrect password\")\r\n    };\r\n  // Only can use challenges once.\r\n  Accounts._setAccountData(currentInvocation.connection.id, 'srpChallenge', undefined);\r\n\r\n  var userId = serialized.userId;\r\n  var user = Meteor.users.findOne(userId);\r\n  // Was the user deleted since the start of this challenge?\r\n  if (!user)\r\n    return {\r\n      userId: userId,\r\n      error: new Meteor.Error(403, \"User not found\")\r\n    };\r\n\r\n  return {\r\n    userId: userId,\r\n    options: {HAMK: serialized.HAMK}\r\n  };\r\n});\r\n\r\n// Handler to login with plaintext password.\r\n//\r\n// The meteor client doesn't use this, it is for other DDP clients who\r\n// haven't implemented SRP. Since it sends the password in plaintext\r\n// over the wire, it should only be run over SSL!\r\n//\r\n// Also, it might be nice if servers could turn this off. Or maybe it\r\n// should be opt-in, not opt-out? Accounts.config option?\r\nAccounts.registerLoginHandler(\"password\", function (options) {\r\n  if (!options.password || !options.user)\r\n    return undefined; // don't handle\r\n\r\n  check(options, {user: userQueryValidator, password: String});\r\n\r\n  var selector = selectorFromUserQuery(options.user);\r\n  var user = Meteor.users.findOne(selector);\r\n  if (!user)\r\n    throw new Meteor.Error(403, \"User not found\");\r\n\r\n  if (!user.services || !user.services.password ||\r\n      !user.services.password.srp)\r\n    return {\r\n      userId: user._id,\r\n      error: new Meteor.Error(403, \"User has no password set\")\r\n    };\r\n\r\n  // Just check the verifier output when the same identity and salt\r\n  // are passed. Don't bother with a full exchange.\r\n  var verifier = user.services.password.srp;\r\n  var newVerifier = SRP.generateVerifier(options.password, {\r\n    identity: verifier.identity, salt: verifier.salt});\r\n\r\n  if (verifier.verifier !== newVerifier.verifier)\r\n    return {\r\n      userId: user._id,\r\n      error: new Meteor.Error(403, \"Incorrect password\")\r\n    };\r\n\r\n  return {userId: user._id};\r\n});\r\n\r\n\r\n///\r\n/// CHANGING\r\n///\r\n\r\n// Let the user change their own password if they know the old\r\n// password. Checks the `M` value set by beginPasswordExchange.\r\nMeteor.methods({changePassword: function (options) {\r\n  if (!this.userId)\r\n    throw new Meteor.Error(401, \"Must be logged in\");\r\n  check(options, {\r\n    // If options.M is set, it means we went through a challenge with the old\r\n    // password. For now, we don't allow changePassword without knowing the old\r\n    // password.\r\n    M: String,\r\n    srp: Match.Optional(SRP.matchVerifier),\r\n    password: Match.Optional(String)\r\n  });\r\n\r\n  var serialized = Accounts._getAccountData(this.connection.id, 'srpChallenge');\r\n  if (!serialized || serialized.M !== options.M)\r\n    throw new Meteor.Error(403, \"Incorrect password\");\r\n  if (serialized.userId !== this.userId)\r\n    // No monkey business!\r\n    throw new Meteor.Error(403, \"Incorrect password\");\r\n  // Only can use challenges once.\r\n  Accounts._setAccountData(this.connection.id, 'srpChallenge', undefined);\r\n\r\n  var verifier = options.srp;\r\n  if (!verifier && options.password) {\r\n    verifier = SRP.generateVerifier(options.password);\r\n  }\r\n  if (!verifier)\r\n    throw new Meteor.Error(400, \"Invalid verifier\");\r\n\r\n  // It would be better if this removed ALL existing tokens and replaced\r\n  // the token for the current connection with a new one, but that would\r\n  // be tricky, so we'll settle for just replacing all tokens other than\r\n  // the one for the current connection.\r\n  var currentToken = Accounts._getLoginToken(this.connection.id);\r\n  Meteor.users.update(\r\n    { _id: this.userId },\r\n    {\r\n      $set: { 'services.password.srp': verifier },\r\n      $pull: {\r\n        'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }\r\n      }\r\n    }\r\n  );\r\n\r\n  var ret = {passwordChanged: true};\r\n  if (serialized)\r\n    ret.HAMK = serialized.HAMK;\r\n  return ret;\r\n}});\r\n\r\n\r\n// Force change the users password.\r\nAccounts.setPassword = function (userId, newPassword) {\r\n  var user = Meteor.users.findOne(userId);\r\n  if (!user)\r\n    throw new Meteor.Error(403, \"User not found\");\r\n  var newVerifier = SRP.generateVerifier(newPassword);\r\n\r\n  Meteor.users.update({_id: user._id}, {\r\n    $set: {'services.password.srp': newVerifier}});\r\n};\r\n\r\n\r\n///\r\n/// RESETTING VIA EMAIL\r\n///\r\n\r\n// Method called by a user to request a password reset email. This is\r\n// the start of the reset process.\r\nMeteor.methods({forgotPassword: function (options) {\r\n  check(options, {email: String});\r\n\r\n  var user = Meteor.users.findOne({\"emails.address\": options.email});\r\n  if (!user)\r\n    throw new Meteor.Error(403, \"User not found\");\r\n\r\n  Accounts.sendResetPasswordEmail(user._id, options.email);\r\n}});\r\n\r\n// send the user an email with a link that when opened allows the user\r\n// to set a new password, without the old password.\r\n//\r\nAccounts.sendResetPasswordEmail = function (userId, email) {\r\n  // Make sure the user exists, and email is one of their addresses.\r\n  var user = Meteor.users.findOne(userId);\r\n  if (!user)\r\n    throw new Error(\"Can't find user\");\r\n  // pick the first email if we weren't passed an email.\r\n  if (!email && user.emails && user.emails[0])\r\n    email = user.emails[0].address;\r\n  // make sure we have a valid email\r\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email))\r\n    throw new Error(\"No such email for user.\");\r\n\r\n  var token = Random.secret();\r\n  var when = new Date();\r\n  Meteor.users.update(userId, {$set: {\r\n    \"services.password.reset\": {\r\n      token: token,\r\n      email: email,\r\n      when: when\r\n    }\r\n  }});\r\n\r\n  var resetPasswordUrl = Accounts.urls.resetPassword(token);\r\n\r\n  var options = {\r\n    to: email,\r\n    from: Accounts.emailTemplates.from,\r\n    subject: Accounts.emailTemplates.resetPassword.subject(user),\r\n    text: Accounts.emailTemplates.resetPassword.text(user, resetPasswordUrl)\r\n  };\r\n\r\n  if (typeof Accounts.emailTemplates.resetPassword.html === 'function')\r\n    options.html =\r\n      Accounts.emailTemplates.resetPassword.html(user, resetPasswordUrl);\r\n\r\n  Email.send(options);\r\n};\r\n\r\n// send the user an email informing them that their account was created, with\r\n// a link that when opened both marks their email as verified and forces them\r\n// to choose their password. The email must be one of the addresses in the\r\n// user's emails field, or undefined to pick the first email automatically.\r\n//\r\n// This is not called automatically. It must be called manually if you\r\n// want to use enrollment emails.\r\n//\r\nAccounts.sendEnrollmentEmail = function (userId, email) {\r\n  // XXX refactor! This is basically identical to sendResetPasswordEmail.\r\n\r\n  // Make sure the user exists, and email is in their addresses.\r\n  var user = Meteor.users.findOne(userId);\r\n  if (!user)\r\n    throw new Error(\"Can't find user\");\r\n  // pick the first email if we weren't passed an email.\r\n  if (!email && user.emails && user.emails[0])\r\n    email = user.emails[0].address;\r\n  // make sure we have a valid email\r\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email))\r\n    throw new Error(\"No such email for user.\");\r\n\r\n\r\n  var token = Random.secret();\r\n  var when = new Date();\r\n  Meteor.users.update(userId, {$set: {\r\n    \"services.password.reset\": {\r\n      token: token,\r\n      email: email,\r\n      when: when\r\n    }\r\n  }});\r\n\r\n  var enrollAccountUrl = Accounts.urls.enrollAccount(token);\r\n\r\n  var options = {\r\n    to: email,\r\n    from: Accounts.emailTemplates.from,\r\n    subject: Accounts.emailTemplates.enrollAccount.subject(user),\r\n    text: Accounts.emailTemplates.enrollAccount.text(user, enrollAccountUrl)\r\n  };\r\n\r\n  if (typeof Accounts.emailTemplates.enrollAccount.html === 'function')\r\n    options.html =\r\n      Accounts.emailTemplates.enrollAccount.html(user, enrollAccountUrl);\r\n\r\n  Email.send(options);\r\n};\r\n\r\n\r\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\r\n// the users password, and log them in.\r\nMeteor.methods({resetPassword: function (token, newVerifier) {\r\n  var self = this;\r\n  return Accounts._loginMethod(\r\n    self,\r\n    \"resetPassword\",\r\n    arguments,\r\n    \"password\",\r\n    function () {\r\n      check(token, String);\r\n      check(newVerifier, SRP.matchVerifier);\r\n\r\n      var user = Meteor.users.findOne({\r\n        \"services.password.reset.token\": \"\"+token});\r\n      if (!user)\r\n        throw new Meteor.Error(403, \"Token expired\");\r\n      var email = user.services.password.reset.email;\r\n      if (!_.include(_.pluck(user.emails || [], 'address'), email))\r\n        return {\r\n          userId: user._id,\r\n          error: new Meteor.Error(403, \"Token has invalid email address\")\r\n        };\r\n\r\n      // NOTE: We're about to invalidate tokens on the user, who we might be\r\n      // logged in as. Make sure to avoid logging ourselves out if this\r\n      // happens. But also make sure not to leave the connection in a state\r\n      // of having a bad token set if things fail.\r\n      var oldToken = Accounts._getLoginToken(self.connection.id);\r\n      Accounts._setLoginToken(user._id, self.connection, null);\r\n      var resetToOldToken = function () {\r\n        Accounts._setLoginToken(user._id, self.connection, oldToken);\r\n      };\r\n\r\n      try {\r\n        // Update the user record by:\r\n        // - Changing the password verifier to the new one\r\n        // - Forgetting about the reset token that was just used\r\n        // - Verifying their email, since they got the password reset via email.\r\n        var affectedRecords = Meteor.users.update(\r\n          {\r\n            _id: user._id,\r\n            'emails.address': email,\r\n            'services.password.reset.token': token\r\n          },\r\n          {$set: {'services.password.srp': newVerifier,\r\n                  'emails.$.verified': true},\r\n           $unset: {'services.password.reset': 1}});\r\n        if (affectedRecords !== 1)\r\n          return {\r\n            userId: user._id,\r\n            error: new Meteor.Error(403, \"Invalid email\")\r\n          };\r\n      } catch (err) {\r\n        resetToOldToken();\r\n        throw err;\r\n      }\r\n\r\n      // Replace all valid login tokens with new ones (changing\r\n      // password should invalidate existing sessions).\r\n      Accounts._clearAllLoginTokens(user._id);\r\n\r\n      return {userId: user._id};\r\n    }\r\n  );\r\n}});\r\n\r\n///\r\n/// EMAIL VERIFICATION\r\n///\r\n\r\n\r\n// send the user an email with a link that when opened marks that\r\n// address as verified\r\n//\r\nAccounts.sendVerificationEmail = function (userId, address) {\r\n  // XXX Also generate a link using which someone can delete this\r\n  // account if they own said address but weren't those who created\r\n  // this account.\r\n\r\n  // Make sure the user exists, and address is one of their addresses.\r\n  var user = Meteor.users.findOne(userId);\r\n  if (!user)\r\n    throw new Error(\"Can't find user\");\r\n  // pick the first unverified address if we weren't passed an address.\r\n  if (!address) {\r\n    var email = _.find(user.emails || [],\r\n                       function (e) { return !e.verified; });\r\n    address = (email || {}).address;\r\n  }\r\n  // make sure we have a valid address\r\n  if (!address || !_.contains(_.pluck(user.emails || [], 'address'), address))\r\n    throw new Error(\"No such email address for user.\");\r\n\r\n\r\n  var tokenRecord = {\r\n    token: Random.secret(),\r\n    address: address,\r\n    when: new Date()};\r\n  Meteor.users.update(\r\n    {_id: userId},\r\n    {$push: {'services.email.verificationTokens': tokenRecord}});\r\n\r\n  var verifyEmailUrl = Accounts.urls.verifyEmail(tokenRecord.token);\r\n\r\n  var options = {\r\n    to: address,\r\n    from: Accounts.emailTemplates.from,\r\n    subject: Accounts.emailTemplates.verifyEmail.subject(user),\r\n    text: Accounts.emailTemplates.verifyEmail.text(user, verifyEmailUrl)\r\n  };\r\n\r\n  if (typeof Accounts.emailTemplates.verifyEmail.html === 'function')\r\n    options.html =\r\n      Accounts.emailTemplates.verifyEmail.html(user, verifyEmailUrl);\r\n\r\n  Email.send(options);\r\n};\r\n\r\n// Take token from sendVerificationEmail, mark the email as verified,\r\n// and log them in.\r\nMeteor.methods({verifyEmail: function (token) {\r\n  var self = this;\r\n  return Accounts._loginMethod(\r\n    self,\r\n    \"verifyEmail\",\r\n    arguments,\r\n    \"password\",\r\n    function () {\r\n      check(token, String);\r\n\r\n      var user = Meteor.users.findOne(\r\n        {'services.email.verificationTokens.token': token});\r\n      if (!user)\r\n        throw new Meteor.Error(403, \"Verify email link expired\");\r\n\r\n      var tokenRecord = _.find(user.services.email.verificationTokens,\r\n                               function (t) {\r\n                                 return t.token == token;\r\n                               });\r\n      if (!tokenRecord)\r\n        return {\r\n          userId: user._id,\r\n          error: new Meteor.Error(403, \"Verify email link expired\")\r\n        };\r\n\r\n      var emailsRecord = _.find(user.emails, function (e) {\r\n        return e.address == tokenRecord.address;\r\n      });\r\n      if (!emailsRecord)\r\n        return {\r\n          userId: user._id,\r\n          error: new Meteor.Error(403, \"Verify email link is for unknown address\")\r\n        };\r\n\r\n      // By including the address in the query, we can use 'emails.$' in the\r\n      // modifier to get a reference to the specific object in the emails\r\n      // array. See\r\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\r\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\r\n      Meteor.users.update(\r\n        {_id: user._id,\r\n         'emails.address': tokenRecord.address},\r\n        {$set: {'emails.$.verified': true},\r\n         $pull: {'services.email.verificationTokens': {token: token}}});\r\n\r\n      return {userId: user._id};\r\n    }\r\n  );\r\n}});\r\n\r\n\r\n\r\n///\r\n/// CREATING USERS\r\n///\r\n\r\n// Shared createUser function called from the createUser method, both\r\n// if originates in client or server code. Calls user provided hooks,\r\n// does the actual user insertion.\r\n//\r\n// returns the user id\r\nvar createUser = function (options) {\r\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary\r\n  // options.\r\n  check(options, Match.ObjectIncluding({\r\n    username: Match.Optional(String),\r\n    email: Match.Optional(String),\r\n    password: Match.Optional(String),\r\n    srp: Match.Optional(SRP.matchVerifier)\r\n  }));\r\n\r\n  var username = options.username;\r\n  var email = options.email;\r\n  if (!username && !email)\r\n    throw new Meteor.Error(400, \"Need to set a username or email\");\r\n\r\n  // Raw password. The meteor client doesn't send this, but a DDP\r\n  // client that didn't implement SRP could send this. This should\r\n  // only be done over SSL.\r\n  if (options.password) {\r\n    if (options.srp)\r\n      throw new Meteor.Error(400, \"Don't pass both password and srp in options\");\r\n    options.srp = SRP.generateVerifier(options.password);\r\n  }\r\n\r\n  var user = {services: {}};\r\n  if (options.srp)\r\n    user.services.password = {srp: options.srp}; // XXX validate verifier\r\n  if (username)\r\n    user.username = username;\r\n  if (email)\r\n    user.emails = [{address: email, verified: false}];\r\n\r\n  return Accounts.insertUserDoc(options, user);\r\n};\r\n\r\n// method for create user. Requests come from the client.\r\nMeteor.methods({createUser: function (options) {\r\n  var self = this;\r\n  return Accounts._loginMethod(\r\n    self,\r\n    \"createUser\",\r\n    arguments,\r\n    \"password\",\r\n    function () {\r\n      // createUser() above does more checking.\r\n      check(options, Object);\r\n      if (Accounts._options.forbidClientAccountCreation)\r\n        return {\r\n          error: new Meteor.Error(403, \"Signups forbidden\")\r\n        };\r\n\r\n      // Create user. result contains id and token.\r\n      var userId = createUser(options);\r\n      // safety belt. createUser is supposed to throw on error. send 500 error\r\n      // instead of sending a verification email with empty userid.\r\n      if (! userId)\r\n        throw new Error(\"createUser failed to insert new user\");\r\n\r\n      // If `Accounts._options.sendVerificationEmail` is set, register\r\n      // a token to verify the user's primary email, and send it to\r\n      // that address.\r\n      if (options.email && Accounts._options.sendVerificationEmail)\r\n        Accounts.sendVerificationEmail(userId, options.email);\r\n\r\n      // client gets logged in as the new user afterwards.\r\n      return {userId: userId};\r\n    }\r\n  );\r\n}});\r\n\r\n// Create user directly on the server.\r\n//\r\n// Unlike the client version, this does not log you in as this user\r\n// after creation.\r\n//\r\n// returns userId or throws an error if it can't create\r\n//\r\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\r\n// which is always empty when called from the createUser method? eg, \"admin:\r\n// true\", which we want to prevent the client from setting, but which a custom\r\n// method calling Accounts.createUser could set?\r\n//\r\nAccounts.createUser = function (options, callback) {\r\n  options = _.clone(options);\r\n\r\n  // XXX allow an optional callback?\r\n  if (callback) {\r\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\r\n  }\r\n\r\n  return createUser(options);\r\n};\r\n\r\n///\r\n/// PASSWORD-SPECIFIC INDEXES ON USERS\r\n///\r\nMeteor.users._ensureIndex('emails.validationTokens.token',\r\n                          {unique: 1, sparse: 1});\r\nMeteor.users._ensureIndex('services.password.reset.token',\r\n                          {unique: 1, sparse: 1});\r\n"]}