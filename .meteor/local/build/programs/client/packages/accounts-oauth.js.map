)]}'
{"version":3,"file":"\\packages\\accounts-oauth.js","sources":["accounts-oauth/oauth_common.js","accounts-oauth/oauth_client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,oB;;AAEA,kB;;AAEA,wD;AACA,uD;AACA,kD;AACA,4B;AACA,kD;AACA,wB;;AAEA,sB;AACA,+E;AACA,gF;AACA,gF;AACA,wB;AACA,yD;AACA,sD;AACA,G;AACA,E;;AAEA,2C;AACA,0B;AACA,E;;;;;;;;;;;;;;;;;;;ACvBA,mE;AACA,6D;AACA,yB;AACA,+E;AACA,kF;AACA,4B;AACA,+B;AACA,uC;AACA,wC;AACA,Q;AACA,8C;AACA,6E;AACA,+C;AACA,+C;AACA,oE;AACA,+D;AACA,c;AACA,sB;AACA,O;AACA,Q;AACA,E;;AAEA,sE;AACA,4C;AACA,2E;AACA,mD;AACA,Y;AACA,gF;AACA,K;AACA,I;AACA,E","sourcesContent":["Accounts.oauth = {};\r\n\r\nvar services = {};\r\n\r\n// Helper for registering OAuth based accounts packages.\r\n// On the server, adds an index to the user collection.\r\nAccounts.oauth.registerService = function (name) {\r\n  if (_.has(services, name))\r\n    throw new Error(\"Duplicate service: \" + name);\r\n  services[name] = true;\r\n\r\n  if (Meteor.server) {\r\n    // Accounts.updateOrCreateUserFromExternalService does a lookup by this id,\r\n    // so this should be a unique index. You might want to add indexes for other\r\n    // fields returned by your service (eg services.github.login) but you can do\r\n    // that in your app.\r\n    Meteor.users._ensureIndex('services.' + name + '.id',\r\n                              {unique: 1, sparse: 1});\r\n  }\r\n};\r\n\r\nAccounts.oauth.serviceNames = function () {\r\n  return _.keys(services);\r\n};\r\n","// Send an OAuth login method to the server. If the user authorized\r\n// access in the popup this should log the user in, otherwise\r\n// nothing should happen.\r\nAccounts.oauth.tryLoginAfterPopupClosed = function(credentialToken, callback) {\r\n  var credentialSecret = OAuth._retrieveCredentialSecret(credentialToken) || null;\r\n  Accounts.callLoginMethod({\r\n    methodArguments: [{oauth: {\r\n      credentialToken: credentialToken,\r\n      credentialSecret: credentialSecret\r\n    }}],\r\n    userCallback: callback && function (err) {\r\n      // Allow server to specify a specify subclass of errors. We should come\r\n      // up with a more generic way to do this!\r\n      if (err && err instanceof Meteor.Error &&\r\n          err.error === Accounts.LoginCancelledError.numericError) {\r\n        callback(new Accounts.LoginCancelledError(err.reason));\r\n      } else {\r\n        callback(err);\r\n      }\r\n    }});\r\n};\r\n\r\nAccounts.oauth.credentialRequestCompleteHandler = function(callback) {\r\n  return function (credentialTokenOrError) {\r\n    if(credentialTokenOrError && credentialTokenOrError instanceof Error) {\r\n      callback && callback(credentialTokenOrError);\r\n    } else {\r\n      Accounts.oauth.tryLoginAfterPopupClosed(credentialTokenOrError, callback);\r\n    }\r\n  };\r\n};\r\n"]}