)]}'
{"version":3,"file":"\\packages\\http.js","sources":["http/httpcall_common.js","http/httpcall_client.js","http/deprecated.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mD;AACA,+E;;AAEA,wC;AACA,oE;AACA,I;;AAEA,8C;AACA,c;AACA,uE;;AAEA,4B;AACA,E;;AAEA,iC;AACA,e;AACA,uC;AACA,mB;AACA,oB;AACA,0D;AACA,K;AACA,2C;AACA,E;;AAEA,8B;AACA,kF;AACA,E;;AAEA,sE;AACA,uC;AACA,sD;;AAEA,oC;AACA,8B;;AAEA,mB;AACA,wB;AACA,wC;AACA,sB;AACA,mB;AACA,kB;AACA,G;;AAEA,8B;AACA,qB;AACA,uB;;AAEA,a;AACA,E;;AAEA,uD;AACA,mC;AACA,2D;AACA,gE;AACA,gC;AACA,4E;;AAEA,wE;AACA,wE;AACA,S;AACA,mD;AACA,mB;AACA,2B;AACA,K;AACA,U;AACA,yB;AACA,G;AACA,E;;AAEA,U;;AAEA,qC;AACA,qE;AACA,E;;AAEA,sC;AACA,sE;AACA,E;;AAEA,qC;AACA,qE;AACA,E;;AAEA,qC;AACA,wE;AACA,E;;;;;;;;;;;;;;;;;;;ACrFA,sD;;AAEA,yC;;AAEA,oD;AACA,oD;AACA,uB;AACA,mB;AACA,G;;AAEA,0B;;AAEA,qC;AACA,oB;AACA,6E;;AAEA,wC;;AAEA,mB;;AAEA,gC;AACA,qB;AACA,2C;AACA,iD;AACA,G;;AAEA,sC;AACA,uD;AACA,oC;AACA,M;AACA,qC;;AAEA,+C;AACA,gD;AACA,gD;;AAEA,wC;AACA,6E;;AAEA,yB;AACA,qB;AACA,6C;AACA,qB;AACA,+E;AACA,mD;AACA,kD;AACA,G;;AAEA,wB;AACA,4C;AACA,G;;AAEA,2C;;AAEA,yC;;AAEA,oE;AACA,oE;AACA,kC;AACA,sC;AACA,4B;AACA,kC;AACA,gC;AACA,M;AACA,e;;AAEA,8C;AACA,8B;;;AAGA,gC;;AAEA,oE;AACA,qE;AACA,a;AACA,O;AACA,uB;AACA,Y;AACA,8C;AACA,iC;AACA,kD;AACA,0D;AACA,Q;AACA,4D;;AAEA,oD;;AAEA,0B;AACA,0C;;;AAGA,oB;AACA,0B;AACA,c;AACA,0B;AACA,4C;AACA,yB;AACA,oB;AACA,0B;AACA,M;;AAEA,2B;AACA,4C;AACA,6C;AACA,kB;AACA,qC;;AAEA,wB;AACA,yC;AACA,kC;AACA,6B;AACA,yC;AACA,gB;;AAEA,4B;AACA,2C;AACA,8C;;AAEA,gC;AACA,uD;;AAEA,wD;AACA,Y;AACA,yD;AACA,gE;AACA,qE;AACA,mB;AACA,gE;AACA,Y;AACA,qE;AACA,mE;AACA,sE;AACA,sE;AACA,wC;AACA,yE;AACA,wB;AACA,qE;;AAEA,sD;AACA,4C;AACA,kD;AACA,oC;AACA,0D;AACA,a;;AAEA,iC;;AAEA,2B;AACA,yC;AACA,6E;;AAEA,oC;AACA,S;AACA,O;AACA,M;;AAEA,yB;AACA,sB;;AAEA,iB;AACA,kB;AACA,G;;AAEA,E;;;;;;;;;;;;;;;;;;;ACnKA,iD;AACA,wB;AACA,mB","sourcesContent":["makeErrorByStatus = function(statusCode, content) {\r\n  var MAX_LENGTH = 500; // if you change this, also change the appropriate test\r\n\r\n  var truncate = function(str, length) {\r\n    return str.length > length ? str.slice(0, length) + '...' : str;\r\n  };\r\n\r\n  var message = \"failed [\" + statusCode + \"]\";\r\n  if (content)\r\n    message += \" \" + truncate(content.replace(/\\n/g, \" \"), MAX_LENGTH);\r\n\r\n  return new Error(message);\r\n};\r\n\r\nencodeParams = function(params) {\r\n  var buf = [];\r\n  _.each(params, function(value, key) {\r\n    if (buf.length)\r\n      buf.push('&');\r\n    buf.push(encodeString(key), '=', encodeString(value));\r\n  });\r\n  return buf.join('').replace(/%20/g, '+');\r\n};\r\n\r\nencodeString = function(str) {\r\n  return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\r\n};\r\n\r\nbuildUrl = function(before_qmark, from_qmark, opt_query, opt_params) {\r\n  var url_without_query = before_qmark;\r\n  var query = from_qmark ? from_qmark.slice(1) : null;\r\n\r\n  if (typeof opt_query === \"string\")\r\n    query = String(opt_query);\r\n\r\n  if (opt_params) {\r\n    query = query || \"\";\r\n    var prms = encodeParams(opt_params);\r\n    if (query && prms)\r\n      query += '&';\r\n    query += prms;\r\n  }\r\n\r\n  var url = url_without_query;\r\n  if (query !== null)\r\n    url += (\"?\"+query);\r\n\r\n  return url;\r\n};\r\n\r\n// Fill in `response.data` if the content-type is JSON.\r\npopulateData = function(response) {\r\n  // Read Content-Type header, up to a ';' if there is one.\r\n  // A typical header might be \"application/json; charset=utf-8\"\r\n  // or just \"application/json\".\r\n  var contentType = (response.headers['content-type'] || ';').split(';')[0];\r\n\r\n  // Only try to parse data as JSON if server sets correct content type.\r\n  if (_.include(['application/json', 'text/javascript'], contentType)) {\r\n    try {\r\n      response.data = JSON.parse(response.content);\r\n    } catch (err) {\r\n      response.data = null;\r\n    }\r\n  } else {\r\n    response.data = null;\r\n  }\r\n};\r\n\r\nHTTP = {};\r\n\r\nHTTP.get = function (/* varargs */) {\r\n  return HTTP.call.apply(this, [\"GET\"].concat(_.toArray(arguments)));\r\n};\r\n\r\nHTTP.post = function (/* varargs */) {\r\n  return HTTP.call.apply(this, [\"POST\"].concat(_.toArray(arguments)));\r\n};\r\n\r\nHTTP.put = function (/* varargs */) {\r\n  return HTTP.call.apply(this, [\"PUT\"].concat(_.toArray(arguments)));\r\n};\r\n\r\nHTTP.del = function (/* varargs */) {\r\n  return HTTP.call.apply(this, [\"DELETE\"].concat(_.toArray(arguments)));\r\n};\r\n","HTTP.call = function(method, url, options, callback) {\r\n\r\n  ////////// Process arguments //////////\r\n\r\n  if (! callback && typeof options === \"function\") {\r\n    // support (method, url, callback) argument list\r\n    callback = options;\r\n    options = null;\r\n  }\r\n\r\n  options = options || {};\r\n\r\n  if (typeof callback !== \"function\")\r\n    throw new Error(\r\n      \"Can't make a blocking HTTP call from the client; callback required.\");\r\n\r\n  method = (method || \"\").toUpperCase();\r\n\r\n  var headers = {};\r\n\r\n  var content = options.content;\r\n  if (options.data) {\r\n    content = JSON.stringify(options.data);\r\n    headers['Content-Type'] = 'application/json';\r\n  }\r\n\r\n  var params_for_url, params_for_body;\r\n  if (content || method === \"GET\" || method === \"HEAD\")\r\n    params_for_url = options.params;\r\n  else\r\n    params_for_body = options.params;\r\n\r\n  var query_match = /^(.*?)(\\?.*)?$/.exec(url);\r\n  url = buildUrl(query_match[1], query_match[2],\r\n                 options.query, params_for_url);\r\n\r\n  if (options.followRedirects === false)\r\n    throw new Error(\"Option followRedirects:false not supported on client.\");\r\n\r\n  var username, password;\r\n  if (options.auth) {\r\n    var colonLoc = options.auth.indexOf(':');\r\n    if (colonLoc < 0)\r\n      throw new Error('auth option should be of the form \"username:password\"');\r\n    username = options.auth.substring(0, colonLoc);\r\n    password = options.auth.substring(colonLoc+1);\r\n  }\r\n\r\n  if (params_for_body) {\r\n    content = encodeParams(params_for_body);\r\n  }\r\n\r\n  _.extend(headers, options.headers || {});\r\n\r\n  ////////// Callback wrapping //////////\r\n\r\n  // wrap callback to add a 'response' property on an error, in case\r\n  // we have both (http 4xx/5xx error, which has a response payload)\r\n  callback = (function(callback) {\r\n    return function(error, response) {\r\n      if (error && response)\r\n        error.response = response;\r\n      callback(error, response);\r\n    };\r\n  })(callback);\r\n\r\n  // safety belt: only call the callback once.\r\n  callback = _.once(callback);\r\n\r\n\r\n  ////////// Kickoff! //////////\r\n\r\n  // from this point on, errors are because of something remote, not\r\n  // something we should check in advance. Turn exceptions into error\r\n  // results.\r\n  try {\r\n    // setup XHR object\r\n    var xhr;\r\n    if (typeof XMLHttpRequest !== \"undefined\")\r\n      xhr = new XMLHttpRequest();\r\n    else if (typeof ActiveXObject !== \"undefined\")\r\n      xhr = new ActiveXObject(\"Microsoft.XMLHttp\"); // IE6\r\n    else\r\n      throw new Error(\"Can't create XMLHttpRequest\"); // ???\r\n\r\n    xhr.open(method, url, true, username, password);\r\n\r\n    for (var k in headers)\r\n      xhr.setRequestHeader(k, headers[k]);\r\n\r\n\r\n    // setup timeout\r\n    var timed_out = false;\r\n    var timer;\r\n    if (options.timeout) {\r\n      timer = Meteor.setTimeout(function() {\r\n        timed_out = true;\r\n        xhr.abort();\r\n      }, options.timeout);\r\n    };\r\n\r\n    // callback on complete\r\n    xhr.onreadystatechange = function(evt) {\r\n      if (xhr.readyState === 4) { // COMPLETE\r\n        if (timer)\r\n          Meteor.clearTimeout(timer);\r\n\r\n        if (timed_out) {\r\n          callback(new Error(\"timeout\"));\r\n        } else if (! xhr.status) {\r\n          // no HTTP response\r\n          callback(new Error(\"network\"));\r\n        } else {\r\n\r\n          var response = {};\r\n          response.statusCode = xhr.status;\r\n          response.content = xhr.responseText;\r\n\r\n          response.headers = {};\r\n          var header_str = xhr.getAllResponseHeaders();\r\n\r\n          // https://github.com/meteor/meteor/issues/553\r\n          //\r\n          // In Firefox there is a weird issue, sometimes\r\n          // getAllResponseHeaders returns the empty string, but\r\n          // getResponseHeader returns correct results. Possibly this\r\n          // issue:\r\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=608735\r\n          //\r\n          // If this happens we can't get a full list of headers, but\r\n          // at least get content-type so our JSON decoding happens\r\n          // correctly. In theory, we could try and rescue more header\r\n          // values with a list of common headers, but content-type is\r\n          // the only vital one for now.\r\n          if (\"\" === header_str && xhr.getResponseHeader(\"content-type\"))\r\n            header_str =\r\n            \"content-type: \" + xhr.getResponseHeader(\"content-type\");\r\n\r\n          var headers_raw = header_str.split(/\\r?\\n/);\r\n          _.each(headers_raw, function (h) {\r\n            var m = /^(.*?):(?:\\s+)(.*)$/.exec(h);\r\n            if (m && m.length === 3)\r\n              response.headers[m[1].toLowerCase()] = m[2];\r\n          });\r\n\r\n          populateData(response);\r\n\r\n          var error = null;\r\n          if (response.statusCode >= 400)\r\n            error = makeErrorByStatus(response.statusCode, response.content);\r\n\r\n          callback(error, response);\r\n        }\r\n      }\r\n    };\r\n\r\n    // send it on its way\r\n    xhr.send(content);\r\n\r\n  } catch (err) {\r\n    callback(err);\r\n  }\r\n\r\n};\r\n","// The HTTP object used to be called Meteor.http.\r\n// XXX COMPAT WITH 0.6.4\r\nMeteor.http = HTTP;\r\n"]}