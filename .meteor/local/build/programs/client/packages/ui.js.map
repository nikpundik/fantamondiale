)]}'
{"version":3,"file":"\\packages\\ui.js","sources":["ui/exceptions.js","ui/base.js","ui/dombackend.js","ui/domrange.js","ui/attrs.js","ui/render.js","ui/builtins.js","ui/each.js","ui/fields.js","ui/handlebars_backcompat.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,c;;AAEA,mF;AACA,8E;AACA,4E;AACA,sB;AACA,E;AACA,S;AACA,E;AACA,M;AACA,Q;AACA,yB;AACA,gB;AACA,0B;AACA,I;AACA,M;AACA,E;AACA,6D;;AAEA,uC;AACA,kB;AACA,wB;AACA,6B;AACA,6D;AACA,8E;AACA,gC;AACA,M;;AAEA,4E;AACA,gF;AACA,gE;AACA,sE;AACA,E;;;;;;;;;;;;;;;;;;;ACjCA,Q;;AAEA,2D;AACA,2D;AACA,iB;AACA,+B;AACA,oB;AACA,8B;AACA,sB;AACA,a;AACA,E;;AAEA,sD;AACA,Y;AACA,6C;AACA,iD;AACA,6C;AACA,mB;AACA,kD;AACA,O;AACA,qD;AACA,e;AACA,a;AACA,sB;AACA,G;AACA,a;AACA,E;;AAEA,6D;AACA,iE;AACA,mE;AACA,qE;AACA,mD;AACA,c;;AAEA,4D;AACA,2D;AACA,8D;AACA,4D;AACA,iB;AACA,I;AACA,6D;AACA,8D;AACA,6D;AACA,4D;AACA,6B;AACA,qC;;AAEA,wD;AACA,4C;AACA,yD;AACA,uD;AACA,0D;AACA,sD;AACA,wD;AACA,gD;AACA,uB;AACA,yC;AACA,sC;AACA,a;AACA,8B;AACA,K;;AAEA,a;AACA,iC;;AAEA,+B;AACA,iD;AACA,I;AACA,yD;AACA,+C;AACA,gC;AACA,6B;AACA,e;AACA,kB;AACA,oB;AACA,mB;AACA,K;AACA,iB;AACA,I;AACA,uD;AACA,sD;AACA,iB;AACA,sC;AACA,sB;AACA,oF;AACA,I;AACA,gC;AACA,qB;AACA,4E;AACA,I;AACA,6B;AACA,gB;AACA,oF;AACA,G;AACA,G;;AAEA,yB;;AAEA,uB;AACA,oB;AACA,Y;AACA,Y;AACA,yC;AACA,kB;AACA,+D;AACA,sB;AACA,qB;AACA,0D;AACA,iC;AACA,yC;AACA,e;;AAEA,yD;AACA,+C;AACA,4B;AACA,qD;AACA,2D;AACA,2B;;AAEA,sB;AACA,qD;AACA,0D;AACA,sD;AACA,wB;AACA,0D;;AAEA,e;AACA,2B;AACA,8B;AACA,8D;AACA,iE;AACA,kE;AACA,6D;AACA,8B;AACA,8B;AACA,wB;AACA,Y;AACA,4B;AACA,K;;AAEA,yD;AACA,0D;AACA,uD;AACA,qD;AACA,4B;;AAEA,uB;AACA,mB;AACA,yB;;AAEA,c;AACA,wB;;AAEA,wD;AACA,sC;AACA,sC;AACA,mC;;AAEA,a;AACA,G;AACA,G;;AAEA,yD;AACA,wC;AACA,wD;AACA,0D;AACA,0D;AACA,sD;AACA,uC;AACA,oB;AACA,+D;AACA,E;AACA,sC;AACA,wC;AACA,I;;;AAGA,wE;AACA,sE;AACA,kB;AACA,qE;AACA,2C;AACA,2D;AACA,c;AACA,a;AACA,kC;AACA,yC;AACA,mD;AACA,U;AACA,8E;AACA,kF;AACA,sC;AACA,uC;AACA,e;AACA,oD;AACA,G;AACA,E;;AAEA,6C;AACA,gB;AACA,wC;AACA,kB;AACA,uB;AACA,G;AACA,c;AACA,E;;AAEA,+C;AACA,gB;AACA,4B;AACA,0C;AACA,oB;AACA,U;AACA,oB;AACA,K;AACA,uB;AACA,G;AACA,c;AACA,E;;AAEA,oC;AACA,6C;AACA,gB;AACA,4C;AACA,qC;AACA,gB;AACA,E;;AAEA,0C;AACA,+D;AACA,e;AACA,mC;AACA,qC;;AAEA,sC;AACA,sD;AACA,uD;AACA,0D;AACA,yD;AACA,gC;AACA,sE;AACA,qC;AACA,U;AACA,qE;AACA,0B;AACA,yB;AACA,G;AACA,E;;AAEA,uB;AACA,iE;AACA,0B;AACA,4B;AACA,wB;AACA,I;AACA,2B;AACA,e;AACA,uC;AACA,4B;AACA,Q;AACA,mC;;AAEA,2C;AACA,uC;AACA,wE;AACA,yC;AACA,wC;AACA,+B;AACA,iB;;AAEA,sC;AACA,uC;AACA,uC;AACA,wC;AACA,wC;AACA,S;AACA,O;AACA,G;AACA,G;;AAEA,+D;AACA,uD;AACA,2C;AACA,kB;AACA,mD;AACA,0E;AACA,sD;AACA,0C;AACA,kE;AACA,mE;AACA,kE;AACA,gE;AACA,qE;AACA,iD;AACA,kD;AACA,4B;AACA,K;AACA,kE;AACA,iE;AACA,+D;AACA,2B;AACA,6C;AACA,2E;AACA,kD;AACA,wC;AACA,qC;AACA,6C;AACA,6D;AACA,mD;AACA,wE;AACA,gE;AACA,4C;AACA,mE;AACA,sE;AACA,kD;AACA,oE;AACA,W;AACA,Q;;AAEA,4D;AACA,O;AACA,G;;AAEA,sB;AACA,gD;AACA,iC;AACA,+B;AACA,qC;AACA,kD;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,c;AACA,qC;AACA,yF;AACA,E;;AAEA,mE;AACA,gB;AACA,mC;AACA,oD;AACA,wC;AACA,E;;AAEA,0B;AACA,uC;AACA,uB;AACA,E;AACA,yC;AACA,uB;AACA,E;;;;;;;;;;;;;;;;;;;ACjWA,sB;;AAEA,0D;AACA,oD;AACA,sE;;AAEA,uB;AACA,mE;;AAEA,kC;;AAEA,sB;AACA,6B;;AAEA,+C;;AAEA,+C;AACA,qD;AACA,I;AACA,6D;AACA,qD;AACA,6D;AACA,U;;AAEA,sE;AACA,uE;AACA,4B;;AAEA,0E;AACA,wE;AACA,kE;AACA,sC;AACA,I;AACA,8E;AACA,wD;AACA,8C;AACA,uB;AACA,I;;AAEA,yE;AACA,0E;AACA,8E;AACA,gC;AACA,sD;AACA,kD;AACA,iD;;AAEA,+C;AACA,4D;AACA,K;;AAEA,qD;AACA,I;;AAEA,0D;AACA,0B;AACA,sB;AACA,4D;AACA,sB;AACA,kD;AACA,6B;AACA,qD;AACA,O;AACA,K;AACA,I;;AAEA,0C;AACA,gC;AACA,M;AACA,2D;AACA,6D;AACA,2C;AACA,qC;AACA,I;;AAEA,iD;AACA,uD;AACA,iD;AACA,4D;AACA,kC;AACA,I;;AAEA,iD;AACA,iD;AACA,8C;AACA,qC;AACA,gB;AACA,I;;AAEA,qD;AACA,4D;AACA,qC;AACA,wE;AACA,0C;AACA,I;;AAEA,gE;AACA,iC;AACA,I;;AAEA,2E;AACA,0B;;AAEA,oC;AACA,mC;AACA,yC;;AAEA,uE;AACA,wE;AACA,yE;AACA,mE;AACA,2E;AACA,4B;AACA,6C;AACA,2C;AACA,kC;AACA,M;;AAEA,wC;;AAEA,qC;AACA,qC;AACA,+C;AACA,I;;AAEA,mE;AACA,qC;AACA,oE;AACA,I;;AAEA,+C;AACA,2B;AACA,mC;AACA,oB;AACA,mC;AACA,gB;AACA,I;;AAEA,C;;;;;;;;;;;;;;;;;;AC1IA,O;AACA,2B;AACA,4B;AACA,8D;AACA,6B;;AAEA,+B;;AAEA,+B;AACA,2B;AACA,qE;AACA,6C;AACA,Q;AACA,gC;AACA,E;;AAEA,6C;AACA,2B;AACA,yD;AACA,qD;AACA,Q;AACA,kE;AACA,uC;AACA,E;;AAEA,2C;AACA,2B;AACA,uD;AACA,mD;AACA,Q;AACA,kE;AACA,yC;AACA,E;;AAEA,2D;AACA,2D;AACA,iB;AACA,mC;AACA,oB;AACA,8B;AACA,sB;AACA,a;AACA,E;;AAEA,uC;AACA,a;AACA,iB;AACA,8C;AACA,yB;AACA,kB;AACA,e;AACA,E;;AAEA,4B;AACA,6C;AACA,kC;AACA,E;;AAEA,2C;AACA,6B;AACA,sC;AACA,+B;AACA,6B;AACA,yC;AACA,E;;AAEA,6B;AACA,6B;AACA,2C;AACA,W;AACA,2C;AACA,E;;AAEA,0C;AACA,uC;AACA,O;AACA,uB;AACA,gB;AACA,e;AACA,W;AACA,iB;AACA,G;AACA,K;;AAEA,wB;AACA,yB;AACA,yD;AACA,wD;;AAEA,sC;AACA,2B;AACA,4B;;AAEA,wB;AACA,kD;AACA,kD;AACA,gD;AACA,qD;AACA,gD;AACA,0C;AACA,uB;AACA,gC;AACA,wC;AACA,wC;AACA,mC;;AAEA,wD;AACA,0D;AACA,4B;AACA,S;AACA,K;;AAEA,0D;AACA,uC;;AAEA,+B;AACA,gC;AACA,4B;AACA,2B;AACA,kC;AACA,2B;AACA,K;AACA,G;AACA,E;;AAEA,qC;AACA,0B;AACA,2B;;AAEA,yB;AACA,8C;;AAEA,wC;;AAEA,kC;AACA,sB;AACA,sB;;AAEA,0B;AACA,G;AACA,E;;AAEA,+C;AACA,uC;AACA,6C;AACA,iD;AACA,6B;;AAEA,qB;AACA,qC;AACA,G;AACA,E;;AAEA,uC;AACA,8B;AACA,0B;AACA,yB;AACA,gC;AACA,wB;AACA,Q;AACA,uB;AACA,G;AACA,E;;AAEA,iB;;AAEA,4B;AACA,iC;AACA,+B;AACA,sD;AACA,kC;;AAEA,qB;AACA,iB;AACA,mB;AACA,iB;;AAEA,oB;AACA,wB;AACA,oB;AACA,6B;AACA,yB;;AAEA,0B;AACA,yB;AACA,E;;AAEA,6B;AACA,yB;AACA,4B;AACA,gB;;AAEA,mB;;AAEA,yC;AACA,mB;AACA,4B;AACA,8B;AACA,2B;AACA,oB;AACA,iB;AACA,I;AACA,0B;AACA,4B;AACA,a;;AAEA,mB;;AAEA,0B;AACA,6B;AACA,mB;AACA,wC;AACA,8B;AACA,6B;AACA,0D;AACA,oB;AACA,K;AACA,iD;AACA,2B;;AAEA,yB;;AAEA,sB;AACA,I;AACA,4B;AACA,6D;AACA,+C;AACA,iC;AACA,wD;AACA,2D;AACA,mB;AACA,+C;AACA,kC;AACA,4B;AACA,gB;AACA,K;;AAEA,mE;AACA,4D;;AAEA,oC;AACA,0C;AACA,+C;AACA,c;AACA,uB;AACA,mF;AACA,qC;AACA,kE;AACA,qD;AACA,8C;AACA,wD;AACA,e;AACA,O;AACA,K;;AAEA,uC;AACA,qD;AACA,kC;AACA,qB;AACA,a;AACA,uD;AACA,2C;AACA,gC;AACA,sD;;AAEA,qC;AACA,qB;AACA,+B;AACA,Y;AACA,kB;AACA,oB;AACA,K;;AAEA,+B;AACA,qC;AACA,kC;AACA,0C;AACA,sC;AACA,iC;AACA,uD;AACA,6B;AACA,gC;AACA,iC;AACA,gB;AACA,mE;AACA,S;AACA,c;AACA,qC;AACA,gC;AACA,gD;AACA,+B;AACA,6B;AACA,gB;AACA,mE;AACA,S;AACA,O;AACA,K;;AAEA,wC;AACA,c;AACA,4B;AACA,yB;AACA,mC;;AAEA,8B;AACA,4C;AACA,mD;;AAEA,0B;AACA,6B;AACA,Y;AACA,a;AACA,iD;AACA,sD;AACA,2B;AACA,qD;AACA,qC;AACA,8B;AACA,wB;;AAEA,8B;AACA,6C;AACA,K;AACA,I;AACA,yB;AACA,qB;AACA,oB;AACA,uB;AACA,6B;AACA,2B;AACA,wB;AACA,yB;AACA,a;AACA,K;;AAEA,gB;AACA,kB;AACA,+B;AACA,+C;AACA,+B;AACA,uB;;AAEA,gC;AACA,iB;AACA,a;;AAEA,uC;AACA,qD;AACA,kC;AACA,qB;AACA,a;;AAEA,qC;AACA,c;AACA,yB;AACA,yB;AACA,oD;AACA,0C;AACA,gD;AACA,wB;AACA,Y;AACA,a;AACA,wB;AACA,qD;AACA,yC;AACA,yB;AACA,K;AACA,I;AACA,uC;AACA,oD;AACA,gB;AACA,kB;AACA,+B;AACA,gB;AACA,wC;AACA,wB;AACA,0C;AACA,iB;AACA,a;;AAEA,uC;AACA,qD;AACA,kC;AACA,qB;AACA,a;;AAEA,qC;AACA,c;AACA,yB;AACA,4D;AACA,kC;AACA,kD;AACA,wB;AACA,qC;AACA,8C;AACA,mD;AACA,O;AACA,Y;AACA,a;AACA,wB;AACA,2C;AACA,K;AACA,I;AACA,sB;AACA,gB;AACA,kB;AACA,+B;AACA,mC;AACA,yB;AACA,gB;AACA,I;AACA,2B;AACA,iC;AACA,I;AACA,0B;AACA,sB;AACA,I;AACA,wB;AACA,oB;AACA,I;AACA,8C;AACA,+B;AACA,uC;AACA,4B;AACA,uD;AACA,2B;AACA,oC;AACA,gB;AACA,wB;AACA,oD;AACA,uD;AACA,gB;AACA,6B;AACA,oC;AACA,8B;AACA,S;AACA,c;AACA,e;AACA,uB;AACA,6C;AACA,oD;AACA,gB;AACA,oC;AACA,4B;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,uD;;AAEA,iD;AACA,oD;AACA,mD;AACA,qD;AACA,oD;AACA,a;AACA,I;AACA,yD;AACA,0D;AACA,0D;AACA,uD;AACA,yD;AACA,qD;AACA,6C;AACA,I;AACA,8C;AACA,mD;AACA,+C;AACA,gD;AACA,oD;AACA,qD;AACA,oD;AACA,sD;AACA,iD;AACA,sD;AACA,qD;AACA,I;AACA,uD;AACA,uD;AACA,qD;AACA,iD;AACA,sD;AACA,0C;AACA,wB;;AAEA,uC;AACA,qB;AACA,a;;AAEA,6C;AACA,kC;AACA,0B;AACA,0C;AACA,kD;AACA,mD;AACA,mD;AACA,sB;AACA,wB;AACA,yB;AACA,uB;AACA,yB;AACA,qC;AACA,sB;AACA,mB;AACA,gC;AACA,sC;AACA,6B;AACA,O;AACA,yB;AACA,sB;AACA,wB;AACA,mB;AACA,O;;AAEA,yB;AACA,wB;;AAEA,2B;AACA,+B;AACA,kC;AACA,qB;AACA,6B;AACA,4B;AACA,6B;AACA,oC;AACA,iC;AACA,O;AACA,Y;AACA,+D;AACA,iE;AACA,gE;AACA,oD;AACA,Q;AACA,2D;AACA,uD;AACA,yD;AACA,wD;AACA,Q;AACA,8D;AACA,6D;AACA,iE;AACA,+D;AACA,4C;AACA,2C;;AAEA,sB;AACA,uB;AACA,qC;AACA,mC;AACA,oC;AACA,kC;AACA,yC;AACA,mC;AACA,yC;AACA,2C;AACA,yC;AACA,yD;AACA,kD;AACA,0B;AACA,qD;AACA,yD;AACA,sD;AACA,mD;AACA,8B;AACA,yC;AACA,oD;AACA,6D;AACA,6C;AACA,mC;AACA,6B;AACA,a;AACA,W;AACA,kC;AACA,mB;AACA,4C;AACA,4B;AACA,kB;AACA,oB;AACA,+C;AACA,kC;AACA,4C;AACA,gC;AACA,4B;AACA,W;AACA,S;AACA,O;AACA,K;AACA,oB;AACA,mD;AACA,kD;AACA,uB;AACA,iB;AACA,6C;AACA,sC;AACA,sC;AACA,sB;AACA,iB;AACA,wC;AACA,sC;AACA,sC;AACA,qB;AACA,sC;AACA,mC;AACA,8B;AACA,0C;AACA,gC;AACA,wC;AACA,uC;AACA,K;AACA,I;AACA,0C;AACA,+B;AACA,uC;;AAEA,qB;AACA,mD;AACA,mD;AACA,wD;AACA,mD;AACA,qD;AACA,6D;AACA,Q;AACA,gD;AACA,+C;AACA,kD;AACA,sB;AACA,K;;AAEA,sB;AACA,8B;AACA,gC;;AAEA,kC;AACA,c;AACA,sB;AACA,kD;AACA,sB;AACA,wB;AACA,2B;AACA,c;AACA,2B;AACA,4B;AACA,O;AACA,Y;AACA,a;AACA,qB;AACA,yC;AACA,mC;AACA,U;AACA,0B;AACA,K;;AAEA,wB;AACA,6B;AACA,uB;AACA,oB;AACA,G;AACA,G;;AAEA,oD;AACA,gC;AACA,mC;AACA,4B;AACA,2B;AACA,uB;AACA,8B;AACA,K;AACA,mB;AACA,E;;AAEA,sD;;AAEA,gD;AACA,+B;AACA,mD;AACA,8B;AACA,E;AACA,M;AACA,gB;AACA,U;AACA,gB;AACA,Y;AACA,M;AACA,E;AACA,iD;AACA,2D;AACA,uC;AACA,8C;;AAEA,+C;AACA,uB;AACA,E;;AAEA,6C;AACA,yB;AACA,kC;AACA,8B;AACA,qC;AACA,sB;AACA,gC;AACA,G;AACA,uB;AACA,E;;AAEA,kD;AACA,0D;AACA,+B;AACA,wC;AACA,+C;AACA,uB;AACA,E;;AAEA,sD;AACA,kC;AACA,iC;;AAEA,uC;;AAEA,iB;AACA,wB;AACA,6B;AACA,wB;AACA,G;AACA,c;AACA,E;;AAEA,sB;;AAEA,qD;AACA,mB;AACA,kD;;AAEA,qC;AACA,mB;AACA,iB;;AAEA,Y;AACA,uC;AACA,gB;AACA,uB;AACA,gC;AACA,a;AACA,mB;AACA,oD;AACA,kB;AACA,0B;AACA,+B;AACA,uB;AACA,yC;AACA,sD;AACA,e;AACA,U;AACA,W;AACA,0B;AACA,4C;AACA,mB;;AAEA,0C;AACA,6B;;AAEA,qB;AACA,G;;AAEA,mD;AACA,6B;;AAEA,iC;AACA,wB;;AAEA,wB;AACA,E;;AAEA,4C;AACA,kB;;AAEA,qC;AACA,mB;AACA,wD;;AAEA,0D;AACA,0D;AACA,8D;AACA,wD;AACA,2D;AACA,0D;AACA,4B;;AAEA,4D;AACA,4C;AACA,0D;AACA,iC;AACA,6D;;AAEA,gE;;AAEA,4D;AACA,6D;AACA,sD;AACA,e;;;AAGA,0D;AACA,yD;AACA,kB;AACA,oC;AACA,0D;AACA,wD;AACA,iC;AACA,kB;;AAEA,+B;AACA,I;;AAEA,yB;AACA,iD;AACA,0C;AACA,wB;AACA,8C;AACA,yB;AACA,wB;AACA,2B;AACA,K;AACA,yB;AACA,U;AACA,mE;AACA,yC;AACA,G;;AAEA,iB;AACA,E;;;AAGA,Y;;AAEA,oD;AACA,oD;AACA,qD;AACA,kB;AACA,E;AACA,mC;AACA,sD;AACA,kD;AACA,wB;AACA,qD;AACA,kC;AACA,E;;AAEA,uB;AACA,4B;AACA,6B;;AAEA,gE;AACA,mB;AACA,mB;AACA,2B;AACA,yB;AACA,iB;;AAEA,6B;;AAEA,wD;AACA,0D;AACA,0B;AACA,I;AACA,wD;AACA,8C;AACA,yC;AACA,2B;AACA,6D;AACA,gD;AACA,e;AACA,8C;AACA,e;AACA,+C;AACA,M;AACA,W;;AAEA,oD;AACA,iC;AACA,wD;AACA,qD;AACA,qD;AACA,sD;AACA,8C;;AAEA,6C;AACA,2C;AACA,4C;;AAEA,qB;AACA,2C;AACA,6B;AACA,wC;AACA,6C;AACA,4B;AACA,mD;AACA,gC;AACA,yC;AACA,2C;AACA,kD;AACA,mB;AACA,kB;AACA,iD;AACA,mD;AACA,mC;AACA,0C;AACA,wC;AACA,kD;AACA,W;AACA,S;;AAEA,gC;AACA,Q;AACA,a;;AAEA,U;AACA,oC;AACA,G;AACA,E;;AAEA,yC;AACA,sE;AACA,gE;AACA,4D;AACA,0C;AACA,iC;AACA,iD;AACA,6B;AACA,G;;AAEA,yC;AACA,8B;AACA,2B;AACA,mD;AACA,E;;AAEA,2C;AACA,wC;AACA,wD;AACA,0D;;AAEA,yC;AACA,qD;AACA,uD;AACA,E;;;AAGA,0D;AACA,+D;AACA,8D;AACA,qC;AACA,mB;AACA,8C;AACA,W;AACA,kC;AACA,iC;AACA,qE;;AAEA,sB;AACA,0C;AACA,uB;AACA,K;;AAEA,sD;AACA,yB;AACA,uB;AACA,oB;AACA,0B;AACA,0B;AACA,oB;AACA,G;;AAEA,sD;AACA,6B;;AAEA,0C;AACA,oB;AACA,+C;;AAEA,+B;AACA,iB;AACA,kC;AACA,yB;AACA,K;AACA,oC;AACA,oC;AACA,iD;AACA,sB;AACA,iC;AACA,+C;AACA,8C;AACA,mC;AACA,8C;AACA,yB;AACA,+B;AACA,0B;AACA,qB;AACA,mB;AACA,4D;AACA,8B;AACA,6C;AACA,gD;AACA,S;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,iE;AACA,yC;AACA,oC;AACA,mB;AACA,gB;AACA,mB;;AAEA,oC;AACA,iD;AACA,Y;AACA,qE;AACA,gF;AACA,sE;AACA,+C;AACA,uB;AACA,+C;AACA,qB;AACA,kB;AACA,oB;;AAEA,2B;AACA,K;AACA,I;;;AAGA,uB;;;;;;;;;;;;;;;;;;;;ACzgCA,gF;AACA,kE;AACA,uE;AACA,sB;AACA,E;AACA,gD;AACA,uE;AACA,4E;AACA,yE;AACA,uE;AACA,0E;AACA,yE;AACA,wE;AACA,sE;AACA,0E;AACA,+B;AACA,E;AACA,2E;AACA,kE;AACA,E;AACA,4E;AACA,0D;;AAEA,2C;AACA,mB;AACA,qB;AACA,E;;AAEA,yE;AACA,uB;AACA,0B;AACA,yC;AACA,U;AACA,2C;AACA,G;AACA,E;;AAEA,8C;AACA,qB;AACA,iE;AACA,4C;AACA,I;AACA,kC;AACA,kC;AACA,c;AACA,yC;AACA,iB;AACA,E;;AAEA,0D;AACA,gD;AACA,+C;AACA,gD;AACA,2E;;AAEA,oE;AACA,8D;;AAEA,gE;AACA,sE;;AAEA,qE;AACA,iD;AACA,4B;AACA,sC;AACA,wC;AACA,K;AACA,iD;AACA,4B;AACA,0C;AACA,qC;AACA,wB;AACA,K;;AAEA,8C;AACA,G;AACA,G;;AAEA,4C;AACA,6B;AACA,uC;AACA,6B;AACA,I;AACA,2C;AACA,kC;AACA,G;AACA,G;;AAEA,+C;AACA,uC;AACA,qC;AACA,I;AACA,2C;AACA,6C;AACA,G;AACA,G;;AAEA,8C;AACA,+C;AACA,wC;;AAEA,mB;AACA,2B;AACA,0B;AACA,6B;AACA,gC;AACA,c;AACA,6B;AACA,O;AACA,K;AACA,I;AACA,uD;AACA,+B;AACA,sC;AACA,gD;;AAEA,8C;AACA,2D;AACA,wB;AACA,6B;AACA,uD;AACA,uC;;AAEA,mB;AACA,mD;AACA,U;AACA,qB;AACA,Y;AACA,0D;AACA,K;AACA,G;AACA,G;;AAEA,4C;AACA,+C;AACA,uD;;AAEA,iB;AACA,4B;AACA,G;AACA,G;;AAEA,+D;AACA,yC;AACA,4C;AACA,8C;AACA,4C;AACA,yB;AACA,4B;AACA,iD;AACA,Y;AACA,wD;AACA,K;AACA,G;AACA,G;;AAEA,mD;AACA,oC;AACA,mC;AACA,E;;AAEA,mD;AACA,wE;AACA,Q;AACA,yE;AACA,kB;AACA,qB;AACA,yB;AACA,yB;AACA,gB;AACA,kB;AACA,kB;AACA,sD;AACA,yB;AACA,gB;AACA,mB;AACA,mB;AACA,mB;AACA,uC;AACA,+B;AACA,gC;AACA,sB;AACA,oB;AACA,2C;AACA,2B;AACA,mB;AACA,uB;AACA,uB;AACA,qB;AACA,I;;AAEA,8B;AACA,gB;AACA,G;;AAEA,6C;AACA,4C;AACA,E;;AAEA,qE;AACA,uE;AACA,2B;AACA,sB;AACA,2D;AACA,C;;AAEA,mC;AACA,wB;AACA,sC;AACA,uC;AACA,U;AACA,kE;AACA,G;AACA,E;;AAEA,uE;AACA,oD;AACA,mE;AACA,qE;AACA,qE;AACA,uD;AACA,oE;AACA,mD;AACA,iE;AACA,mD;AACA,0C;AACA,+C;AACA,oB;AACA,yB;;AAEA,sC;AACA,mC;AACA,Y;AACA,gC;AACA,+D;AACA,iC;AACA,2E;AACA,2D;AACA,yD;AACA,yC;AACA,0D;AACA,c;AACA,qC;AACA,O;AACA,K;AACA,G;AACA,G;;AAEA,iE;AACA,qD;AACA,sE;AACA,kE;AACA,yB;AACA,6B;AACA,8C;AACA,Y;AACA,2C;AACA,K;AACA,kE;AACA,gE;AACA,2C;AACA,sE;AACA,mC;AACA,8D;AACA,kC;AACA,yC;AACA,gD;AACA,sD;AACA,kD;AACA,uC;AACA,U;AACA,6C;AACA,G;;AAEA,gE;AACA,oC;AACA,E;;;AAGA,4C;AACA,mB;AACA,qB;AACA,E;;AAEA,+D;AACA,sB;AACA,gE;AACA,uB;AACA,+B;;AAEA,2B;AACA,uC;AACA,6D;AACA,4D;AACA,yD;AACA,sD;AACA,4B;AACA,gC;AACA,mC;AACA,2B;AACA,2C;AACA,yB;AACA,K;AACA,G;;AAEA,2B;AACA,uB;AACA,iB;AACA,4B;AACA,uC;AACA,2B;AACA,2B;AACA,uD;AACA,8B;AACA,wB;AACA,O;AACA,Y;AACA,4B;AACA,+B;AACA,K;AACA,6B;AACA,4B;AACA,4C;AACA,yB;AACA,2B;AACA,K;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;;ACvUA,8C;AACA,kB;;AAEA,oB;AACA,6B;AACA,sB;AACA,uE;AACA,U;AACA,+C;AACA,G;;AAEA,+C;AACA,uB;;AAEA,kC;AACA,2B;AACA,kC;AACA,2C;AACA,kC;AACA,M;AACA,+B;AACA,0C;AACA,+B;AACA,M;AACA,oB;AACA,mB;AACA,e;AACA,uB;AACA,I;AACA,0D;;AAEA,iC;;AAEA,gB;AACA,gB;;AAEA,qB;AACA,iC;AACA,6C;AACA,G;;AAEA,c;AACA,E;;AAEA,mC;AACA,c;AACA,E;;AAEA,mC;AACA,kB;;AAEA,mB;AACA,uB;;AAEA,wB;;AAEA,iC;;AAEA,yD;AACA,sC;AACA,2B;;AAEA,6B;;AAEA,yB;AACA,iC;AACA,uC;;AAEA,mD;AACA,sC;AACA,8B;AACA,iB;AACA,S;AACA,O;;AAEA,iC;AACA,yB;AACA,O;AACA,K;AACA,E;;AAEA,kC;AACA,gC;AACA,E;;AAEA,iC;AACA,sD;AACA,sB;;AAEA,wB;AACA,E;;AAEA,8E;AACA,8E;AACA,oD;AACA,E;AACA,yE;AACA,yE;AACA,uE;AACA,0E;AACA,2E;AACA,yE;AACA,4E;AACA,kB;AACA,E;AACA,0E;AACA,0E;AACA,qE;AACA,sE;AACA,yE;AACA,8D;AACA,E;AACA,0E;AACA,oE;AACA,uE;AACA,wE;AACA,0E;AACA,2E;AACA,2E;AACA,4E;AACA,sD;AACA,E;AACA,4E;AACA,8E;AACA,E;AACA,gD;AACA,0C;;AAEA,2B;AACA,oC;;AAEA,yB;AACA,uB;AACA,M;;AAEA,0B;AACA,iB;AACA,M;;AAEA,a;;AAEA,U;AACA,4B;AACA,8B;AACA,mB;AACA,M;AACA,qC;AACA,kB;AACA,G;AACA,E;;;AAGA,2D;AACA,sB;AACA,+C;AACA,a;AACA,a;AACA,G;;AAEA,kC;AACA,gB;AACA,iD;;AAEA,iB;AACA,E;;AAEA,wC;;AAEA,kE;AACA,6B;AACA,iE;;AAEA,oE;AACA,E;;AAEA,gE;AACA,E;AACA,gF;AACA,yC;AACA,iD;AACA,4C;AACA,E;AACA,+E;AACA,kC;AACA,qD;AACA,e;AACA,uD;;AAEA,sC;AACA,oC;AACA,kD;AACA,8C;AACA,oD;AACA,U;AACA,iD;AACA,sE;AACA,G;AACA,E;;AAEA,8C;AACA,oB;AACA,4E;;AAEA,2B;;AAEA,gC;;AAEA,6C;;AAEA,6C;;AAEA,4B;AACA,qB;AACA,2B;;AAEA,K;;AAEA,0C;;AAEA,+B;AACA,4B;AACA,yB;AACA,oC;AACA,qC;AACA,mD;AACA,S;AACA,K;AACA,I;;AAEA,c;AACA,E;;AAEA,4D;AACA,6B;AACA,+C;AACA,oB;AACA,4E;AACA,iC;AACA,yD;;AAEA,qE;AACA,oC;AACA,E;;AAEA,qC;AACA,8B;AACA,4D;AACA,yB;AACA,uB;AACA,U;AACA,uB;AACA,6D;AACA,gC;AACA,G;AACA,E;;AAEA,uD;AACA,6C;AACA,2B;AACA,yD;;AAEA,sC;AACA,iC;AACA,iC;;AAEA,6B;AACA,yB;AACA,E;;AAEA,kE;AACA,mD;AACA,E;;AAEA,4E;AACA,6D;AACA,E;;AAEA,uE;AACA,yE;AACA,oE;AACA,qF;AACA,oF;AACA,0E;;AAEA,qB;AACA,yB;AACA,mB;AACA,uG;AACA,wB;AACA,0D;AACA,qC;AACA,yC;AACA,4D;AACA,0C;;AAEA,gC;AACA,2B;AACA,kD;AACA,2B;AACA,0D;AACA,gC;AACA,uB;AACA,kE;AACA,6B;;AAEA,sD;AACA,kD;AACA,8B;;AAEA,yB;AACA,4B;;AAEA,2D;AACA,O;AACA,O;AACA,iC;AACA,0B;AACA,oB;AACA,oB;AACA,M;AACA,gB;AACA,mC;AACA,qC;AACA,oB;AACA,S;AACA,K;AACA,kC;AACA,wC;AACA,+B;AACA,a;AACA,sE;AACA,6E;AACA,Y;AACA,kD;AACA,K;;AAEA,8B;AACA,iC;AACA,sC;AACA,kC;AACA,gC;AACA,oB;AACA,M;;AAEA,mB;AACA,gD;AACA,oC;AACA,4B;AACA,uE;AACA,S;;AAEA,a;AACA,yE;AACA,+B;AACA,sB;AACA,kC;AACA,0E;AACA,4D;AACA,a;AACA,4C;AACA,W;AACA,qB;AACA,+B;AACA,S;AACA,S;AACA,uD;AACA,wB;AACA,S;AACA,K;AACA,uD;;AAEA,iC;AACA,sD;AACA,gB;AACA,oD;;AAEA,sE;AACA,wB;AACA,8B;AACA,8B;;AAEA,yC;AACA,4C;AACA,8D;AACA,4C;AACA,wE;AACA,wC;AACA,mE;AACA,wB;AACA,wD;AACA,8C;AACA,2C;AACA,kG;AACA,oF;AACA,kD;AACA,8D;AACA,U;AACA,qB;AACA,0D;AACA,G;AACA,E;;;;AAIA,4D;AACA,0D;AACA,6B;;AAEA,+B;AACA,e;AACA,mB;AACA,uB;AACA,6B;AACA,I;AACA,gC;AACA,sB;AACA,oB;AACA,G;;AAEA,kC;AACA,qD;AACA,E;;AAEA,iD;AACA,+C;AACA,E;;AAEA,oD;AACA,qE;AACA,E;;;;;;;;;;;;;;;;;;;;AC7aA,4D;AACA,2E;;AAEA,uB;AACA,mD;AACA,0B;AACA,8B;AACA,M;AACA,2B;AACA,0B;AACA,Q;AACA,sC;AACA,I;;AAEA,W;AACA,E;;;AAGA,gE;AACA,+E;;AAEA,uB;AACA,mD;AACA,0B;AACA,8B;AACA,M;AACA,6B;AACA,0B;AACA,Q;AACA,sC;AACA,I;;AAEA,W;AACA,E;;AAEA,4E;AACA,6E;AACA,8E;AACA,mC;AACA,iC;AACA,c;AACA,iB;AACA,M;AACA,0E;AACA,qC;AACA,E;;AAEA,wE;AACA,E;AACA,yE;AACA,wE;AACA,gB;AACA,4C;AACA,2D;;AAEA,2B;AACA,wB;AACA,8D;AACA,kC;AACA,0B;AACA,O;AACA,G;;AAEA,4B;AACA,yD;AACA,I;;AAEA,4B;AACA,sD;AACA,I;;AAEA,oC;AACA,oB;AACA,sB;AACA,qC;AACA,yB;AACA,S;AACA,K;AACA,I;AACA,mC;;AAEA,e;AACA,E;;AAEA,8D;AACA,6E;;AAEA,6B;AACA,wB;AACA,4B;AACA,mC;AACA,K;AACA,E;;AAEA,2F;AACA,oC;AACA,0E;AACA,qC;AACA,uF;AACA,6D;AACA,iG;AACA,E;;AAEA,gE;AACA,E;AACA,oC;AACA,gE;AACA,0D;AACA,+C;AACA,sD;AACA,uD;AACA,sD;AACA,wD;AACA,uD;AACA,uD;AACA,wC;AACA,+B;;AAEA,gD;AACA,mD;AACA,mB;AACA,Q;AACA,qB;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AC7HA,gC;AACA,mB;AACA,+B;AACA,oB;AACA,iC;AACA,yC;;AAEA,gC;AACA,2D;AACA,yD;AACA,yD;AACA,yD;AACA,qC;AACA,Q;AACA,2D;AACA,2D;AACA,0D;AACA,uD;AACA,0D;AACA,2D;AACA,2D;AACA,6D;AACA,wB;AACA,iD;AACA,yB;AACA,oD;AACA,wB;AACA,c;AACA,W;;AAEA,yB;AACA,qB;AACA,c;AACA,2B;AACA,O;AACA,mB;AACA,Y;AACA,kB;AACA,K;AACA,I;AACA,6B;AACA,oB;;AAEA,yB;;AAEA,iC;AACA,yC;;AAEA,8D;AACA,sE;AACA,+D;AACA,sB;AACA,sC;AACA,qE;AACA,e;;AAEA,gC;AACA,8D;;AAEA,4B;AACA,6B;AACA,0B;AACA,O;AACA,yB;AACA,4B;AACA,uD;AACA,O;AACA,M;;AAEA,8D;AACA,+B;AACA,Q;AACA,iD;AACA,sB;AACA,8C;;AAEA,wB;AACA,sC;;AAEA,yC;AACA,oC;AACA,uB;AACA,sB;AACA,U;AACA,gD;AACA,oC;AACA,sC;AACA,mB;AACA,wB;AACA,U;;AAEA,qB;AACA,4D;;AAEA,6E;AACA,kD;AACA,Q;AACA,sC;AACA,uB;AACA,uD;AACA,Q;AACA,oD;AACA,yB;AACA,2C;AACA,8D;AACA,Q;AACA,kD;AACA,iF;AACA,O;AACA,O;;AAEA,6D;AACA,kB;AACA,I;AACA,0B;AACA,yC;AACA,8C;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;;ACrHA,8C;;AAEA,yD;AACA,6D;AACA,iD;AACA,2C;AACA,yC;AACA,mC;AACA,kC;AACA,gB;AACA,E;;AAEA,4D;AACA,iE;AACA,qC;AACA,2B;AACA,iB;AACA,yB;AACA,4E;AACA,4B;AACA,K;AACA,K;AACA,E;;AAEA,sE;AACA,c;AACA,yB;AACA,qB;AACA,wC;AACA,qC;AACA,E;;AAEA,uB;AACA,a;AACA,I;AACA,sE;AACA,uC;AACA,+B;AACA,oB;AACA,yC;AACA,e;AACA,a;;AAEA,Y;AACA,gD;;AAEA,yB;AACA,qE;AACA,4C;AACA,gC;AACA,yE;AACA,O;;AAEA,6D;AACA,2C;AACA,gG;AACA,O;;AAEA,uD;;AAEA,4D;AACA,kD;AACA,yC;AACA,4B;;AAEA,8C;AACA,mC;;AAEA,gE;AACA,6D;AACA,W;AACA,M;AACA,wD;AACA,wD;AACA,4D;AACA,0B;AACA,6B;AACA,0C;AACA,6C;AACA,4C;AACA,kD;AACA,yB;AACA,W;AACA,iD;AACA,0B;;AAEA,iD;;AAEA,Y;AACA,4D;AACA,uC;AACA,0C;AACA,mD;AACA,oF;AACA,mB;AACA,sB;AACA,8B;AACA,yC;AACA,+C;AACA,sB;AACA,Q;AACA,K;;AAEA,sE;AACA,gF;AACA,sE;AACA,0E;AACA,uC;AACA,0C;AACA,kE;AACA,Q;AACA,Y;AACA,oB;AACA,M;AACA,I;AACA,iC;AACA,6C;AACA,I;AACA,sB;AACA,oD;AACA,yB;AACA,e;;AAEA,iC;AACA,8D;AACA,I;AACA,6B;AACA,+C;AACA,6B;AACA,iD;AACA,uC;AACA,qD;AACA,oB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACvIA,sE;AACA,sC;AACA,uB;;AAEA,2C;AACA,6B;AACA,E;;AAEA,oC;AACA,6B;AACA,E;;AAEA,gB;AACA,8C;;AAEA,mC;AACA,+C;AACA,oB;AACA,gB;AACA,gB;AACA,kB;AACA,kB;AACA,kE;AACA,gB;AACA,I;AACA,gC;AACA,yB;AACA,I;;AAEA,uB;AACA,8C;AACA,I;AACA,K;;AAEA,qE;AACA,iC;AACA,0C;AACA,uB;AACA,E;AACA,uD;AACA,gC;AACA,E","sourcesContent":["\r\nvar debugFunc;\r\n\r\n// Meteor UI calls into user code in many places, and it's nice to catch exceptions\r\n// propagated from user code immediately so that the whole system doesn't just\r\n// break.  Catching exceptions is easy; reporting them is hard.  This helper\r\n// reports exceptions.\r\n//\r\n// Usage:\r\n//\r\n// ```\r\n// try {\r\n//   // ... someStuff ...\r\n// } catch (e) {\r\n//   reportUIException(e);\r\n// }\r\n// ```\r\n//\r\n// An optional second argument overrides the default message.\r\n\r\nreportUIException = function (e, msg) {\r\n  if (! debugFunc)\r\n    // adapted from Deps\r\n    debugFunc = function () {\r\n      return (typeof Meteor !== \"undefined\" ? Meteor._debug :\r\n              ((typeof console !== \"undefined\") && console.log ? console.log :\r\n               function () {}));\r\n    };\r\n\r\n  // In Chrome, `e.stack` is a multiline string that starts with the message\r\n  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.\r\n  // `console.log` supplies the space between the two arguments.\r\n  debugFunc()(msg || 'Exception in Meteor UI:', e.stack || e.message);\r\n};\r\n","UI = {};\r\n\r\n// A very basic operation like Underscore's `_.extend` that\r\n// copies `src`'s own, enumerable properties onto `tgt` and\r\n// returns `tgt`.\r\n_extend = function (tgt, src) {\r\n  for (var k in src)\r\n    if (src.hasOwnProperty(k))\r\n      tgt[k] = src[k];\r\n  return tgt;\r\n};\r\n\r\n// Defines a single non-enumerable, read-only property\r\n// on `tgt`.\r\n// It won't be non-enumerable in IE 8, so its\r\n// non-enumerability can't be relied on for logic\r\n// purposes, it just makes things prettier in\r\n// the dev console.\r\nvar _defineNonEnum = function (tgt, name, value) {\r\n  try {\r\n    Object.defineProperty(tgt, name, {value: value});\r\n  } catch (e) {\r\n    // IE < 9\r\n    tgt[name] = value;\r\n  }\r\n  return tgt;\r\n};\r\n\r\n// Named function (like `function Component() {}` below) make\r\n// inspection in debuggers more descriptive. In IE, this sets the\r\n// value of the `Component` var in the function scope in which it's\r\n// executed. We already have a top-level `Component` var so we create\r\n// a new function scope to not write it over in IE.\r\n(function () {\r\n\r\n  // Components and Component kinds are the same thing, just\r\n  // objects; there are no constructor functions, no `new`,\r\n  // and no `instanceof`.  A Component object is like a class,\r\n  // until it is inited, at which point it becomes more like\r\n  // an instance.\r\n  //\r\n  // `y = x.extend({ ...new props })` creates a new Component\r\n  // `y` with `x` as its prototype, plus additional properties\r\n  // on `y` itself.  `extend` is used both to subclass and to\r\n  // create instances (and the hope is we can gloss over the\r\n  // difference in the docs).\r\n  UI.Component = (function (constr) {\r\n\r\n    // Make sure the \"class name\" that Chrome infers for\r\n    // UI.Component is \"Component\", and that\r\n    // `new UI.Component._constr` (which is what `extend`\r\n    // does) also produces objects whose inferred class\r\n    // name is \"Component\".  Chrome's name inference rules\r\n    // are a little mysterious, but a function name in\r\n    // the source code (as in `function Component() {}`)\r\n    // seems to be reliable and high precedence.\r\n    var C = new constr;\r\n    _defineNonEnum(C, '_constr', constr);\r\n    _defineNonEnum(C, '_super', null);\r\n    return C;\r\n  })(function Component() {});\r\n})();\r\n\r\n_extend(UI, {\r\n  nextGuid: 2, // Component is 1!\r\n\r\n  isComponent: function (obj) {\r\n    return obj && UI.isKindOf(obj, UI.Component);\r\n  },\r\n  // `UI.isKindOf(a, b)` where `a` and `b` are Components\r\n  // (or kinds) asks if `a` is or descends from\r\n  // (transitively extends) `b`.\r\n  isKindOf: function (a, b) {\r\n    while (a) {\r\n      if (a === b)\r\n        return true;\r\n      a = a._super;\r\n    }\r\n    return false;\r\n  },\r\n  // use these to produce error messages for developers\r\n  // (though throwing a more specific error message is\r\n  // even better)\r\n  _requireNotDestroyed: function (c) {\r\n    if (c.isDestroyed)\r\n      throw new Error(\"Component has been destroyed; can't perform this operation\");\r\n  },\r\n  _requireInited: function (c) {\r\n    if (! c.isInited)\r\n      throw new Error(\"Component must be inited to perform this operation\");\r\n  },\r\n  _requireDom: function (c) {\r\n    if (! c.dom)\r\n      throw new Error(\"Component must be built into DOM to perform this operation\");\r\n  }\r\n});\r\n\r\nComponent = UI.Component;\r\n\r\n_extend(UI.Component, {\r\n  kind: \"Component\",\r\n  guid: \"1\",\r\n  dom: null,\r\n  // Has this Component ever been inited?\r\n  isInited: false,\r\n  // Has this Component been destroyed?  Only inited Components\r\n  // can be destroyed.\r\n  isDestroyed: false,\r\n  // Component that created this component (typically also\r\n  // the DOM containment parent).\r\n  // No child pointers (except in `dom`).\r\n  parent: null,\r\n\r\n  // create a new subkind or instance whose proto pointer\r\n  // points to this, with additional props set.\r\n  extend: function (props) {\r\n    // this function should never cause `props` to be\r\n    // mutated in case people want to reuse `props` objects\r\n    // in a mixin-like way.\r\n\r\n    if (this.isInited)\r\n      // Disallow extending inited Components so that\r\n      // inited Components don't inherit instance-specific\r\n      // properties from other inited Components, just\r\n      // default values.\r\n      throw new Error(\"Can't extend an inited Component\");\r\n\r\n    var constr;\r\n    var constrMade = false;\r\n    if (props && props.kind) {\r\n      // If `kind` is different from super, set a constructor.\r\n      // We used to set the function name here so that components\r\n      // printed better in the console, but we took it out because\r\n      // of CSP (and in hopes that Chrome finally adds proper\r\n      // displayName support).\r\n      constr = function () {};\r\n      constrMade = true;\r\n    } else {\r\n      constr = this._constr;\r\n    }\r\n\r\n    // We don't know where we're getting `constr` from --\r\n    // it might be from some supertype -- just that it has\r\n    // the right function name.  So set the `prototype`\r\n    // property each time we use it as a constructor.\r\n    constr.prototype = this;\r\n\r\n    var c = new constr;\r\n    if (constrMade)\r\n      c._constr = constr;\r\n\r\n    if (props)\r\n      _extend(c, props);\r\n\r\n    // for efficient Component instantiations, we assign\r\n    // as few things as possible here.\r\n    _defineNonEnum(c, '_super', this);\r\n    c.guid = String(UI.nextGuid++);\r\n\r\n    return c;\r\n  }\r\n});\r\n\r\n//callChainedCallback = function (comp, propName, orig) {\r\n  // Call `comp.foo`, `comp._super.foo`,\r\n  // `comp._super._super.foo`, and so on, but in reverse\r\n  // order, and only if `foo` is an \"own property\" in each\r\n  // case.  Furthermore, the passed value of `this` should\r\n  // remain `comp` for all calls (which is achieved by\r\n  // filling in `orig` when recursing).\r\n//  if (comp._super)\r\n//    callChainedCallback(comp._super, propName, orig || comp);\r\n//\r\n//  if (comp.hasOwnProperty(propName))\r\n//    comp[propName].call(orig || comp);\r\n//};\r\n\r\n\r\n// Returns 0 if the nodes are the same or either one contains the other;\r\n// otherwise, -1 if a comes before b, or else 1 if b comes before a in\r\n// document order.\r\n// Requires: `a` and `b` are element nodes in the same document tree.\r\nvar compareElementIndex = function (a, b) {\r\n  // See http://ejohn.org/blog/comparing-document-position/\r\n  if (a === b)\r\n    return 0;\r\n  if (a.compareDocumentPosition) {\r\n    var n = a.compareDocumentPosition(b);\r\n    return ((n & 0x18) ? 0 : ((n & 0x4) ? -1 : 1));\r\n  } else {\r\n    // Only old IE is known to not have compareDocumentPosition (though Safari\r\n    // originally lacked it).  Thankfully, IE gives us a way of comparing elements\r\n    // via the \"sourceIndex\" property.\r\n    if (a.contains(b) || b.contains(a))\r\n      return 0;\r\n    return (a.sourceIndex < b.sourceIndex ? -1 : 1);\r\n  }\r\n};\r\n\r\nfindComponentWithProp = function (id, comp) {\r\n  while (comp) {\r\n    if (typeof comp[id] !== 'undefined')\r\n      return comp;\r\n    comp = comp.parent;\r\n  }\r\n  return null;\r\n};\r\n\r\nfindComponentWithHelper = function (id, comp) {\r\n  while (comp) {\r\n    if (comp.__helperHost) {\r\n      if (typeof comp[id] !== 'undefined')\r\n        return comp;\r\n      else\r\n        return null;\r\n    }\r\n    comp = comp.parent;\r\n  }\r\n  return null;\r\n};\r\n\r\ngetComponentData = function (comp) {\r\n  comp = findComponentWithProp('data', comp);\r\n  return (comp ?\r\n          (typeof comp.data === 'function' ?\r\n           comp.data() : comp.data) :\r\n          null);\r\n};\r\n\r\nupdateTemplateInstance = function (comp) {\r\n  // Populate `comp.templateInstance.{firstNode,lastNode,data}`\r\n  // on demand.\r\n  var tmpl = comp.templateInstance;\r\n  tmpl.data = getComponentData(comp);\r\n\r\n  if (comp.dom && !comp.isDestroyed) {\r\n    tmpl.firstNode = comp.dom.startNode().nextSibling;\r\n    tmpl.lastNode = comp.dom.endNode().previousSibling;\r\n    // Catch the case where the DomRange is empty and we'd\r\n    // otherwise pass the out-of-order nodes (end, start)\r\n    // as (firstNode, lastNode).\r\n    if (tmpl.lastNode && tmpl.lastNode.nextSibling === tmpl.firstNode)\r\n      tmpl.lastNode = tmpl.firstNode;\r\n  } else {\r\n    // on 'created' or 'destroyed' callbacks we don't have a DomRange\r\n    tmpl.firstNode = null;\r\n    tmpl.lastNode = null;\r\n  }\r\n};\r\n\r\n_extend(UI.Component, {\r\n  // We implement the old APIs here, including how data is passed\r\n  // to helpers in `this`.\r\n  helpers: function (dict) {\r\n    _extend(this, dict);\r\n  },\r\n  events: function (dict) {\r\n    var events;\r\n    if (this.hasOwnProperty('_events'))\r\n      events = this._events;\r\n    else\r\n      events = (this._events = []);\r\n\r\n    _.each(dict, function (handler, spec) {\r\n      var clauses = spec.split(/,\\s+/);\r\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\r\n      _.each(clauses, function (clause) {\r\n        var parts = clause.split(/\\s+/);\r\n        if (parts.length === 0)\r\n          return;\r\n\r\n        var newEvents = parts.shift();\r\n        var selector = parts.join(' ');\r\n        events.push({events: newEvents,\r\n                     selector: selector,\r\n                     handler: handler});\r\n      });\r\n    });\r\n  }\r\n});\r\n\r\n// XXX we don't really want this to be a user-visible callback,\r\n// it's just a particular signal we need from DomRange.\r\nUI.Component.notifyParented = function () {\r\n  var self = this;\r\n  for (var comp = self; comp; comp = comp._super) {\r\n    var events = (comp.hasOwnProperty('_events') && comp._events) || null;\r\n    if ((! events) && comp.hasOwnProperty('events') &&\r\n        typeof comp.events === 'object') {\r\n      // Provide limited back-compat support for `.events = {...}`\r\n      // syntax.  Pass `comp.events` to the original `.events(...)`\r\n      // function.  This code must run only once per component, in\r\n      // order to not bind the handlers more than once, which is\r\n      // ensured by the fact that we only do this when `comp._events`\r\n      // is falsy, and we cause it to be set now.\r\n      UI.Component.events.call(comp, comp.events);\r\n      events = comp._events;\r\n    }\r\n    _.each(events, function (esh) { // {events, selector, handler}\r\n      // wrap the handler here, per instance of the template that\r\n      // declares the event map, so we can pass the instance to\r\n      // the event handler.\r\n      var wrappedHandler = function (event) {\r\n        var comp = UI.DomRange.getContainingComponent(event.currentTarget);\r\n        var data = comp && getComponentData(comp);\r\n        var args = _.toArray(arguments);\r\n        updateTemplateInstance(self);\r\n        return Deps.nonreactive(function () {\r\n          // put self.templateInstance as the second argument\r\n          args.splice(1, 0, self.templateInstance);\r\n          // Don't want to be in a deps context, even if we were somehow\r\n          // triggered synchronously in an existing deps context\r\n          // (the `blur` event can do this).\r\n          // XXX we should probably do what Spark did and block all\r\n          // event handling during our DOM manip.  Many apps had weird\r\n          // unanticipated bugs until we did that.\r\n          return esh.handler.apply(data === null ? {} : data, args);\r\n        });\r\n      };\r\n\r\n      self.dom.on(esh.events, esh.selector, wrappedHandler);\r\n    });\r\n  }\r\n\r\n  if (self.rendered) {\r\n    // Defer rendered callback until flush time.\r\n    Deps.afterFlush(function () {\r\n      if (! self.isDestroyed) {\r\n        updateTemplateInstance(self);\r\n        self.rendered.call(self.templateInstance);\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\n// past compat\r\nUI.Component.preserve = function () {\r\n  Meteor._debug(\"The 'preserve' method on templates is now unnecessary and deprecated.\");\r\n};\r\n\r\n// Gets the data context of the enclosing component that rendered a\r\n// given element\r\nUI.getElementData = function (el) {\r\n  var comp = UI.DomRange.getContainingComponent(el);\r\n  return comp && getComponentData(comp);\r\n};\r\n\r\nvar jsUrlsAllowed = false;\r\nUI._allowJavascriptUrls = function () {\r\n  jsUrlsAllowed = true;\r\n};\r\nUI._javascriptUrlsAllowed = function () {\r\n  return jsUrlsAllowed;\r\n};\r\n","if (Meteor.isClient) {\r\n\r\n  // XXX in the future, make the jQuery adapter a separate\r\n  // package and make the choice of back-end library\r\n  // configurable.  Adapters all expose the same DomBackend interface.\r\n\r\n  if (! Package.jquery)\r\n    throw new Error(\"Meteor UI jQuery adapter: jQuery not found.\");\r\n\r\n  var $jq = Package.jquery.jQuery;\r\n\r\n  var DomBackend = {};\r\n  UI.DomBackend = DomBackend;\r\n\r\n  ///// Removal detection and interoperability.\r\n\r\n  // For an explanation of this technique, see:\r\n  // http://bugs.jquery.com/ticket/12213#comment:23 .\r\n  //\r\n  // In short, an element is considered \"removed\" when jQuery\r\n  // cleans up its *private* userdata on the element,\r\n  // which we can detect using a custom event with a teardown\r\n  // hook.\r\n\r\n  var JQUERY_REMOVAL_WATCHER_EVENT_NAME = 'meteor_ui_removal_watcher';\r\n  var REMOVAL_CALLBACKS_PROPERTY_NAME = '$meteor_ui_removal_callbacks';\r\n  var NOOP = function () {};\r\n\r\n  // Causes `elem` (a DOM element) to be detached from its parent, if any.\r\n  // Whether or not `elem` was detached, causes any callbacks registered\r\n  // with `onRemoveElement` on `elem` and its descendants to fire.\r\n  // Not for use on non-element nodes.\r\n  //\r\n  // This method is modeled after the behavior of jQuery's `$(elem).remove()`,\r\n  // which causes teardown on the subtree being removed.\r\n  DomBackend.removeElement = function (elem) {\r\n    $jq(elem).remove();\r\n  };\r\n\r\n  // Registers a callback function to be called when the given element or\r\n  // one of its ancestors is removed from the DOM via the backend library.\r\n  // The callback function is called at most once, and it receives the element\r\n  // in question as an argument.\r\n  DomBackend.onRemoveElement = function (elem, func) {\r\n    if (! elem[REMOVAL_CALLBACKS_PROPERTY_NAME]) {\r\n      elem[REMOVAL_CALLBACKS_PROPERTY_NAME] = [];\r\n\r\n      // Set up the event, only the first time.\r\n      $jq(elem).on(JQUERY_REMOVAL_WATCHER_EVENT_NAME, NOOP);\r\n    }\r\n\r\n    elem[REMOVAL_CALLBACKS_PROPERTY_NAME].push(func);\r\n  };\r\n\r\n  $jq.event.special[JQUERY_REMOVAL_WATCHER_EVENT_NAME] = {\r\n    teardown: function() {\r\n      var elem = this;\r\n      var callbacks = elem[REMOVAL_CALLBACKS_PROPERTY_NAME];\r\n      if (callbacks) {\r\n        for (var i = 0; i < callbacks.length; i++)\r\n          callbacks[i](elem);\r\n        elem[REMOVAL_CALLBACKS_PROPERTY_NAME] = null;\r\n      }\r\n    }\r\n  };\r\n\r\n  DomBackend.parseHTML = function (html) {\r\n    // Return an array of nodes.\r\n    //\r\n    // jQuery does fancy stuff like creating an appropriate\r\n    // container element and setting innerHTML on it, as well\r\n    // as working around various IE quirks.\r\n    return $jq.parseHTML(html) || [];\r\n  };\r\n\r\n  // Must use jQuery semantics for `context`, not\r\n  // querySelectorAll's.  In other words, all the parts\r\n  // of `selector` must be found under `context`.\r\n  DomBackend.findBySelector = function (selector, context) {\r\n    return $jq(selector, context);\r\n  };\r\n\r\n  DomBackend.newFragment = function (nodeArray) {\r\n    var frag = document.createDocumentFragment();\r\n    for (var i = 0; i < nodeArray.length; i++)\r\n      frag.appendChild(nodeArray[i]);\r\n    return frag;\r\n  };\r\n\r\n  // `selector` is non-null.  `type` is one type (but\r\n  // may be in backend-specific form, e.g. have namespaces).\r\n  // Order fired must be order bound.\r\n  DomBackend.delegateEvents = function (elem, type, selector, handler) {\r\n    $jq(elem).on(type, selector, handler);\r\n  };\r\n\r\n  DomBackend.undelegateEvents = function (elem, type, handler) {\r\n    $jq(elem).off(type, handler);\r\n  };\r\n\r\n  DomBackend.bindEventCapturer = function (elem, type, selector, handler) {\r\n    var $elem = $jq(elem);\r\n\r\n    var wrapper = function (event) {\r\n      event = $jq.event.fix(event);\r\n      event.currentTarget = event.target;\r\n\r\n      // Note: It might improve jQuery interop if we called into jQuery\r\n      // here somehow.  Since we don't use jQuery to dispatch the event,\r\n      // we don't fire any of jQuery's event hooks or anything.  However,\r\n      // since jQuery can't bind capturing handlers, it's not clear\r\n      // where we would hook in.  Internal jQuery functions like `dispatch`\r\n      // are too high-level.\r\n      var $target = $jq(event.currentTarget);\r\n      if ($target.is($elem.find(selector)))\r\n        handler.call(elem, event);\r\n    };\r\n\r\n    handler._meteorui_wrapper = wrapper;\r\n\r\n    type = this.parseEventType(type);\r\n    // add *capturing* event listener\r\n    elem.addEventListener(type, wrapper, true);\r\n  };\r\n\r\n  DomBackend.unbindEventCapturer = function (elem, type, handler) {\r\n    type = this.parseEventType(type);\r\n    elem.removeEventListener(type, handler._meteorui_wrapper, true);\r\n  };\r\n\r\n  DomBackend.parseEventType = function (type) {\r\n    // strip off namespaces\r\n    var dotLoc = type.indexOf('.');\r\n    if (dotLoc >= 0)\r\n      return type.slice(0, dotLoc);\r\n    return type;\r\n  };\r\n\r\n}","// TODO\r\n// - Lazy removal detection\r\n// - UI hooks (expose, test)\r\n// - Quick remove/add (mark \"leaving\" members; needs UI hooks)\r\n// - Event removal on removal\r\n\r\nvar DomBackend = UI.DomBackend;\r\n\r\nvar removeNode = function (n) {\r\n//  if (n.nodeType === 1 &&\r\n//      n.parentNode.$uihooks && n.parentNode.$uihooks.removeElement)\r\n//    n.parentNode.$uihooks.removeElement(n);\r\n//  else\r\n    n.parentNode.removeChild(n);\r\n};\r\n\r\nvar insertNode = function (n, parent, next) {\r\n//  if (n.nodeType === 1 &&\r\n//      parent.$uihooks && parent.$uihooks.insertElement)\r\n//    parent.$uihooks.insertElement(n, parent, next);\r\n//  else\r\n    // `|| null` because IE throws an error if 'next' is undefined\r\n  parent.insertBefore(n, next || null);\r\n};\r\n\r\nvar moveNode = function (n, parent, next) {\r\n//  if (n.nodeType === 1 &&\r\n//      parent.$uihooks && parent.$uihooks.moveElement)\r\n//    parent.$uihooks.moveElement(n, parent, next);\r\n//  else\r\n    // `|| null` because IE throws an error if 'next' is undefined\r\n    parent.insertBefore(n, next || null);\r\n};\r\n\r\n// A very basic operation like Underscore's `_.extend` that\r\n// copies `src`'s own, enumerable properties onto `tgt` and\r\n// returns `tgt`.\r\nvar _extend = function (tgt, src) {\r\n  for (var k in src)\r\n    if (src.hasOwnProperty(k))\r\n      tgt[k] = src[k];\r\n  return tgt;\r\n};\r\n\r\nvar _contains = function (list, item) {\r\n  if (! list)\r\n    return false;\r\n  for (var i = 0, N = list.length; i < N; i++)\r\n    if (list[i] === item)\r\n      return true;\r\n  return false;\r\n};\r\n\r\nvar isArray = function (x) {\r\n  return !!((typeof x.length === 'number') &&\r\n            (x.sort || x.splice));\r\n};\r\n\r\n// Text nodes consisting of only whitespace\r\n// are \"insignificant\" nodes.\r\nvar isSignificantNode = function (n) {\r\n  return ! (n.nodeType === 3 &&\r\n            (! n.nodeValue ||\r\n             /^\\s+$/.test(n.nodeValue)));\r\n};\r\n\r\nvar checkId = function (id) {\r\n  if (typeof id !== 'string')\r\n    throw new Error(\"id must be a string\");\r\n  if (! id)\r\n    throw new Error(\"id may not be empty\");\r\n};\r\n\r\nvar textExpandosSupported = (function () {\r\n  var tn = document.createTextNode('');\r\n  try {\r\n    tn.blahblah = true;\r\n    return true;\r\n  } catch (e) {\r\n    // IE 8\r\n    return false;\r\n  }\r\n})();\r\n\r\nvar createMarkerNode = (\r\n  textExpandosSupported ?\r\n    function () { return document.createTextNode(\"\"); } :\r\n  function () { return document.createComment(\"IE\"); });\r\n\r\nvar rangeParented = function (range) {\r\n  if (! range.isParented) {\r\n    range.isParented = true;\r\n\r\n    if (! range.owner) {\r\n      // top-level (unowned) ranges in an element,\r\n      // keep a pointer to the range on the parent\r\n      // element.  This is really just for IE 9+\r\n      // TextNode GC issues, but we can't do reliable\r\n      // feature detection (i.e. bug detection).\r\n      var parentNode = range.parentNode();\r\n      var rangeDict = (\r\n        parentNode.$_uiranges ||\r\n          (parentNode.$_uiranges = {}));\r\n      rangeDict[range._rangeId] = range;\r\n      range._rangeDict = rangeDict;\r\n\r\n      // get jQuery to tell us when this node is removed\r\n      DomBackend.onRemoveElement(parentNode, function () {\r\n        rangeRemoved(range);\r\n      });\r\n    }\r\n\r\n    if (range.component && range.component.notifyParented)\r\n      range.component.notifyParented();\r\n\r\n    // recurse on member ranges\r\n    var members = range.members;\r\n    for (var k in members) {\r\n      var mem = members[k];\r\n      if (mem instanceof DomRange)\r\n        rangeParented(mem);\r\n    }\r\n  }\r\n};\r\n\r\nvar rangeRemoved = function (range) {\r\n  if (! range.isRemoved) {\r\n    range.isRemoved = true;\r\n\r\n    if (range._rangeDict)\r\n      delete range._rangeDict[range._rangeId];\r\n\r\n    // XXX clean up events in $_uievents\r\n\r\n    // notify component of removal\r\n    if (range.removed)\r\n      range.removed();\r\n\r\n    membersRemoved(range);\r\n  }\r\n};\r\n\r\nvar nodeRemoved = function (node, viaBackend) {\r\n  if (node.nodeType === 1) { // ELEMENT\r\n    var comps = DomRange.getComponents(node);\r\n    for (var i = 0, N = comps.length; i < N; i++)\r\n      rangeRemoved(comps[i]);\r\n\r\n    if (! viaBackend)\r\n      DomBackend.removeElement(node);\r\n  }\r\n};\r\n\r\nvar membersRemoved = function (range) {\r\n  var members = range.members;\r\n  for (var k in members) {\r\n    var mem = members[k];\r\n    if (mem instanceof DomRange)\r\n      rangeRemoved(mem);\r\n    else\r\n      nodeRemoved(mem);\r\n  }\r\n};\r\n\r\nvar nextGuid = 1;\r\n\r\nvar DomRange = function () {\r\n  var start = createMarkerNode();\r\n  var end = createMarkerNode();\r\n  var fragment = DomBackend.newFragment([start, end]);\r\n  fragment.$_uiIsOffscreen = true;\r\n\r\n  this.start = start;\r\n  this.end = end;\r\n  start.$ui = this;\r\n  end.$ui = this;\r\n\r\n  this.members = {};\r\n  this.nextMemberId = 1;\r\n  this.owner = null;\r\n  this._rangeId = nextGuid++;\r\n  this._rangeDict = null;\r\n\r\n  this.isParented = false;\r\n  this.isRemoved = false;\r\n};\r\n\r\n_extend(DomRange.prototype, {\r\n  getNodes: function () {\r\n    if (! this.parentNode())\r\n      return [];\r\n\r\n    this.refresh();\r\n\r\n    var afterNode = this.end.nextSibling;\r\n    var nodes = [];\r\n    for (var n = this.start;\r\n         n && n !== afterNode;\r\n         n = n.nextSibling)\r\n      nodes.push(n);\r\n    return nodes;\r\n  },\r\n  removeAll: function () {\r\n    if (! this.parentNode())\r\n      return;\r\n\r\n    this.refresh();\r\n\r\n    // leave start and end\r\n    var afterNode = this.end;\r\n    var nodes = [];\r\n    for (var n = this.start.nextSibling;\r\n         n && n !== afterNode;\r\n         n = n.nextSibling) {\r\n      // don't remove yet since then we'd lose nextSibling\r\n      nodes.push(n);\r\n    }\r\n    for (var i = 0, N = nodes.length; i < N; i++)\r\n      removeNode(nodes[i]);\r\n\r\n    membersRemoved(this);\r\n\r\n    this.members = {};\r\n  },\r\n  // (_nextNode is internal)\r\n  add: function (id, newMemberOrArray, beforeId, _nextNode) {\r\n    if (id != null && typeof id !== 'string') {\r\n      if (typeof id !== 'object')\r\n        // a non-object first argument is probably meant\r\n        // as an id, NOT a new member, so complain about it\r\n        // as such.\r\n        throw new Error(\"id must be a string\");\r\n      beforeId = newMemberOrArray;\r\n      newMemberOrArray = id;\r\n      id = null;\r\n    }\r\n\r\n    if (! newMemberOrArray || typeof newMemberOrArray !== 'object')\r\n      throw new Error(\"Expected component, node, or array\");\r\n\r\n    if (isArray(newMemberOrArray)) {\r\n      if (newMemberOrArray.length === 1) {\r\n        newMemberOrArray = newMemberOrArray[0];\r\n      } else {\r\n        if (id != null)\r\n          throw new Error(\"Can only add one node or one component if id is given\");\r\n        var array = newMemberOrArray;\r\n        // calculate `nextNode` once in case it involves a refresh\r\n        _nextNode = this.getInsertionPoint(beforeId);\r\n        for (var i = 0; i < array.length; i++)\r\n          this.add(null, array[i], beforeId, _nextNode);\r\n        return;\r\n      }\r\n    }\r\n\r\n    var parentNode = this.parentNode();\r\n    // Consider ourselves removed (and don't mind) if\r\n    // start marker has no parent.\r\n    if (! parentNode)\r\n      return;\r\n    // because this may call `refresh`, it must be done\r\n    // early, before we add the new member.\r\n    var nextNode = (_nextNode ||\r\n                    this.getInsertionPoint(beforeId));\r\n\r\n    var newMember = newMemberOrArray;\r\n    if (id == null) {\r\n      id = this.nextMemberId++;\r\n    } else {\r\n      checkId(id);\r\n      id = ' ' + id;\r\n    }\r\n\r\n    var members = this.members;\r\n    if (members.hasOwnProperty(id)) {\r\n      var oldMember = members[id];\r\n      if (oldMember instanceof DomRange) {\r\n        // range, does it still exist?\r\n        var oldRange = oldMember;\r\n        if (oldRange.start.parentNode !== parentNode) {\r\n          delete members[id];\r\n          oldRange.owner = null;\r\n          rangeRemoved(oldRange);\r\n        } else {\r\n          throw new Error(\"Member already exists: \" + id.slice(1));\r\n        }\r\n      } else {\r\n        // node, does it still exist?\r\n        var oldNode = oldMember;\r\n        if (oldNode.parentNode !== parentNode) {\r\n          nodeRemoved(oldNode);\r\n          delete members[id];\r\n        } else {\r\n          throw new Error(\"Member already exists: \" + id.slice(1));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (newMember instanceof DomRange) {\r\n      // Range\r\n      var range = newMember;\r\n      range.owner = this;\r\n      var nodes = range.getNodes();\r\n\r\n      members[id] = newMember;\r\n      for (var i = 0; i < nodes.length; i++)\r\n        insertNode(nodes[i], parentNode, nextNode);\r\n\r\n      if (this.isParented)\r\n        rangeParented(range);\r\n    } else {\r\n      // Node\r\n      if (typeof newMember.nodeType !== 'number')\r\n        throw new Error(\"Expected Component or Node\");\r\n      var node = newMember;\r\n      // can't attach `$ui` to a TextNode in IE 8, so\r\n      // don't bother on any browser.\r\n      if (node.nodeType !== 3)\r\n        node.$ui = this;\r\n\r\n      members[id] = newMember;\r\n      insertNode(node, parentNode, nextNode);\r\n    }\r\n  },\r\n  remove: function (id) {\r\n    if (id == null) {\r\n      // remove self\r\n      this.removeAll();\r\n      removeNode(this.start);\r\n      removeNode(this.end);\r\n      this.owner = null;\r\n      rangeRemoved(this);\r\n      return;\r\n    }\r\n\r\n    checkId(id);\r\n    id = ' ' + id;\r\n    var members = this.members;\r\n    var member = (members.hasOwnProperty(id) &&\r\n                  members[id]);\r\n    delete members[id];\r\n\r\n    // Don't mind double-remove.\r\n    if (! member)\r\n      return;\r\n\r\n    var parentNode = this.parentNode();\r\n    // Consider ourselves removed (and don't mind) if\r\n    // start marker has no parent.\r\n    if (! parentNode)\r\n      return;\r\n\r\n    if (member instanceof DomRange) {\r\n      // Range\r\n      var range = member;\r\n      range.owner = null;\r\n      // Don't mind if range (specifically its start\r\n      // marker) has been removed already.\r\n      if (range.start.parentNode === parentNode)\r\n        member.remove();\r\n    } else {\r\n      // Node\r\n      var node = member;\r\n      // Don't mind if node has been removed already.\r\n      if (node.parentNode === parentNode)\r\n        removeNode(node);\r\n    }\r\n  },\r\n  moveBefore: function (id, beforeId) {\r\n    var nextNode = this.getInsertionPoint(beforeId);\r\n    checkId(id);\r\n    id = ' ' + id;\r\n    var members = this.members;\r\n    var member =\r\n          (members.hasOwnProperty(id) &&\r\n           members[id]);\r\n    // Don't mind if member doesn't exist.\r\n    if (! member)\r\n      return;\r\n\r\n    var parentNode = this.parentNode();\r\n    // Consider ourselves removed (and don't mind) if\r\n    // start marker has no parent.\r\n    if (! parentNode)\r\n      return;\r\n\r\n    if (member instanceof DomRange) {\r\n      // Range\r\n      var range = member;\r\n      // Don't mind if range (specifically its start marker)\r\n      // has been removed already.\r\n      if (range.start.parentNode === parentNode) {\r\n        range.refresh();\r\n        var nodes = range.getNodes();\r\n        for (var i = 0; i < nodes.length; i++)\r\n          moveNode(nodes[i], parentNode, nextNode);\r\n      }\r\n    } else {\r\n      // Node\r\n      var node = member;\r\n      moveNode(node, parentNode, nextNode);\r\n    }\r\n  },\r\n  get: function (id) {\r\n    checkId(id);\r\n    id = ' ' + id;\r\n    var members = this.members;\r\n    if (members.hasOwnProperty(id))\r\n      return members[id];\r\n    return null;\r\n  },\r\n  parentNode: function () {\r\n    return this.start.parentNode;\r\n  },\r\n  startNode: function () {\r\n    return this.start;\r\n  },\r\n  endNode: function () {\r\n    return this.end;\r\n  },\r\n  eachMember: function (nodeFunc, rangeFunc) {\r\n    var members = this.members;\r\n    var parentNode = this.parentNode();\r\n    for (var k in members) {\r\n      // mem is a component (hosting a Range) or a Node\r\n      var mem = members[k];\r\n      if (mem instanceof DomRange) {\r\n        // Range\r\n        var range = mem;\r\n        if (range.start.parentNode === parentNode) {\r\n          rangeFunc && rangeFunc(range); // still there\r\n        } else {\r\n          range.owner = null;\r\n          delete members[k]; // gone\r\n          rangeRemoved(range);\r\n        }\r\n      } else {\r\n        // Node\r\n        var node = mem;\r\n        if (node.parentNode === parentNode) {\r\n          nodeFunc && nodeFunc(node); // still there\r\n        } else {\r\n          delete members[k]; // gone\r\n          nodeRemoved(node);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  ///////////// INTERNALS below this point, pretty much\r\n\r\n  // The purpose of \"refreshing\" a DomRange is to\r\n  // take into account any element removals or moves\r\n  // that may have occurred, and to \"fix\" the start\r\n  // and end markers before the entire range is moved\r\n  // or removed so that they bracket the appropriate\r\n  // content.\r\n  //\r\n  // For example, if a DomRange contains a single element\r\n  // node, and this node is moved using jQuery, refreshing\r\n  // the DomRange will look to the element as ground truth\r\n  // and move the start/end markers around the element.\r\n  // A refreshed DomRange's nodes may surround nodes from\r\n  // sibling DomRanges (including their marker nodes)\r\n  // until the sibling DomRange is refreshed.\r\n  //\r\n  // Specifically, `refresh` moves the `start`\r\n  // and `end` nodes to immediate before the first,\r\n  // and after the last, \"significant\" node the\r\n  // DomRange contains, where a significant node\r\n  // is any node except a whitespace-only text-node.\r\n  // All member ranges are refreshed first.  Adjacent\r\n  // insignificant member nodes are included between\r\n  // `start` and `end` as well, but it's possible that\r\n  // other insignificant nodes remain as siblings\r\n  // elsewhere.  Nodes with no DomRange owner that are\r\n  // found between this DomRange's nodes are adopted.\r\n  //\r\n  // Performing add/move/remove operations on an \"each\"\r\n  // shouldn't require refreshing the entire each, just\r\n  // the member in question.  (However, adding to the\r\n  // end may require refreshing the whole \"each\";\r\n  // see `getInsertionPoint`.  Adding multiple members\r\n  // at once using `add(array)` is faster.\r\n  refresh: function () {\r\n\r\n    var parentNode = this.parentNode();\r\n    if (! parentNode)\r\n      return;\r\n\r\n    // Using `eachMember`, do several things:\r\n    // - Refresh all member ranges\r\n    // - Count our members\r\n    // - If there's only one, get that one\r\n    // - Make a list of member TextNodes, which we\r\n    //   can't detect with a `$ui` property because\r\n    //   IE 8 doesn't allow user-defined properties\r\n    //   on TextNodes.\r\n    var someNode = null;\r\n    var someRange = null;\r\n    var numMembers = 0;\r\n    var textNodes = null;\r\n    this.eachMember(function (node) {\r\n      someNode = node;\r\n      numMembers++;\r\n      if (node.nodeType === 3) {\r\n        textNodes = (textNodes || []);\r\n        textNodes.push(node);\r\n      }\r\n    }, function (range) {\r\n      range.refresh();\r\n      someRange = range;\r\n      numMembers++;\r\n    });\r\n\r\n    var firstNode = null;\r\n    var lastNode = null;\r\n\r\n    if (numMembers === 0) {\r\n      // don't scan for members\r\n    } else if (numMembers === 1) {\r\n      if (someNode) {\r\n        firstNode = someNode;\r\n        lastNode = someNode;\r\n      } else if (someRange) {\r\n        firstNode = someRange.start;\r\n        lastNode = someRange.end;\r\n      }\r\n    } else {\r\n      // This loop is O(childNodes.length), even if our members\r\n      // are already consecutive.  This means refreshing just one\r\n      // item in a list is technically order of the total number\r\n      // of siblings, including in other list items.\r\n      //\r\n      // The root cause is we intentionally don't track the\r\n      // DOM order of our members, so finding the first\r\n      // and last in sibling order either involves a scan\r\n      // or a bunch of calls to compareDocumentPosition.\r\n      //\r\n      // Fortunately, the common cases of zero and one members\r\n      // are optimized.  Also, the scan is super-fast because\r\n      // no work is done for unknown nodes.  It could be possible\r\n      // to optimize this code further if it becomes a problem.\r\n      for (var node = parentNode.firstChild;\r\n           node; node = node.nextSibling) {\r\n\r\n        var nodeOwner;\r\n        if (node.$ui &&\r\n            (nodeOwner = node.$ui) &&\r\n            ((nodeOwner === this &&\r\n              node !== this.start &&\r\n              node !== this.end &&\r\n              isSignificantNode(node)) ||\r\n             (nodeOwner !== this &&\r\n              nodeOwner.owner === this &&\r\n              nodeOwner.start === node))) {\r\n          // found a member range or node\r\n          // (excluding \"insignificant\" empty text nodes,\r\n          // which won't be moved by, say, jQuery)\r\n          if (firstNode) {\r\n            // if we've already found a member in our\r\n            // scan, see if there are some easy ownerless\r\n            // nodes to \"adopt\" by scanning backwards.\r\n            for (var n = firstNode.previousSibling;\r\n                 n && ! n.$ui;\r\n                 n = n.previousSibling) {\r\n              this.members[this.nextMemberId++] = n;\r\n              // can't attach `$ui` to a TextNode in IE 8, so\r\n              // don't bother on any browser.\r\n              if (n.nodeType !== 3)\r\n                n.$ui = this;\r\n            }\r\n          }\r\n          if (node.$ui === this) {\r\n            // Node\r\n            firstNode = (firstNode || node);\r\n            lastNode = node;\r\n          } else {\r\n            // Range\r\n            // skip it and include its nodes in\r\n            // firstNode/lastNode.\r\n            firstNode = (firstNode || node);\r\n            node = node.$ui.end;\r\n            lastNode = node;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (firstNode) {\r\n      // some member or significant node was found.\r\n      // expand to include our insigificant member\r\n      // nodes as well.\r\n      for (var n;\r\n           (n = firstNode.previousSibling) &&\r\n           (n.$ui && n.$ui === this ||\r\n            _contains(textNodes, n));)\r\n        firstNode = n;\r\n      for (var n;\r\n           (n = lastNode.nextSibling) &&\r\n           (n.$ui && n.$ui === this ||\r\n            _contains(textNodes, n));)\r\n        lastNode = n;\r\n      // adjust our start/end pointers\r\n      if (firstNode !== this.start)\r\n        insertNode(this.start,\r\n                   parentNode, firstNode);\r\n      if (lastNode !== this.end)\r\n        insertNode(this.end, parentNode,\r\n                 lastNode.nextSibling);\r\n    }\r\n  },\r\n  getInsertionPoint: function (beforeId) {\r\n    var members = this.members;\r\n    var parentNode = this.parentNode();\r\n\r\n    if (! beforeId) {\r\n      // Refreshing here is necessary if we want to\r\n      // allow elements to move around arbitrarily.\r\n      // If jQuery is used to reorder elements, it could\r\n      // easily make our `end` pointer meaningless,\r\n      // even though all our members continue to make\r\n      // good reference points as long as they are refreshed.\r\n      //\r\n      // However, a refresh is expensive!  Let's\r\n      // make the developer manually refresh if\r\n      // elements are being re-ordered externally.\r\n      return this.end;\r\n    }\r\n\r\n    checkId(beforeId);\r\n    beforeId = ' ' + beforeId;\r\n    var mem = members[beforeId];\r\n\r\n    if (mem instanceof DomRange) {\r\n      // Range\r\n      var range = mem;\r\n      if (range.start.parentNode === parentNode) {\r\n        // still there\r\n        range.refresh();\r\n        return range.start;\r\n      } else {\r\n        range.owner = null;\r\n        rangeRemoved(range);\r\n      }\r\n    } else {\r\n      // Node\r\n      var node = mem;\r\n      if (node.parentNode === parentNode)\r\n        return node; // still there\r\n      else\r\n        nodeRemoved(node);\r\n    }\r\n\r\n    // not there anymore\r\n    delete members[beforeId];\r\n    // no good position\r\n    return this.end;\r\n  }\r\n});\r\n\r\nDomRange.prototype.elements = function (intoArray) {\r\n  intoArray = (intoArray || []);\r\n  this.eachMember(function (node) {\r\n    if (node.nodeType === 1)\r\n      intoArray.push(node);\r\n  }, function (range) {\r\n    range.elements(intoArray);\r\n  });\r\n  return intoArray;\r\n};\r\n\r\n// XXX alias the below as `UI.refresh` and `UI.insert`\r\n\r\n// In a real-life case where you need a refresh,\r\n// you probably don't have easy\r\n// access to the appropriate DomRange or component,\r\n// just the enclosing element:\r\n//\r\n// ```\r\n// {{#Sortable}}\r\n//   <div>\r\n//     {{#each}}\r\n//       ...\r\n// ```\r\n//\r\n// In this case, Sortable wants to call `refresh`\r\n// on the div, not the each, so it would use this function.\r\nDomRange.refresh = function (element) {\r\n  var comps = DomRange.getComponents(element);\r\n\r\n  for (var i = 0, N = comps.length; i < N; i++)\r\n    comps[i].refresh();\r\n};\r\n\r\nDomRange.getComponents = function (element) {\r\n  var topLevelComps = [];\r\n  for (var n = element.firstChild;\r\n       n; n = n.nextSibling) {\r\n    if (n.$ui && n === n.$ui.start &&\r\n        ! n.$ui.owner)\r\n      topLevelComps.push(n.$ui);\r\n  }\r\n  return topLevelComps;\r\n};\r\n\r\n// `parentNode` must be an ELEMENT, not a fragment\r\nDomRange.insert = function (range, parentNode, nextNode) {\r\n  var nodes = range.getNodes();\r\n  for (var i = 0; i < nodes.length; i++)\r\n    insertNode(nodes[i], parentNode, nextNode);\r\n  rangeParented(range);\r\n};\r\n\r\nDomRange.getContainingComponent = function (element) {\r\n  while (element && ! element.$ui)\r\n    element = element.parentNode;\r\n\r\n  var range = (element && element.$ui);\r\n\r\n  while (range) {\r\n    if (range.component)\r\n      return range.component;\r\n    range = range.owner;\r\n  }\r\n  return null;\r\n};\r\n\r\n///// FIND BY SELECTOR\r\n\r\nDomRange.prototype.contains = function (compOrNode) {\r\n  if (! compOrNode)\r\n    throw new Error(\"Expected Component or Node\");\r\n\r\n  var parentNode = this.parentNode();\r\n  if (! parentNode)\r\n    return false;\r\n\r\n  var range;\r\n  if (compOrNode instanceof DomRange) {\r\n    // Component\r\n    range = compOrNode;\r\n    var pn = range.parentNode();\r\n    if (! pn)\r\n      return false;\r\n    // If parentNode is different, it must be a node\r\n    // we contain.\r\n    if (pn !== parentNode)\r\n      return this.contains(pn);\r\n    if (range === this)\r\n      return false; // don't contain self\r\n    // Ok, `range` is a same-parent range to see if we\r\n    // contain.\r\n  } else {\r\n    // Node\r\n    var node = compOrNode;\r\n    if (! elementContains(parentNode, node))\r\n      return false;\r\n\r\n    while (node.parentNode !== parentNode)\r\n      node = node.parentNode;\r\n\r\n    range = node.$ui;\r\n  }\r\n\r\n  // Now see if `range` is truthy and either `this`\r\n  // or an immediate subrange\r\n\r\n  while (range && range !== this)\r\n    range = range.owner;\r\n\r\n  return range === this;\r\n};\r\n\r\nDomRange.prototype.$ = function (selector) {\r\n  var self = this;\r\n\r\n  var parentNode = this.parentNode();\r\n  if (! parentNode)\r\n    throw new Error(\"Can't select in removed DomRange\");\r\n\r\n  // Strategy: Find all selector matches under parentNode,\r\n  // then filter out the ones that aren't in this DomRange\r\n  // using upwards pointers ($ui, owner, parentNode).  This is\r\n  // asymptotically slow in the presence of O(N) sibling\r\n  // content that is under parentNode but not in our range,\r\n  // so if performance is an issue, the selector should be\r\n  // run on a child element.\r\n\r\n  // Since jQuery can't run selectors on a DocumentFragment,\r\n  // we don't expect findBySelector to work.\r\n  if (parentNode.nodeType === 11 /* DocumentFragment */ ||\r\n      parentNode.$_uiIsOffscreen)\r\n    throw new Error(\"Can't use $ on an offscreen component\");\r\n\r\n  var results = DomBackend.findBySelector(selector, parentNode);\r\n\r\n  // We don't assume `results` has jQuery API; a plain array\r\n  // should do just as well.  However, if we do have a jQuery\r\n  // array, we want to end up with one also, so we use\r\n  // `.filter`.\r\n\r\n\r\n  // Function that selects only elements that are actually\r\n  // in this DomRange, rather than simply descending from\r\n  // `parentNode`.\r\n  var filterFunc = function (elem) {\r\n    // handle jQuery's arguments to filter, where the node\r\n    // is in `this` and the index is the first argument.\r\n    if (typeof elem === 'number')\r\n      elem = this;\r\n\r\n    return self.contains(elem);\r\n  };\r\n\r\n  if (! results.filter) {\r\n    // not a jQuery array, and not a browser with\r\n    // Array.prototype.filter (e.g. IE <9)\r\n    var newResults = [];\r\n    for (var i = 0; i < results.length; i++) {\r\n      var x = results[i];\r\n      if (filterFunc(x))\r\n        newResults.push(x);\r\n    }\r\n    results = newResults;\r\n  } else {\r\n    // `results.filter` is either jQuery's or ECMAScript's `filter`\r\n    results = results.filter(filterFunc);\r\n  }\r\n\r\n  return results;\r\n};\r\n\r\n\r\n///// EVENTS\r\n\r\n// List of events to always delegate, never capture.\r\n// Since jQuery fakes bubbling for certain events in\r\n// certain browsers (like `submit`), we don't want to\r\n// get in its way.\r\n//\r\n// We could list all known bubbling\r\n// events here to avoid creating speculative capturers\r\n// for them, but it would only be an optimization.\r\nvar eventsToDelegate = {\r\n  blur: 1, change: 1, click: 1, focus: 1, focusin: 1,\r\n  focusout: 1, reset: 1, submit: 1\r\n};\r\n\r\nvar EVENT_MODE_TBD = 0;\r\nvar EVENT_MODE_BUBBLING = 1;\r\nvar EVENT_MODE_CAPTURING = 2;\r\n\r\nvar HandlerRec = function (elem, type, selector, handler, $ui) {\r\n  this.elem = elem;\r\n  this.type = type;\r\n  this.selector = selector;\r\n  this.handler = handler;\r\n  this.$ui = $ui;\r\n\r\n  this.mode = EVENT_MODE_TBD;\r\n\r\n  // It's important that delegatedHandler be a different\r\n  // instance for each handlerRecord, because its identity\r\n  // is used to remove it.\r\n  //\r\n  // It's also important that the closure have access to\r\n  // `this` when it is not called with it set.\r\n  this.delegatedHandler = (function (h) {\r\n    return function (evt) {\r\n      if ((! h.selector) && evt.currentTarget !== evt.target)\r\n        // no selector means only fire on target\r\n        return;\r\n      if (! h.$ui.contains(evt.currentTarget))\r\n        return;\r\n      return h.handler.apply(h.$ui, arguments);\r\n    };\r\n  })(this);\r\n\r\n  // WHY CAPTURE AND DELEGATE: jQuery can't delegate\r\n  // non-bubbling events, because\r\n  // event capture doesn't work in IE 8.  However, there\r\n  // are all sorts of new-fangled non-bubbling events\r\n  // like \"play\" and \"touchenter\".  We delegate these\r\n  // events using capture in all browsers except IE 8.\r\n  // IE 8 doesn't support these events anyway.\r\n\r\n  var tryCapturing = elem.addEventListener &&\r\n        (! eventsToDelegate.hasOwnProperty(\r\n          DomBackend.parseEventType(type)));\r\n\r\n  if (tryCapturing) {\r\n    this.capturingHandler = (function (h) {\r\n      return function (evt) {\r\n        if (h.mode === EVENT_MODE_TBD) {\r\n          // must be first time we're called.\r\n          if (evt.bubbles) {\r\n            // this type of event bubbles, so don't\r\n            // get called again.\r\n            h.mode = EVENT_MODE_BUBBLING;\r\n            DomBackend.unbindEventCapturer(\r\n              h.elem, h.type, h.capturingHandler);\r\n            return;\r\n          } else {\r\n            // this type of event doesn't bubble,\r\n            // so unbind the delegation, preventing\r\n            // it from ever firing.\r\n            h.mode = EVENT_MODE_CAPTURING;\r\n            DomBackend.undelegateEvents(\r\n              h.elem, h.type, h.delegatedHandler);\r\n          }\r\n        }\r\n\r\n        h.delegatedHandler(evt);\r\n      };\r\n    })(this);\r\n\r\n  } else {\r\n    this.mode = EVENT_MODE_BUBBLING;\r\n  }\r\n};\r\n\r\nHandlerRec.prototype.bind = function () {\r\n  // `this.mode` may be EVENT_MODE_TBD, in which case we bind both. in\r\n  // this case, 'capturingHandler' is in charge of detecting the\r\n  // correct mode and turning off one or the other handlers.\r\n  if (this.mode !== EVENT_MODE_BUBBLING) {\r\n    DomBackend.bindEventCapturer(\r\n      this.elem, this.type, this.selector || '*',\r\n      this.capturingHandler);\r\n  }\r\n\r\n  if (this.mode !== EVENT_MODE_CAPTURING)\r\n    DomBackend.delegateEvents(\r\n      this.elem, this.type,\r\n      this.selector || '*', this.delegatedHandler);\r\n};\r\n\r\nHandlerRec.prototype.unbind = function () {\r\n  if (this.mode !== EVENT_MODE_BUBBLING)\r\n    DomBackend.unbindEventCapturer(this.elem, this.type,\r\n                                   this.capturingHandler);\r\n\r\n  if (this.mode !== EVENT_MODE_CAPTURING)\r\n    DomBackend.undelegateEvents(this.elem, this.type,\r\n                                this.delegatedHandler);\r\n};\r\n\r\n\r\n// XXX could write the form of arguments for this function\r\n// in several different ways, including simply as an event map.\r\nDomRange.prototype.on = function (events, selector, handler) {\r\n  var parentNode = this.parentNode();\r\n  if (! parentNode)\r\n    // if we're not in the DOM, silently fail.\r\n    return;\r\n  // haven't been added yet; error\r\n  if (parentNode.$_uiIsOffscreen)\r\n    throw new Error(\"Can't bind events before DomRange is inserted\");\r\n\r\n  var eventTypes = [];\r\n  events.replace(/[^ /]+/g, function (e) {\r\n    eventTypes.push(e);\r\n  });\r\n\r\n  if (! handler && (typeof selector === 'function')) {\r\n    // omitted `selector`\r\n    handler = selector;\r\n    selector = null;\r\n  } else if (! selector) {\r\n    // take `\"\"` to `null`\r\n    selector = null;\r\n  }\r\n\r\n  for (var i = 0, N = eventTypes.length; i < N; i++) {\r\n    var type = eventTypes[i];\r\n\r\n    var eventDict = parentNode.$_uievents;\r\n    if (! eventDict)\r\n      eventDict = (parentNode.$_uievents = {});\r\n\r\n    var info = eventDict[type];\r\n    if (! info) {\r\n      info = eventDict[type] = {};\r\n      info.handlers = [];\r\n    }\r\n    var handlerList = info.handlers;\r\n    var handlerRec = new HandlerRec(\r\n      parentNode, type, selector, handler, this);\r\n    handlerRec.bind();\r\n    handlerList.push(handlerRec);\r\n    // move handlers of enclosing ranges to end\r\n    for (var r = this.owner; r; r = r.owner) {\r\n      // r is an enclosing DomRange\r\n      for (var j = 0, Nj = handlerList.length;\r\n           j < Nj; j++) {\r\n        var h = handlerList[j];\r\n        if (h.$ui === r) {\r\n          h.unbind();\r\n          h.bind();\r\n          handlerList.splice(j, 1); // remove handlerList[j]\r\n          handlerList.push(h);\r\n          j--; // account for removed handler\r\n          Nj--; // don't visit appended handlers\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n  // Returns true if element a contains node b and is not node b.\r\n  var elementContains = function (a, b) {\r\n    if (a.nodeType !== 1) // ELEMENT\r\n      return false;\r\n    if (a === b)\r\n      return false;\r\n\r\n    if (a.compareDocumentPosition) {\r\n      return a.compareDocumentPosition(b) & 0x10;\r\n    } else {\r\n          // Should be only old IE and maybe other old browsers here.\r\n          // Modern Safari has both functions but seems to get contains() wrong.\r\n          // IE can't handle b being a text node.  We work around this\r\n          // by doing a direct parent test now.\r\n      b = b.parentNode;\r\n      if (! (b && b.nodeType === 1)) // ELEMENT\r\n        return false;\r\n      if (a === b)\r\n        return true;\r\n\r\n      return a.contains(b);\r\n    }\r\n  };\r\n\r\n\r\nUI.DomRange = DomRange;\r\n","\r\n// An AttributeHandler object is responsible for updating a particular attribute\r\n// of a particular element.  AttributeHandler subclasses implement\r\n// browser-specific logic for dealing with particular attributes across\r\n// different browsers.\r\n//\r\n// To define a new type of AttributeHandler, use\r\n// `var FooHandler = AttributeHandler.extend({ update: function ... })`\r\n// where the `update` function takes arguments `(element, oldValue, value)`.\r\n// The `element` argument is always the same between calls to `update` on\r\n// the same instance.  `oldValue` and `value` are each either `null` or\r\n// a Unicode string of the type that might be passed to the value argument\r\n// of `setAttribute` (i.e. not an HTML string with character references).\r\n// When an AttributeHandler is installed, an initial call to `update` is\r\n// always made with `oldValue = null`.  The `update` method can access\r\n// `this.name` if the AttributeHandler class is a generic one that applies\r\n// to multiple attribute names.\r\n//\r\n// AttributeHandlers can store custom properties on `this`, as long as they\r\n// don't use the names `element`, `name`, `value`, and `oldValue`.\r\n//\r\n// AttributeHandlers can't influence how attributes appear in rendered HTML,\r\n// only how they are updated after materialization as DOM.\r\n\r\nAttributeHandler = function (name, value) {\r\n  this.name = name;\r\n  this.value = value;\r\n};\r\n\r\nAttributeHandler.prototype.update = function (element, oldValue, value) {\r\n  if (value === null) {\r\n    if (oldValue !== null)\r\n      element.removeAttribute(this.name);\r\n  } else {\r\n    element.setAttribute(this.name, value);\r\n  }\r\n};\r\n\r\nAttributeHandler.extend = function (options) {\r\n  var curType = this;\r\n  var subType = function AttributeHandlerSubtype(/*arguments*/) {\r\n    AttributeHandler.apply(this, arguments);\r\n  };\r\n  subType.prototype = new curType;\r\n  subType.extend = curType.extend;\r\n  if (options)\r\n    _.extend(subType.prototype, options);\r\n  return subType;\r\n};\r\n\r\n// Extended below to support both regular and SVG elements\r\nvar BaseClassHandler = AttributeHandler.extend({\r\n  update: function (element, oldValue, value) {\r\n    if (!this.getCurrentValue || !this.setValue)\r\n      throw new Error(\"Missing methods in subclass of 'BaseClassHandler'\");\r\n\r\n    var oldClasses = oldValue ? _.compact(oldValue.split(' ')) : [];\r\n    var newClasses = value ? _.compact(value.split(' ')) : [];\r\n\r\n    // the current classes on the element, which we will mutate.\r\n    var classes = _.compact(this.getCurrentValue(element).split(' '));\r\n\r\n    // optimize this later (to be asymptotically faster) if necessary\r\n    for (var i = 0; i < oldClasses.length; i++) {\r\n      var c = oldClasses[i];\r\n      if (! _.contains(newClasses, c))\r\n        classes = _.without(classes, c);\r\n    }\r\n    for (var i = 0; i < newClasses.length; i++) {\r\n      var c = newClasses[i];\r\n      if ((! _.contains(oldClasses, c)) &&\r\n          (! _.contains(classes, c)))\r\n        classes.push(c);\r\n    }\r\n\r\n    this.setValue(element, classes.join(' '));\r\n  }\r\n});\r\n\r\nvar ClassHandler = BaseClassHandler.extend({\r\n  // @param rawValue {String}\r\n  getCurrentValue: function (element) {\r\n    return element.className;\r\n  },\r\n  setValue: function (element, className) {\r\n    element.className = className;\r\n  }\r\n});\r\n\r\nvar SVGClassHandler = BaseClassHandler.extend({\r\n  getCurrentValue: function (element) {\r\n    return element.className.baseVal;\r\n  },\r\n  setValue: function (element, className) {\r\n    element.setAttribute('class', className);\r\n  }\r\n});\r\n\r\nvar BooleanHandler = AttributeHandler.extend({\r\n  update: function (element, oldValue, value) {\r\n    var focused = this.focused(element);\r\n\r\n    if (!focused) {\r\n      var name = this.name;\r\n      if (value == null) {\r\n        if (oldValue != null)\r\n          element[name] = false;\r\n      } else {\r\n        element[name] = true;\r\n      }\r\n    }\r\n  },\r\n  // is the element part of a control which is focused?\r\n  focused: function (element) {\r\n    if (element.tagName === 'INPUT') {\r\n      return element === document.activeElement;\r\n\r\n    } else if (element.tagName === 'OPTION') {\r\n      // find the containing SELECT element, on which focus\r\n      // is actually set\r\n      var selectEl = element;\r\n      while (selectEl && selectEl.tagName !== 'SELECT')\r\n        selectEl = selectEl.parentNode;\r\n\r\n      if (selectEl)\r\n        return selectEl === document.activeElement;\r\n      else\r\n        return false;\r\n    } else {\r\n      throw new Error(\"Expected INPUT or OPTION element\");\r\n    }\r\n  }\r\n});\r\n\r\nvar ValueHandler = AttributeHandler.extend({\r\n  update: function (element, oldValue, value) {\r\n    var focused = (element === document.activeElement);\r\n\r\n    if (!focused)\r\n      element.value = value;\r\n  }\r\n});\r\n\r\n// attributes of the type 'xlink:something' should be set using\r\n// the correct namespace in order to work\r\nvar XlinkHandler = AttributeHandler.extend({\r\n  update: function(element, oldValue, value) {\r\n    var NS = 'http://www.w3.org/1999/xlink';\r\n    if (value === null) {\r\n      if (oldValue !== null)\r\n        element.removeAttributeNS(NS, this.name);\r\n    } else {\r\n      element.setAttributeNS(NS, this.name, this.value);\r\n    }\r\n  }\r\n});\r\n\r\n// cross-browser version of `instanceof SVGElement`\r\nvar isSVGElement = function (elem) {\r\n  return 'ownerSVGElement' in elem;\r\n};\r\n\r\nvar isUrlAttribute = function (tagName, attrName) {\r\n  // Compiled from http://www.w3.org/TR/REC-html40/index/attributes.html\r\n  // and\r\n  // http://www.w3.org/html/wg/drafts/html/master/index.html#attributes-1\r\n  var urlAttrs = {\r\n    FORM: ['action'],\r\n    BODY: ['background'],\r\n    BLOCKQUOTE: ['cite'],\r\n    Q: ['cite'],\r\n    DEL: ['cite'],\r\n    INS: ['cite'],\r\n    OBJECT: ['classid', 'codebase', 'data', 'usemap'],\r\n    APPLET: ['codebase'],\r\n    A: ['href'],\r\n    AREA: ['href'],\r\n    LINK: ['href'],\r\n    BASE: ['href'],\r\n    IMG: ['longdesc', 'src', 'usemap'],\r\n    FRAME: ['longdesc', 'src'],\r\n    IFRAME: ['longdesc', 'src'],\r\n    HEAD: ['profile'],\r\n    SCRIPT: ['src'],\r\n    INPUT: ['src', 'usemap', 'formaction'],\r\n    BUTTON: ['formaction'],\r\n    BASE: ['href'],\r\n    MENUITEM: ['icon'],\r\n    HTML: ['manifest'],\r\n    VIDEO: ['poster']\r\n  };\r\n\r\n  if (attrName === 'itemid') {\r\n    return true;\r\n  }\r\n\r\n  var urlAttrNames = urlAttrs[tagName] || [];\r\n  return _.contains(urlAttrNames, attrName);\r\n};\r\n\r\n// To get the protocol for a URL, we let the browser normalize it for\r\n// us, by setting it as the href for an anchor tag and then reading out\r\n// the 'protocol' property.\r\nif (Meteor.isClient) {\r\n  var anchorForNormalization = document.createElement('A');\r\n}\r\n\r\nvar normalizeUrl = function (url) {\r\n  if (Meteor.isClient) {\r\n    anchorForNormalization.href = url;\r\n    return anchorForNormalization.href;\r\n  } else {\r\n    throw new Error('normalizeUrl not implemented on the server');\r\n  }\r\n};\r\n\r\n// UrlHandler is an attribute handler for all HTML attributes that take\r\n// URL values. It disallows javascript: URLs, unless\r\n// UI._allowJavascriptUrls() has been called. To detect javascript:\r\n// urls, we set the attribute and then reads the attribute out of the\r\n// DOM, in order to avoid writing our own URL normalization code. (We\r\n// don't want to be fooled by ' javascript:alert(1)' or\r\n// 'jAvAsCrIpT:alert(1)'.) In future, when the URL interface is more\r\n// widely supported, we can use that, which will be\r\n// cleaner.  https://developer.mozilla.org/en-US/docs/Web/API/URL\r\nvar origUpdate = AttributeHandler.prototype.update;\r\nvar UrlHandler = AttributeHandler.extend({\r\n  update: function (element, oldValue, value) {\r\n    var self = this;\r\n    var args = arguments;\r\n\r\n    if (UI._javascriptUrlsAllowed()) {\r\n      origUpdate.apply(self, args);\r\n    } else {\r\n      var isJavascriptProtocol =\r\n            (normalizeUrl(value).indexOf('javascript:') === 0);\r\n      if (isJavascriptProtocol) {\r\n        Meteor._debug(\"URLs that use the 'javascript:' protocol are not \" +\r\n                      \"allowed in URL attribute values. \" +\r\n                      \"Call UI._allowJavascriptUrls() \" +\r\n                      \"to enable them.\");\r\n        origUpdate.apply(self, [element, oldValue, null]);\r\n      } else {\r\n        origUpdate.apply(self, args);\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\n// XXX make it possible for users to register attribute handlers!\r\nmakeAttributeHandler = function (elem, name, value) {\r\n  // generally, use setAttribute but certain attributes need to be set\r\n  // by directly setting a JavaScript property on the DOM element.\r\n  if (name === 'class') {\r\n    if (isSVGElement(elem)) {\r\n      return new SVGClassHandler(name, value);\r\n    } else {\r\n      return new ClassHandler(name, value);\r\n    }\r\n  } else if ((elem.tagName === 'OPTION' && name === 'selected') ||\r\n             (elem.tagName === 'INPUT' && name === 'checked')) {\r\n    return new BooleanHandler(name, value);\r\n  } else if ((elem.tagName === 'TEXTAREA' || elem.tagName === 'INPUT')\r\n             && name === 'value') {\r\n    // internally, TEXTAREAs tracks their value in the 'value'\r\n    // attribute just like INPUTs.\r\n    return new ValueHandler(name, value);\r\n  } else if (name.substring(0,6) === 'xlink:') {\r\n    return new XlinkHandler(name.substring(6), value);\r\n  } else if (isUrlAttribute(elem.tagName, name)) {\r\n    return new UrlHandler(name, value);\r\n  } else {\r\n    return new AttributeHandler(name, value);\r\n  }\r\n\r\n  // XXX will need one for 'style' on IE, though modern browsers\r\n  // seem to handle setAttribute ok.\r\n};\r\n\r\n\r\nElementAttributesUpdater = function (elem) {\r\n  this.elem = elem;\r\n  this.handlers = {};\r\n};\r\n\r\n// Update attributes on `elem` to the dictionary `attrs`, whose\r\n// values are strings.\r\nElementAttributesUpdater.prototype.update = function(newAttrs) {\r\n  var elem = this.elem;\r\n  var handlers = this.handlers;\r\n\r\n  for (var k in handlers) {\r\n    if (! newAttrs.hasOwnProperty(k)) {\r\n      // remove attributes (and handlers) for attribute names\r\n      // that don't exist as keys of `newAttrs` and so won't\r\n      // be visited when traversing it.  (Attributes that\r\n      // exist in the `newAttrs` object but are `null`\r\n      // are handled later.)\r\n      var handler = handlers[k];\r\n      var oldValue = handler.value;\r\n      handler.value = null;\r\n      handler.update(elem, oldValue, null);\r\n      delete handlers[k];\r\n    }\r\n  }\r\n\r\n  for (var k in newAttrs) {\r\n    var handler = null;\r\n    var oldValue;\r\n    var value = newAttrs[k];\r\n    if (! handlers.hasOwnProperty(k)) {\r\n      if (value !== null) {\r\n        // make new handler\r\n        handler = makeAttributeHandler(elem, k, value);\r\n        handlers[k] = handler;\r\n        oldValue = null;\r\n      }\r\n    } else {\r\n      handler = handlers[k];\r\n      oldValue = handler.value;\r\n    }\r\n    if (oldValue !== value) {\r\n      handler.value = value;\r\n      handler.update(elem, oldValue, value);\r\n      if (value === null)\r\n        delete handlers[k];\r\n    }\r\n  }\r\n};\r\n","\r\nUI.Component.instantiate = function (parent) {\r\n  var kind = this;\r\n\r\n  // check arguments\r\n  if (UI.isComponent(kind)) {\r\n    if (kind.isInited)\r\n      throw new Error(\"A component kind is required, not an instance\");\r\n  } else {\r\n    throw new Error(\"Expected Component kind\");\r\n  }\r\n\r\n  var inst = kind.extend(); // XXX args go here\r\n  inst.isInited = true;\r\n\r\n  // XXX messy to define this here\r\n  inst.templateInstance = {\r\n    findAll: function (selector) {\r\n      // XXX check that `.dom` exists here?\r\n      return inst.dom.$(selector);\r\n    },\r\n    find: function (selector) {\r\n      var result = this.findAll(selector);\r\n      return result[0] || null;\r\n    },\r\n    firstNode: null,\r\n    lastNode: null,\r\n    data: null,\r\n    __component__: inst\r\n  };\r\n  inst.templateInstance.$ = inst.templateInstance.findAll;\r\n\r\n  inst.parent = (parent || null);\r\n\r\n  if (inst.init)\r\n    inst.init();\r\n\r\n  if (inst.created) {\r\n    updateTemplateInstance(inst);\r\n    inst.created.call(inst.templateInstance);\r\n  }\r\n\r\n  return inst;\r\n};\r\n\r\nUI.Component.render = function () {\r\n  return null;\r\n};\r\n\r\nvar Box = function (func, equals) {\r\n  var self = this;\r\n\r\n  self.func = func;\r\n  self.equals = equals;\r\n\r\n  self.curResult = null;\r\n\r\n  self.dep = new Deps.Dependency;\r\n\r\n  self.resultComputation = Deps.nonreactive(function () {\r\n    return Deps.autorun(function (c) {\r\n      var func = self.func;\r\n\r\n      var newResult = func();\r\n\r\n      if (! c.firstRun) {\r\n        var equals = self.equals;\r\n        var oldResult = self.curResult;\r\n\r\n        if (equals ? equals(newResult, oldResult) :\r\n            newResult === oldResult) {\r\n          // same as last time\r\n          return;\r\n        }\r\n      }\r\n\r\n      self.curResult = newResult;\r\n      self.dep.changed();\r\n    });\r\n  });\r\n};\r\n\r\nBox.prototype.stop = function () {\r\n  this.resultComputation.stop();\r\n};\r\n\r\nBox.prototype.get = function () {\r\n  if (Deps.active && ! this.resultComputation.stopped)\r\n    this.dep.depend();\r\n\r\n  return this.curResult;\r\n};\r\n\r\n// Takes a reactive function (call it `inner`) and returns a reactive function\r\n// `outer` which is equivalent except in its reactive behavior.  Specifically,\r\n// `outer` has the following two special properties:\r\n//\r\n// 1. Isolation:  An invocation of `outer()` only invalidates its context\r\n//    when the value of `inner()` changes.  For example, `inner` may be a\r\n//    function that gets one or more Session variables and calculates a\r\n//    true/false value.  `outer` blocks invalidation signals caused by the\r\n//    Session variables changing and sends a signal out only when the value\r\n//    changes between true and false (in this example).  The value can be\r\n//    of any type, and it is compared with `===` unless an `equals` function\r\n//    is provided.\r\n//\r\n// 2. Value Sharing:  The `outer` function returned by `emboxValue` can be\r\n//    shared between different contexts, for example by assigning it to an\r\n//    object as a method that can be accessed at any time, such as by\r\n//    different templates or different parts of a template.  No matter\r\n//    how many times `outer` is called, `inner` is only called once until\r\n//    it changes.  The most recent value is stored internally.\r\n//\r\n// Conceptually, an emboxed value is much like a Session variable which is\r\n// kept up to date by an autorun.  Session variables provide storage\r\n// (value sharing) and they don't notify their listeners unless a value\r\n// actually changes (isolation).  The biggest difference is that such an\r\n// autorun would never be stopped, and the Session variable would never be\r\n// deleted even if it wasn't used any more.  An emboxed value, on the other\r\n// hand, automatically stops computing when it's not being used, and starts\r\n// again when called from a reactive context.  This means that when it stops\r\n// being used, it can be completely garbage-collected.\r\n//\r\n// If a non-function value is supplied to `emboxValue` instead of a reactive\r\n// function, then `outer` is still a function but it simply returns the value.\r\n//\r\nUI.emboxValue = function (funcOrValue, equals) {\r\n  if (typeof funcOrValue === 'function') {\r\n\r\n    var func = funcOrValue;\r\n    var box = new Box(func, equals);\r\n\r\n    var f = function () {\r\n      return box.get();\r\n    };\r\n\r\n    f.stop = function () {\r\n      box.stop();\r\n    };\r\n\r\n    return f;\r\n\r\n  } else {\r\n    var value = funcOrValue;\r\n    var result = function () {\r\n      return value;\r\n    };\r\n    result._isEmboxedConstant = true;\r\n    return result;\r\n  }\r\n};\r\n\r\n\r\nUI.namedEmboxValue = function (name, funcOrValue, equals) {\r\n  if (! Deps.active) {\r\n    var f = UI.emboxValue(funcOrValue, equals);\r\n    f.stop();\r\n    return f;\r\n  }\r\n\r\n  var c = Deps.currentComputation;\r\n  if (! c[name])\r\n    c[name] = UI.emboxValue(funcOrValue, equals);\r\n\r\n  return c[name];\r\n};\r\n\r\n////////////////////////////////////////\r\n\r\nUI.insert = function (renderedTemplate, parentElement, nextNode) {\r\n  if (! renderedTemplate.dom)\r\n    throw new Error(\"Expected template rendered with UI.render\");\r\n\r\n  UI.DomRange.insert(renderedTemplate.dom, parentElement, nextNode);\r\n};\r\n\r\n// Insert a DOM node or DomRange into a DOM element or DomRange.\r\n//\r\n// One of three things happens depending on what needs to be inserted into what:\r\n// - `range.add` (anything into DomRange)\r\n// - `UI.DomRange.insert` (DomRange into element)\r\n// - `elem.insertBefore` (node into element)\r\n//\r\n// The optional `before` argument is an existing node or id to insert before in\r\n// the parent element or DomRange.\r\nvar insert = function (nodeOrRange, parent, before) {\r\n  if (! parent)\r\n    throw new Error(\"Materialization parent required\");\r\n\r\n  if (parent instanceof UI.DomRange) {\r\n    parent.add(nodeOrRange, before);\r\n  } else if (nodeOrRange instanceof UI.DomRange) {\r\n    // parent is an element; inserting a range\r\n    UI.DomRange.insert(nodeOrRange, parent, before);\r\n  } else {\r\n    // parent is an element; inserting an element\r\n    parent.insertBefore(nodeOrRange, before || null); // `null` for IE\r\n  }\r\n};\r\n\r\nUI.render = function (kind, parentComponent) {\r\n  if (kind.isInited)\r\n    throw new Error(\"Can't render component instance, only component kind\");\r\n\r\n  var inst, content, range;\r\n\r\n  Deps.nonreactive(function () {\r\n\r\n    inst = kind.instantiate(parentComponent);\r\n\r\n    content = (inst.render && inst.render());\r\n\r\n    range = new UI.DomRange;\r\n    inst.dom = range;\r\n    range.component = inst;\r\n\r\n  });\r\n\r\n  materialize(content, range, null, inst);\r\n\r\n  range.removed = function () {\r\n    inst.isDestroyed = true;\r\n    if (inst.destroyed) {\r\n      Deps.nonreactive(function () {\r\n        updateTemplateInstance(inst);\r\n        inst.destroyed.call(inst.templateInstance);\r\n      });\r\n    }\r\n  };\r\n\r\n  return inst;\r\n};\r\n\r\nUI.renderWithData = function (kind, data, parentComponent) {\r\n  if (! UI.isComponent(kind))\r\n    throw new Error(\"Component required here\");\r\n  if (kind.isInited)\r\n    throw new Error(\"Can't render component instance, only component kind\");\r\n  if (typeof data === 'function')\r\n    throw new Error(\"Data argument can't be a function\");\r\n\r\n  return UI.render(kind.extend({data: function () { return data; }}),\r\n                   parentComponent);\r\n};\r\n\r\nvar contentEquals = function (a, b) {\r\n  if (a instanceof HTML.Raw) {\r\n    return (b instanceof HTML.Raw) && (a.value === b.value);\r\n  } else if (a == null) {\r\n    return (b == null);\r\n  } else {\r\n    return (a === b) &&\r\n      ((typeof a === 'number') || (typeof a === 'boolean') ||\r\n       (typeof a === 'string'));\r\n  }\r\n};\r\n\r\nUI.InTemplateScope = function (tmplInstance, content) {\r\n  if (! (this instanceof UI.InTemplateScope))\r\n    // called without `new`\r\n    return new UI.InTemplateScope(tmplInstance, content);\r\n\r\n  var parentPtr = tmplInstance.parent;\r\n  if (parentPtr.__isTemplateWith)\r\n    parentPtr = parentPtr.parent;\r\n\r\n  this.parentPtr = parentPtr;\r\n  this.content = content;\r\n};\r\n\r\nUI.InTemplateScope.prototype.toHTML = function (parentComponent) {\r\n  return HTML.toHTML(this.content, this.parentPtr);\r\n};\r\n\r\nUI.InTemplateScope.prototype.toText = function (textMode, parentComponent) {\r\n  return HTML.toText(this.content, textMode, this.parentPtr);\r\n};\r\n\r\n// Convert the pseudoDOM `node` into reactive DOM nodes and insert them\r\n// into the element or DomRange `parent`, before the node or id `before`.\r\nvar materialize = function (node, parent, before, parentComponent) {\r\n  // XXX should do more error-checking for the case where user is supplying the tags.\r\n  // For example, check that CharRef has `html` and `str` properties and no content.\r\n  // Check that Comment has a single string child and no attributes.  Etc.\r\n\r\n  if (node == null) {\r\n    // null or undefined.\r\n    // do nothinge.\r\n  } else if ((typeof node === 'string') || (typeof node === 'boolean') || (typeof node === 'number')) {\r\n    node = String(node);\r\n    insert(document.createTextNode(node), parent, before);\r\n  } else if (node instanceof Array) {\r\n    for (var i = 0; i < node.length; i++)\r\n      materialize(node[i], parent, before, parentComponent);\r\n  } else if (typeof node === 'function') {\r\n\r\n    var range = new UI.DomRange;\r\n    var lastContent = null;\r\n    var rangeUpdater = Deps.autorun(function (c) {\r\n      var content = node();\r\n      // normalize content a little, for easier comparison\r\n      if (HTML.isNully(content))\r\n        content = null;\r\n      else if ((content instanceof Array) && content.length === 1)\r\n        content = content[0];\r\n\r\n      // update if content is different from last time\r\n      if (! contentEquals(content, lastContent)) {\r\n        lastContent = content;\r\n\r\n        if (! c.firstRun)\r\n          range.removeAll();\r\n\r\n        materialize(content, range, null, parentComponent);\r\n      }\r\n    });\r\n    range.removed = function () {\r\n      rangeUpdater.stop();\r\n      if (node.stop)\r\n        node.stop();\r\n    };\r\n    // XXXX HACK\r\n    if (Deps.active && node.stop) {\r\n      Deps.onInvalidate(function () {\r\n        node.stop();\r\n      });\r\n    }\r\n    insert(range, parent, before);\r\n  } else if (node instanceof HTML.Tag) {\r\n    var tagName = node.tagName;\r\n    var elem;\r\n    if (HTML.isKnownSVGElement(tagName) && document.createElementNS) {\r\n      elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);\r\n    } else {\r\n      elem = document.createElement(node.tagName);\r\n    }\r\n\r\n    var rawAttrs = node.attrs;\r\n    var children = node.children;\r\n    if (node.tagName === 'textarea') {\r\n      rawAttrs = (rawAttrs || {});\r\n      rawAttrs.value = children;\r\n      children = [];\r\n    };\r\n\r\n    if (rawAttrs) {\r\n      var attrComp = Deps.autorun(function (c) {\r\n        var attrUpdater = c.updater;\r\n        if (! attrUpdater) {\r\n          attrUpdater = c.updater = new ElementAttributesUpdater(elem);\r\n        }\r\n\r\n        try {\r\n          var attrs = HTML.evaluateAttributes(rawAttrs, parentComponent);\r\n          var stringAttrs = {};\r\n          if (attrs) {\r\n            for (var k in attrs) {\r\n              stringAttrs[k] = HTML.toText(attrs[k], HTML.TEXTMODE.STRING,\r\n                                           parentComponent);\r\n            }\r\n            attrUpdater.update(stringAttrs);\r\n          }\r\n        } catch (e) {\r\n          reportUIException(e);\r\n        }\r\n      });\r\n      UI.DomBackend.onRemoveElement(elem, function () {\r\n        attrComp.stop();\r\n      });\r\n    }\r\n    materialize(children, elem, null, parentComponent);\r\n\r\n    insert(elem, parent, before);\r\n  } else if (typeof node.instantiate === 'function') {\r\n    // component\r\n    var instance = UI.render(node, parentComponent);\r\n\r\n    // Call internal callback, which may take advantage of the current\r\n    // Deps computation.\r\n    if (instance.materialized)\r\n      instance.materialized();\r\n\r\n    insert(instance.dom, parent, before);\r\n  } else if (node instanceof HTML.CharRef) {\r\n    insert(document.createTextNode(node.str), parent, before);\r\n  } else if (node instanceof HTML.Comment) {\r\n    insert(document.createComment(node.sanitizedValue), parent, before);\r\n  } else if (node instanceof HTML.Raw) {\r\n    // Get an array of DOM nodes by using the browser's HTML parser\r\n    // (like innerHTML).\r\n    var htmlNodes = UI.DomBackend.parseHTML(node.value);\r\n    for (var i = 0; i < htmlNodes.length; i++)\r\n      insert(htmlNodes[i], parent, before);\r\n  } else if (Package['html-tools'] && (node instanceof Package['html-tools'].HTMLTools.Special)) {\r\n    throw new Error(\"Can't materialize Special tag, it's just an intermediate rep\");\r\n  } else if (node instanceof UI.InTemplateScope) {\r\n    materialize(node.content, parent, before, node.parentPtr);\r\n  } else {\r\n    // can't get here\r\n    throw new Error(\"Unexpected node in htmljs: \" + node);\r\n  }\r\n};\r\n\r\n\r\n\r\n// XXX figure out the right names, and namespace, for these.\r\n// for example, maybe some of them go in the HTML package.\r\nUI.materialize = materialize;\r\n\r\nUI.body = UI.Component.extend({\r\n  kind: 'body',\r\n  contentParts: [],\r\n  render: function () {\r\n    return this.contentParts;\r\n  },\r\n  // XXX revisit how body works.\r\n  INSTANTIATED: false,\r\n  __helperHost: true\r\n});\r\n\r\nUI.block = function (renderFunc) {\r\n  return UI.Component.extend({ render: renderFunc });\r\n};\r\n\r\nUI.toHTML = function (content, parentComponent) {\r\n  return HTML.toHTML(content, parentComponent);\r\n};\r\n\r\nUI.toRawText = function (content, parentComponent) {\r\n  return HTML.toText(content, HTML.TEXTMODE.STRING, parentComponent);\r\n};\r\n","\r\nUI.If = function (argFunc, contentBlock, elseContentBlock) {\r\n  checkBlockHelperArguments('If', argFunc, contentBlock, elseContentBlock);\r\n\r\n  var f = function () {\r\n    var emboxedCondition = emboxCondition(argFunc);\r\n    f.stop = function () {\r\n      emboxedCondition.stop();\r\n    };\r\n    if (emboxedCondition())\r\n      return contentBlock;\r\n    else\r\n      return elseContentBlock || null;\r\n  };\r\n\r\n  return f;\r\n};\r\n\r\n\r\nUI.Unless = function (argFunc, contentBlock, elseContentBlock) {\r\n  checkBlockHelperArguments('Unless', argFunc, contentBlock, elseContentBlock);\r\n\r\n  var f = function () {\r\n    var emboxedCondition = emboxCondition(argFunc);\r\n    f.stop = function () {\r\n      emboxedCondition.stop();\r\n    };\r\n    if (! emboxedCondition())\r\n      return contentBlock;\r\n    else\r\n      return elseContentBlock || null;\r\n  };\r\n\r\n  return f;\r\n};\r\n\r\n// Returns true if `a` and `b` are `===`, unless they are of a mutable type.\r\n// (Because then, they may be equal references to an object that was mutated,\r\n// and we'll never know.  We save only a reference to the old object; we don't\r\n// do any deep-copying or diffing.)\r\nUI.safeEquals = function (a, b) {\r\n  if (a !== b)\r\n    return false;\r\n  else\r\n    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||\r\n            (typeof a === 'string'));\r\n};\r\n\r\n// Unlike Spacebars.With, there's no else case and no conditional logic.\r\n//\r\n// We don't do any reactive emboxing of `argFunc` here; it should be done\r\n// by the caller if efficiency and/or number of calls to the data source\r\n// is important.\r\nUI.With = function (argFunc, contentBlock) {\r\n  checkBlockHelperArguments('With', argFunc, contentBlock);\r\n\r\n  var block = contentBlock;\r\n  if ('data' in block) {\r\n    // XXX TODO: get religion about where `data` property goes\r\n    block = UI.block(function () {\r\n      return contentBlock;\r\n    });\r\n  }\r\n\r\n  block.data = function () {\r\n    throw new Error(\"Can't get data for component kind\");\r\n  };\r\n\r\n  block.init = function () {\r\n    this.data = UI.emboxValue(argFunc, UI.safeEquals);\r\n  };\r\n\r\n  block.materialized = function () {\r\n    var self = this;\r\n    if (Deps.active) {\r\n      Deps.onInvalidate(function () {\r\n        self.data.stop();\r\n      });\r\n    }\r\n  };\r\n  block.materialized.isWith = true;\r\n\r\n  return block;\r\n};\r\n\r\nUI.Each = function (argFunc, contentBlock, elseContentBlock) {\r\n  checkBlockHelperArguments('Each', argFunc, contentBlock, elseContentBlock);\r\n\r\n  return UI.EachImpl.extend({\r\n    __sequence: argFunc,\r\n    __content: contentBlock,\r\n    __elseContent: elseContentBlock\r\n  });\r\n};\r\n\r\nvar checkBlockHelperArguments = function (which, argFunc, contentBlock, elseContentBlock) {\r\n  if (typeof argFunc !== 'function')\r\n    throw new Error('First argument to ' + which + ' must be a function');\r\n  if (! UI.isComponent(contentBlock))\r\n    throw new Error('Second argument to ' + which + ' must be a template or UI.block');\r\n  if (elseContentBlock && ! UI.isComponent(elseContentBlock))\r\n    throw new Error('Third argument to ' + which + ' must be a template or UI.block if present');\r\n};\r\n\r\n// Returns a function that computes `!! conditionFunc()` except:\r\n//\r\n// - Empty array is considered falsy\r\n// - The result is UI.emboxValue'd (doesn't trigger invalidation\r\n//   as long as the condition stays truthy or stays falsy)\r\nvar emboxCondition = function (conditionFunc) {\r\n  return UI.namedEmboxValue('if/unless', function () {\r\n    // `condition` is emboxed; it is always a function,\r\n    // and it only triggers invalidation if its return\r\n    // value actually changes.  We still need to isolate\r\n    // the calculation of whether it is truthy or falsy\r\n    // in order to not re-render if it changes from one\r\n    // truthy or falsy value to another.\r\n    var cond = conditionFunc();\r\n\r\n    // empty arrays are treated as falsey values\r\n    if (cond instanceof Array && cond.length === 0)\r\n      return false;\r\n    else\r\n      return !! cond;\r\n  });\r\n};\r\n","UI.EachImpl = Component.extend({\r\n  typeName: 'Each',\r\n  render: function (modeHint) {\r\n    var self = this;\r\n    var content = self.__content;\r\n    var elseContent = self.__elseContent;\r\n\r\n    if (modeHint === 'STATIC') {\r\n      // This is a hack.  The caller gives us a hint if the\r\n      // value we return will be static (in HTML or text)\r\n      // or dynamic (materialized DOM).  The dynamic path\r\n      // returns `null` and then we populate the DOM from\r\n      // the `materialized` callback.\r\n      //\r\n      // It would be much cleaner to always return the same\r\n      // value here, and to have that value be some special\r\n      // object that encapsulates the logic for populating\r\n      // the #each using a mode-agnostic interface that\r\n      // works for HTML, text, and DOM.  Alternatively, we\r\n      // could formalize the current pattern, e.g. defining\r\n      // a method like component.populate(domRange) and one\r\n      // like renderStatic() or even renderHTML / renderText.\r\n      var parts = _.map(\r\n        ObserveSequence.fetch(self.__sequence()),\r\n        function (item) {\r\n          return content.extend({data: function () {\r\n            return item;\r\n          }});\r\n        });\r\n\r\n      if (parts.length) {\r\n        return parts;\r\n      } else {\r\n        return elseContent;\r\n      }\r\n      return parts;\r\n    } else {\r\n      return null;\r\n    }\r\n  },\r\n  materialized: function () {\r\n    var self = this;\r\n\r\n    var range = self.dom;\r\n\r\n    var content = self.__content;\r\n    var elseContent = self.__elseContent;\r\n\r\n    // if there is an else clause, keep track of the number of\r\n    // rendered items.  use this to display the else clause when count\r\n    // becomes zero, and remove it when count becomes positive.\r\n    var itemCount = 0;\r\n    var addToCount = function(delta) {\r\n      if (!elseContent) // if no else, no need to keep track of count\r\n        return;\r\n\r\n      if (itemCount + delta < 0)\r\n        throw new Error(\"count should never become negative\");\r\n\r\n      if (itemCount === 0) {\r\n        // remove else clause\r\n        range.removeAll();\r\n      }\r\n      itemCount += delta;\r\n      if (itemCount === 0) {\r\n        UI.materialize(elseContent, range, null, self);\r\n      }\r\n    };\r\n\r\n    this.observeHandle = ObserveSequence.observe(function () {\r\n      return self.__sequence();\r\n    }, {\r\n      addedAt: function (id, item, i, beforeId) {\r\n        addToCount(1);\r\n        id = LocalCollection._idStringify(id);\r\n\r\n        var data = item;\r\n        var dep = new Deps.Dependency;\r\n\r\n        // function to become `comp.data`\r\n        var dataFunc = function () {\r\n          dep.depend();\r\n          return data;\r\n        };\r\n        // Storing `$set` on `comp.data` lets us\r\n        // access it from `changed`.\r\n        dataFunc.$set = function (v) {\r\n          data = v;\r\n          dep.changed();\r\n        };\r\n\r\n        if (beforeId)\r\n          beforeId = LocalCollection._idStringify(beforeId);\r\n\r\n        var renderedItem = UI.render(content.extend({data: dataFunc}), self);\r\n        range.add(id, renderedItem.dom, beforeId);\r\n      },\r\n      removedAt: function (id, item) {\r\n        addToCount(-1);\r\n        range.remove(LocalCollection._idStringify(id));\r\n      },\r\n      movedTo: function (id, item, i, j, beforeId) {\r\n        range.moveBefore(\r\n          LocalCollection._idStringify(id),\r\n          beforeId && LocalCollection._idStringify(beforeId));\r\n      },\r\n      changedAt: function (id, newItem, atIndex) {\r\n        range.get(LocalCollection._idStringify(id)).component.data.$set(newItem);\r\n      }\r\n    });\r\n\r\n    // on initial render, display the else clause if no items\r\n    addToCount(0);\r\n  },\r\n  destroyed: function () {\r\n    if (this.__component__.observeHandle)\r\n      this.__component__.observeHandle.stop();\r\n  }\r\n});\r\n","\r\nvar global = (function () { return this; })();\r\n\r\n// Searches for the given property in `comp` or a parent,\r\n// and returns it as is (without call it if it's a function).\r\nvar lookupComponentProp = function (comp, prop) {\r\n  comp = findComponentWithProp(prop, comp);\r\n  var result = (comp ? comp.data : null);\r\n  if (typeof result === 'function')\r\n    result = _.bind(result, comp);\r\n  return result;\r\n};\r\n\r\n// Component that's a no-op when used as a block helper like\r\n// `{{#foo}}...{{/foo}}`. Prints a warning that it is deprecated.\r\nvar noOpComponent = function (name) {\r\n  return Component.extend({\r\n    kind: 'NoOp',\r\n    render: function () {\r\n      Meteor._debug(\"{{#\" + name + \"}} is now unnecessary and deprecated.\");\r\n      return this.__content;\r\n    }\r\n  });\r\n};\r\n\r\n// This map is searched first when you do something like `{{#foo}}` in\r\n// a template.\r\nvar builtInComponents = {\r\n  // for past compat:\r\n  'constant': noOpComponent(\"constant\"),\r\n  'isolate': noOpComponent(\"isolate\")\r\n};\r\n\r\n_extend(UI.Component, {\r\n  // Options:\r\n  //\r\n  // - template {Boolean} If true, look at the list of templates after\r\n  //   helpers and before data context.\r\n  lookup: function (id, opts) {\r\n    var self = this;\r\n    var template = opts && opts.template;\r\n    var result;\r\n    var comp;\r\n\r\n    if (!id)\r\n      throw new Error(\"must pass id to lookup\");\r\n\r\n    if (/^\\./.test(id)) {\r\n      // starts with a dot. must be a series of dots which maps to an\r\n      // ancestor of the appropriate height.\r\n      if (!/^(\\.)+$/.test(id)) {\r\n        throw new Error(\"id starting with dot must be a series of dots\");\r\n      }\r\n\r\n      var compWithData = findComponentWithProp('data', self);\r\n      for (var i = 1; i < id.length; i++) {\r\n        compWithData = compWithData ? findComponentWithProp('data', compWithData.parent) : null;\r\n      }\r\n\r\n      return (compWithData ? compWithData.data : null);\r\n\r\n    } else if ((comp = findComponentWithHelper(id, self))) {\r\n      // found a property or method of a component\r\n      // (`self` or one of its ancestors)\r\n      var result = comp[id];\r\n\r\n    } else if (_.has(builtInComponents, id)) {\r\n      return builtInComponents[id];\r\n\r\n    // Code to search the global namespace for capitalized names\r\n    // like component classes, `Template`, `StringUtils.foo`,\r\n    // etc.\r\n    //\r\n    // } else if (/^[A-Z]/.test(id) && (id in global)) {\r\n    //   // Only look for a global identifier if `id` is\r\n    //   // capitalized.  This avoids having `{{name}}` mean\r\n    //   // `window.name`.\r\n    //   result = global[id];\r\n    //   return function (/*arguments*/) {\r\n    //     var data = getComponentData(self);\r\n    //     if (typeof result === 'function')\r\n    //       return result.apply(data, arguments);\r\n    //     return result;\r\n    //   };\r\n    } else if (template && _.has(Template, id)) {\r\n      return Template[id];\r\n\r\n    } else if ((result = UI._globalHelper(id))) {\r\n\r\n    } else {\r\n      // Resolve id `foo` as `data.foo` (with a \"soft dot\").\r\n      return function (/*arguments*/) {\r\n        var data = getComponentData(self);\r\n        if (template && !(data && _.has(data, id)))\r\n          throw new Error(\"Can't find template, helper or data context key: \" + id);\r\n        if (! data)\r\n          return data;\r\n        var result = data[id];\r\n        if (typeof result === 'function')\r\n          return result.apply(data, arguments);\r\n        return result;\r\n      };\r\n    }\r\n\r\n    if (typeof result === 'function' && ! result._isEmboxedConstant) {\r\n      // Wrap the function `result`, binding `this` to `getComponentData(self)`.\r\n      // This creates a dependency when the result function is called.\r\n      // Don't do this if the function is really just an emboxed constant.\r\n      return function (/*arguments*/) {\r\n        var data = getComponentData(self);\r\n        return result.apply(data === null ? {} : data, arguments);\r\n      };\r\n    } else {\r\n      return result;\r\n    };\r\n  },\r\n  lookupTemplate: function (id) {\r\n    return this.lookup(id, {template: true});\r\n  },\r\n  get: function (id) {\r\n    // support `this.get()` to get the data context.\r\n    if (id === undefined)\r\n      id = \".\";\r\n\r\n    var result = this.lookup(id);\r\n    return (typeof result === 'function' ? result() : result);\r\n  },\r\n  set: function (id, value) {\r\n    var comp = findComponentWithProp(id, this);\r\n    if (! comp || ! comp[id])\r\n      throw new Error(\"Can't find field: \" + id);\r\n    if (typeof comp[id] !== 'function')\r\n      throw new Error(\"Not a settable field: \" + id);\r\n    comp[id](value);\r\n  }\r\n});\r\n","// XXX this file no longer makes sense in isolation.  take it apart as\r\n// part file reorg on the 'ui' package\r\nvar globalHelpers = {};\r\n\r\nUI.registerHelper = function (name, func) {\r\n  globalHelpers[name] = func;\r\n};\r\n\r\nUI._globalHelper = function (name) {\r\n  return globalHelpers[name];\r\n};\r\n\r\nHandlebars = {};\r\nHandlebars.registerHelper = UI.registerHelper;\r\n\r\n// Utility to HTML-escape a string.\r\nUI._escape = Handlebars._escape = (function() {\r\n  var escape_map = {\r\n    \"<\": \"&lt;\",\r\n    \">\": \"&gt;\",\r\n    '\"': \"&quot;\",\r\n    \"'\": \"&#x27;\",\r\n    \"`\": \"&#x60;\", /* IE allows backtick-delimited attributes?? */\r\n    \"&\": \"&amp;\"\r\n  };\r\n  var escape_one = function(c) {\r\n    return escape_map[c];\r\n  };\r\n\r\n  return function (x) {\r\n    return x.replace(/[&<>\"'`]/g, escape_one);\r\n  };\r\n})();\r\n\r\n// Return these from {{...}} helpers to achieve the same as returning\r\n// strings from {{{...}}} helpers\r\nHandlebars.SafeString = function(string) {\r\n  this.string = string;\r\n};\r\nHandlebars.SafeString.prototype.toString = function() {\r\n  return this.string.toString();\r\n};\r\n"]}