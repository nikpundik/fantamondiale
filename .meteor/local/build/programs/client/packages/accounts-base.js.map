)]}'
{"version":3,"file":"\\packages\\accounts-base.js","sources":["accounts-base/accounts_common.js","accounts-base/url_client.js","accounts-base/accounts_client.js","accounts-base/localstorage_token.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,c;;AAEA,qE;AACA,4B;AACA,uB;;AAEA,iD;AACA,uC;AACA,8E;AACA,6E;AACA,0D;AACA,mD;AACA,0D;AACA,qD;AACA,gF;AACA,S;AACA,sC;;AAEA,sE;AACA,kB;AACA,E;AACA,qE;AACA,+C;AACA,sE;AACA,oE;AACA,qD;AACA,E;AACA,iD;AACA,oC;AACA,uE;AACA,sB;AACA,0C;AACA,wD;AACA,uD;AACA,sE;AACA,mC;AACA,mC;AACA,yE;AACA,gB;AACA,E;AACA,qC;AACA,yE;AACA,6E;AACA,gF;AACA,2E;AACA,+B;AACA,wB;AACA,0D;AACA,+D;AACA,+E;AACA,sD;AACA,8E;AACA,6E;AACA,G;;AAEA,8D;AACA,oE;AACA,yC;AACA,yC;AACA,wB;AACA,uF;AACA,sC;AACA,2F;AACA,gF;AACA,gD;AACA,G;;AAEA,yB;AACA,2E;AACA,8E;AACA,0C;AACA,uC;AACA,8D;AACA,K;AACA,K;;AAEA,oC;AACA,qC;AACA,yB;AACA,qC;AACA,kE;AACA,c;AACA,8C;AACA,O;AACA,K;AACA,K;;AAEA,6E;AACA,4C;AACA,sB;AACA,oC;AACA,E;;AAEA,sB;AACA,uE;AACA,+D;AACA,uE;AACA,I;AACA,sE;AACA,4D;AACA,6B;AACA,0C;;AAEA,yD;AACA,0D;AACA,uE;AACA,+D;AACA,kE;AACA,gE;AACA,M;AACA,mE;AACA,4D;AACA,sC;AACA,wD;AACA,G;AACA,C;;AAEA,uE;AACA,kE;AACA,qD;AACA,E;AACA,+C;AACA,4B;AACA,uE;AACA,G;AACA,gE;AACA,c;;AAEA,uF;AACA,4B;AACA,4B;AACA,0D;AACA,2E;AACA,0D;AACA,G;;AAEA,sE;AACA,oC;AACA,sD;AACA,6B;AACA,E;;AAEA,6E;AACA,6E;AACA,oC;AACA,sD;AACA,qD;AACA,6E;;AAEA,kC;AACA,oD;AACA,+D;AACA,E;;AAEA,6C;AACA,2E;AACA,gC;AACA,qE;AACA,E;;AAEA,8C;AACA,gD;AACA,4D;AACA,uC;AACA,qC;AACA,uD;AACA,E;;;;;;;;;;;;;;;;;;;ACtKA,wB;;AAEA,qE;AACA,kE;AACA,mE;AACA,S;AACA,E;AACA,oE;AACA,qE;AACA,sB;AACA,U;AACA,iE;AACA,Y;AACA,2B;AACA,0C;AACA,4B;AACA,C;;AAEA,8D;AACA,gE;AACA,wB;AACA,E;AACA,mE;AACA,oE;AACA,+D;AACA,+D;AACA,kE;AACA,2C;AACA,+D;AACA,Y;AACA,2B;AACA,wC;AACA,4B;AACA,C;;AAEA,qE;AACA,gE;AACA,wB;AACA,iE;AACA,Y;AACA,2B;AACA,0C;AACA,4B;AACA,C;;;;;;;;;;;;;;;;;;;AC3CA,G;AACA,gB;AACA,G;;AAEA,oB;AACA,6B;AACA,sC;AACA,E;;AAEA,sB;AACA,wC;AACA,4E;AACA,4E;AACA,mB;AACA,uC;AACA,wB;AACA,kB;AACA,4B;AACA,G;AACA,E;AACA,gC;AACA,yB;AACA,mB;AACA,E;;AAEA,wC;AACA,2B;AACA,+B;AACA,c;AACA,gB;AACA,sC;AACA,E;;AAEA,G;AACA,iB;AACA,G;;AAEA,qC;AACA,E;AACA,6E;AACA,4E;AACA,0E;AACA,6B;AACA,E;AACA,+B;AACA,2D;AACA,wC;AACA,0D;AACA,0D;AACA,2D;AACA,uB;AACA,E;AACA,W;AACA,qD;AACA,kD;AACA,uE;AACA,8E;AACA,6D;AACA,0E;AACA,yD;AACA,E;AACA,+C;AACA,sB;AACA,wB;AACA,wB;AACA,6B;AACA,c;AACA,yE;AACA,gC;AACA,2D;AACA,oB;AACA,kC;AACA,K;AACA,qD;AACA,sD;;AAEA,0B;;AAEA,6E;AACA,2E;AACA,0E;AACA,wE;AACA,2E;AACA,yE;AACA,yE;AACA,0C;AACA,I;AACA,0E;AACA,4E;AACA,4E;AACA,2E;AACA,gE;AACA,iD;AACA,0C;AACA,6C;AACA,Y;AACA,qD;AACA,2B;AACA,mE;AACA,6C;AACA,0B;AACA,oB;AACA,+B;AACA,mD;AACA,Y;AACA,S;AACA,kC;AACA,sE;AACA,8D;AACA,gC;AACA,gB;AACA,oC;AACA,sD;AACA,wE;AACA,+E;AACA,mD;AACA,qC;AACA,4C;AACA,sD;AACA,0B;AACA,8E;AACA,2E;AACA,6E;AACA,6E;AACA,+E;AACA,gF;AACA,6E;AACA,8E;AACA,6E;AACA,gF;AACA,gF;AACA,kB;AACA,8E;AACA,gF;AACA,0E;AACA,6E;AACA,0E;AACA,wE;AACA,wC;AACA,iB;AACA,e;AACA,8E;AACA,+E;AACA,wB;AACA,sC;AACA,gB;AACA,S;AACA,Q;AACA,K;AACA,I;;AAEA,qE;AACA,6E;AACA,U;AACA,+D;AACA,wE;AACA,2E;AACA,2E;AACA,yD;AACA,0E;AACA,oB;AACA,a;;AAEA,yE;AACA,gE;AACA,iD;AACA,kC;AACA,2B;AACA,iC;AACA,wD;AACA,8B;AACA,a;AACA,K;AACA,S;AACA,qC;AACA,iB;AACA,0B;AACA,a;AACA,K;;AAEA,2E;AACA,qE;AACA,uB;AACA,I;;AAEA,kC;AACA,iC;AACA,4B;AACA,uB;AACA,4B;AACA,qD;AACA,kC;AACA,E;;AAEA,kC;AACA,sB;AACA,sC;AACA,yC;AACA,E;;AAEA,4D;AACA,+C;AACA,wC;AACA,E;;AAEA,qC;AACA,iF;AACA,gB;AACA,kC;AACA,Y;AACA,4B;AACA,6B;AACA,K;AACA,K;AACA,E;;AAEA,iD;AACA,wE;AACA,wE;AACA,kE;AACA,sE;AACA,uE;AACA,uE;AACA,+D;AACA,qE;AACA,+B;AACA,I;AACA,sE;AACA,qE;AACA,6D;AACA,uE;AACA,wE;AACA,2B;AACA,4B;AACA,kB;AACA,O;AACA,mB;AACA,4B;AACA,kB;AACA,4E;AACA,O;AACA,K;AACA,I;AACA,4B;AACA,wB;AACA,O;AACA,mB;AACA,oB;AACA,gC;AACA,K;AACA,I;AACA,E;;;AAGA,G;AACA,kB;AACA,G;;AAEA,yB;AACA,oE;;AAEA,sE;AACA,sE;AACA,6C;AACA,E;AACA,gD;AACA,qC;AACA,E;;AAEA,G;AACA,sB;AACA,G;;AAEA,sE;AACA,kB;AACA,iB;AACA,2D;AACA,yB;AACA,K;AACA,yD;AACA,8B;AACA,K;AACA,C;;;;;;;;;;;;;;;;;;;AC1RA,gE;AACA,oE;AACA,uE;AACA,W;;AAEA,6B;;AAEA,qE;AACA,Q;AACA,oD;AACA,4B;AACA,uC;AACA,6B;AACA,E;;AAEA,sE;AACA,iC;AACA,yC;AACA,0B;AACA,yB;AACA,E;;;AAGA,G;AACA,W;AACA,G;;AAEA,mC;AACA,wC;AACA,sD;AACA,gC;;AAEA,uE;AACA,sE;AACA,kE;AACA,kD;AACA,8C;AACA,sC;AACA,E;;AAEA,yD;AACA,kD;AACA,qD;AACA,qB;AACA,yD;AACA,mE;;AAEA,oE;AACA,0B;AACA,mC;AACA,E;;AAEA,gC;AACA,6C;AACA,iD;AACA,wD;;AAEA,oE;AACA,0B;AACA,kC;AACA,E;;AAEA,sE;AACA,6B;AACA,E;AACA,4D;AACA,qD;AACA,E;;AAEA,uC;AACA,4D;AACA,E;;AAEA,+B;AACA,iD;AACA,E;;AAEA,kD;AACA,wE;AACA,yE;AACA,wB;AACA,E;;AAEA,G;AACA,c;AACA,G;;AAEA,uB;AACA,iE;AACA,iE;AACA,mC;AACA,iC;AACA,c;AACA,mE;AACA,kE;AACA,gC;AACA,oD;AACA,iD;AACA,gB;AACA,6D;AACA,8B;AACA,O;AACA,O;AACA,G;AACA,C;;AAEA,sE;AACA,c;AACA,iC;AACA,uC;AACA,yB;AACA,W;;AAEA,6C;;AAEA,gF;AACA,sD;AACA,4B;AACA,+D;AACA,gB;AACA,gC;AACA,S;AACA,Y;AACA,sB;AACA,K;AACA,G;AACA,+C;AACA,E;;AAEA,wC","sourcesContent":["Accounts = {};\r\n\r\n// Currently this is read directly by packages like accounts-password\r\n// and accounts-ui-unstyled.\r\nAccounts._options = {};\r\n\r\n// how long (in days) until a login token expires\r\nvar DEFAULT_LOGIN_EXPIRATION_DAYS = 90;\r\n// Clients don't try to auto-login with a token that is going to expire within\r\n// .1 * DEFAULT_LOGIN_EXPIRATION_DAYS, capped at MIN_TOKEN_LIFETIME_CAP_SECS.\r\n// Tries to avoid abrupt disconnects from expiring tokens.\r\nvar MIN_TOKEN_LIFETIME_CAP_SECS = 3600; // one hour\r\n// how often (in milliseconds) we check for expired tokens\r\nEXPIRE_TOKENS_INTERVAL_MS = 600 * 1000; // 10 minutes\r\n// how long we wait before logging out clients when Meteor.logoutOtherClients is\r\n// called\r\nCONNECTION_CLOSE_DELAY_MS = 10 * 1000;\r\n\r\n// Set up config for the accounts system. Call this on both the client\r\n// and the server.\r\n//\r\n// XXX we should add some enforcement that this is called on both the\r\n// client and the server. Otherwise, a user can\r\n// 'forbidClientAccountCreation' only on the client and while it looks\r\n// like their app is secure, the server will still accept createUser\r\n// calls. https://github.com/meteor/meteor/issues/828\r\n//\r\n// @param options {Object} an object with fields:\r\n// - sendVerificationEmail {Boolean}\r\n//     Send email address verification emails to new users created from\r\n//     client signups.\r\n// - forbidClientAccountCreation {Boolean}\r\n//     Do not allow clients to create accounts directly.\r\n// - restrictCreationByEmailDomain {Function or String}\r\n//     Require created users to have an email matching the function or\r\n//     having the string as domain.\r\n// - loginExpirationInDays {Number}\r\n//     Number of days since login until a user is logged out (login token\r\n//     expires).\r\n//\r\nAccounts.config = function(options) {\r\n  // We don't want users to accidentally only call Accounts.config on the\r\n  // client, where some of the options will have partial effects (eg removing\r\n  // the \"create account\" button from accounts-ui if forbidClientAccountCreation\r\n  // is set, or redirecting Google login to a specific-domain page) without\r\n  // having their full effects.\r\n  if (Meteor.isServer) {\r\n    __meteor_runtime_config__.accountsConfigCalled = true;\r\n  } else if (!__meteor_runtime_config__.accountsConfigCalled) {\r\n    // XXX would be nice to \"crash\" the client and replace the UI with an error\r\n    // message, but there's no trivial way to do this.\r\n    Meteor._debug(\"Accounts.config was called on the client but not on the \" +\r\n                  \"server; some configuration options may not take effect.\");\r\n  }\r\n\r\n  // We need to validate the oauthSecretKey option at the time\r\n  // Accounts.config is called. We also deliberately don't store the\r\n  // oauthSecretKey in Accounts._options.\r\n  if (_.has(options, \"oauthSecretKey\")) {\r\n    if (Meteor.isClient)\r\n      throw new Error(\"The oauthSecretKey option may only be specified on the server\");\r\n    if (! Package[\"oauth-encryption\"])\r\n      throw new Error(\"The oauth-encryption package must be loaded to set oauthSecretKey\");\r\n    Package[\"oauth-encryption\"].OAuthEncryption.loadKey(options.oauthSecretKey);\r\n    options = _.omit(options, \"oauthSecretKey\");\r\n  }\r\n\r\n  // validate option keys\r\n  var VALID_KEYS = [\"sendVerificationEmail\", \"forbidClientAccountCreation\",\r\n                    \"restrictCreationByEmailDomain\", \"loginExpirationInDays\"];\r\n  _.each(_.keys(options), function (key) {\r\n    if (!_.contains(VALID_KEYS, key)) {\r\n      throw new Error(\"Accounts.config: Invalid key: \" + key);\r\n    }\r\n  });\r\n\r\n  // set values in Accounts._options\r\n  _.each(VALID_KEYS, function (key) {\r\n    if (key in options) {\r\n      if (key in Accounts._options) {\r\n        throw new Error(\"Can't set `\" + key + \"` more than once\");\r\n      } else {\r\n        Accounts._options[key] = options[key];\r\n      }\r\n    }\r\n  });\r\n\r\n  // If the user set loginExpirationInDays to null, then we need to clear the\r\n  // timer that periodically expires tokens.\r\n  if (Meteor.isServer)\r\n    maybeStopExpireTokensInterval();\r\n};\r\n\r\nif (Meteor.isClient) {\r\n  // The connection used by the Accounts system. This is the connection\r\n  // that will get logged in by Meteor.login(), and this is the\r\n  // connection whose login state will be reflected by Meteor.userId().\r\n  //\r\n  // It would be much preferable for this to be in accounts_client.js,\r\n  // but it has to be here because it's needed to create the\r\n  // Meteor.users collection.\r\n  Accounts.connection = Meteor.connection;\r\n\r\n  if (typeof __meteor_runtime_config__ !== \"undefined\" &&\r\n      __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL) {\r\n    // Temporary, internal hook to allow the server to point the client\r\n    // to a different authentication server. This is for a very\r\n    // particular use case that comes up when implementing a oauth\r\n    // server. Unsupported and may go away at any point in time.\r\n    //\r\n    // We will eventually provide a general way to use account-base\r\n    // against any DDP connection, not just one special one.\r\n    Accounts.connection = DDP.connect(\r\n      __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL)\r\n  }\r\n}\r\n\r\n// Users table. Don't use the normal autopublish, since we want to hide\r\n// some fields. Code to autopublish this is in accounts_server.js.\r\n// XXX Allow users to configure this collection name.\r\n//\r\nMeteor.users = new Meteor.Collection(\"users\", {\r\n  _preventAutopublish: true,\r\n  connection: Meteor.isClient ? Accounts.connection : Meteor.connection\r\n});\r\n// There is an allow call in accounts_server that restricts this\r\n// collection.\r\n\r\n// loginServiceConfiguration and ConfigError are maintained for backwards compatibility\r\nMeteor.startup(function () {\r\n  var ServiceConfiguration =\r\n    Package['service-configuration'].ServiceConfiguration;\r\n  Accounts.loginServiceConfiguration = ServiceConfiguration.configurations;\r\n  Accounts.ConfigError = ServiceConfiguration.ConfigError;\r\n});\r\n\r\n// Thrown when the user cancels the login process (eg, closes an oauth\r\n// popup, declines retina scan, etc)\r\nAccounts.LoginCancelledError = function(description) {\r\n  this.message = description;\r\n};\r\n\r\n// This is used to transmit specific subclass errors over the wire. We should\r\n// come up with a more generic way to do this (eg, with some sort of symbolic\r\n// error code rather than a number).\r\nAccounts.LoginCancelledError.numericError = 0x8acdc2f;\r\nAccounts.LoginCancelledError.prototype = new Error();\r\nAccounts.LoginCancelledError.prototype.name = 'Accounts.LoginCancelledError';\r\n\r\ngetTokenLifetimeMs = function () {\r\n  return (Accounts._options.loginExpirationInDays ||\r\n          DEFAULT_LOGIN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\r\n};\r\n\r\nAccounts._tokenExpiration = function (when) {\r\n  // We pass when through the Date constructor for backwards compatibility;\r\n  // `when` used to be a number.\r\n  return new Date((new Date(when)).getTime() + getTokenLifetimeMs());\r\n};\r\n\r\nAccounts._tokenExpiresSoon = function (when) {\r\n  var minLifetimeMs = .1 * getTokenLifetimeMs();\r\n  var minLifetimeCapMs = MIN_TOKEN_LIFETIME_CAP_SECS * 1000;\r\n  if (minLifetimeMs > minLifetimeCapMs)\r\n    minLifetimeMs = minLifetimeCapMs;\r\n  return new Date() > (new Date(when) - minLifetimeMs);\r\n};\r\n","autoLoginEnabled = true;\r\n\r\n// reads a reset password token from the url's hash fragment, if it's\r\n// there. if so prevent automatically logging in since it could be\r\n// confusing to be logged in as user A while resetting password for\r\n// user B\r\n//\r\n// reset password urls use hash fragments instead of url paths/query\r\n// strings so that the reset password token is not sent over the wire\r\n// on the http request\r\nvar match;\r\nmatch = window.location.hash.match(/^\\#\\/reset-password\\/(.*)$/);\r\nif (match) {\r\n  autoLoginEnabled = false;\r\n  Accounts._resetPasswordToken = match[1];\r\n  window.location.hash = '';\r\n}\r\n\r\n// reads a verify email token from the url's hash fragment, if\r\n// it's there.  also don't automatically log the user is, as for\r\n// reset password links.\r\n//\r\n// XXX we don't need to use hash fragments in this case, and having\r\n// the token appear in the url's path would allow us to use a custom\r\n// middleware instead of verifying the email on pageload, which\r\n// would be faster but less DDP-ish (and more specifically, any\r\n// non-web DDP app, such as an iOS client, would do something more\r\n// in line with the hash fragment approach)\r\nmatch = window.location.hash.match(/^\\#\\/verify-email\\/(.*)$/);\r\nif (match) {\r\n  autoLoginEnabled = false;\r\n  Accounts._verifyEmailToken = match[1];\r\n  window.location.hash = '';\r\n}\r\n\r\n// reads an account enrollment token from the url's hash fragment, if\r\n// it's there.  also don't automatically log the user is, as for\r\n// reset password links.\r\nmatch = window.location.hash.match(/^\\#\\/enroll-account\\/(.*)$/);\r\nif (match) {\r\n  autoLoginEnabled = false;\r\n  Accounts._enrollAccountToken = match[1];\r\n  window.location.hash = '';\r\n}\r\n","///\r\n/// CURRENT USER\r\n///\r\n\r\n// This is reactive.\r\nMeteor.userId = function () {\r\n  return Accounts.connection.userId();\r\n};\r\n\r\nvar loggingIn = false;\r\nvar loggingInDeps = new Deps.Dependency;\r\n// This is mostly just called within this file, but Meteor.loginWithPassword\r\n// also uses it to make loggingIn() be true during the beginPasswordExchange\r\n// method call too.\r\nAccounts._setLoggingIn = function (x) {\r\n  if (loggingIn !== x) {\r\n    loggingIn = x;\r\n    loggingInDeps.changed();\r\n  }\r\n};\r\nMeteor.loggingIn = function () {\r\n  loggingInDeps.depend();\r\n  return loggingIn;\r\n};\r\n\r\n// This calls userId, which is reactive.\r\nMeteor.user = function () {\r\n  var userId = Meteor.userId();\r\n  if (!userId)\r\n    return null;\r\n  return Meteor.users.findOne(userId);\r\n};\r\n\r\n///\r\n/// LOGIN METHODS\r\n///\r\n\r\n// Call a login method on the server.\r\n//\r\n// A login method is a method which on success calls `this.setUserId(id)` and\r\n// `Accounts._setLoginToken` on the server and returns an object with fields\r\n// 'id' (containing the user id), 'token' (containing a resume token), and\r\n// optionally `tokenExpires`.\r\n//\r\n// This function takes care of:\r\n//   - Updating the Meteor.loggingIn() reactive data source\r\n//   - Calling the method in 'wait' mode\r\n//   - On success, saving the resume token to localStorage\r\n//   - On success, calling Accounts.connection.setUserId()\r\n//   - Setting up an onReconnect handler which logs in with\r\n//     the resume token\r\n//\r\n// Options:\r\n// - methodName: The method to call (default 'login')\r\n// - methodArguments: The arguments for the method\r\n// - validateResult: If provided, will be called with the result of the\r\n//                 method. If it throws, the client will not be logged in (and\r\n//                 its error will be passed to the callback).\r\n// - userCallback: Will be called with no arguments once the user is fully\r\n//                 logged in, or with the error on error.\r\n//\r\nAccounts.callLoginMethod = function (options) {\r\n  options = _.extend({\r\n    methodName: 'login',\r\n    methodArguments: [],\r\n    _suppressLoggingIn: false\r\n  }, options);\r\n  // Set defaults for callback arguments to no-op functions; make sure we\r\n  // override falsey values too.\r\n  _.each(['validateResult', 'userCallback'], function (f) {\r\n    if (!options[f])\r\n      options[f] = function () {};\r\n  });\r\n  // make sure we only call the user's callback once.\r\n  var onceUserCallback = _.once(options.userCallback);\r\n\r\n  var reconnected = false;\r\n\r\n  // We want to set up onReconnect as soon as we get a result token back from\r\n  // the server, without having to wait for subscriptions to rerun. This is\r\n  // because if we disconnect and reconnect between getting the result and\r\n  // getting the results of subscription rerun, we WILL NOT re-send this\r\n  // method (because we never re-send methods whose results we've received)\r\n  // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\r\n  // time. This will lead to makeClientLoggedIn(result.id) even though we\r\n  // haven't actually sent a login method!\r\n  //\r\n  // But by making sure that we send this \"resume\" login in that case (and\r\n  // calling makeClientLoggedOut if it fails), we'll end up with an accurate\r\n  // client-side userId. (It's important that livedata_connection guarantees\r\n  // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\r\n  // will occur before the callback from the resume login call.)\r\n  var onResultReceived = function (err, result) {\r\n    if (err || !result || !result.token) {\r\n      Accounts.connection.onReconnect = null;\r\n    } else {\r\n      Accounts.connection.onReconnect = function () {\r\n        reconnected = true;\r\n        // If our token was updated in storage, use the latest one.\r\n        var storedToken = storedLoginToken();\r\n        if (storedToken) {\r\n          result = {\r\n            token: storedToken,\r\n            tokenExpires: storedLoginTokenExpires()\r\n          };\r\n        }\r\n        if (! result.tokenExpires)\r\n          result.tokenExpires = Accounts._tokenExpiration(new Date());\r\n        if (Accounts._tokenExpiresSoon(result.tokenExpires)) {\r\n          makeClientLoggedOut();\r\n        } else {\r\n          Accounts.callLoginMethod({\r\n            methodArguments: [{resume: result.token}],\r\n            // Reconnect quiescence ensures that the user doesn't see an\r\n            // intermediate state before the login method finishes. So we don't\r\n            // need to show a logging-in animation.\r\n            _suppressLoggingIn: true,\r\n            userCallback: function (error) {\r\n              var storedTokenNow = storedLoginToken();\r\n              if (error) {\r\n                // If we had a login error AND the current stored token is the\r\n                // one that we tried to log in with, then declare ourselves\r\n                // logged out. If there's a token in storage but it's not the\r\n                // token that we tried to log in with, we don't know anything\r\n                // about whether that token is valid or not, so do nothing. The\r\n                // periodic localStorage poll will decide if we are logged in or\r\n                // out with this token, if it hasn't already. Of course, even\r\n                // with this check, another tab could insert a new valid token\r\n                // immediately before we clear localStorage here, which would\r\n                // lead to both tabs being logged out, but by checking the token\r\n                // in storage right now we hope to make that unlikely to happen.\r\n                //\r\n                // If there is no token in storage right now, we don't have to\r\n                // do anything; whatever code removed the token from storage was\r\n                // responsible for calling `makeClientLoggedOut()`, or the\r\n                // periodic localStorage poll will call `makeClientLoggedOut`\r\n                // eventually if another tab wiped the token from storage.\r\n                if (storedTokenNow && storedTokenNow === result.token) {\r\n                  makeClientLoggedOut();\r\n                }\r\n              }\r\n              // Possibly a weird callback to call, but better than nothing if\r\n              // there is a reconnect between \"login result received\" and \"data\r\n              // ready\".\r\n              onceUserCallback(error);\r\n            }});\r\n        }\r\n      };\r\n    }\r\n  };\r\n\r\n  // This callback is called once the local cache of the current-user\r\n  // subscription (and all subscriptions, in fact) are guaranteed to be up to\r\n  // date.\r\n  var loggedInAndDataReadyCallback = function (error, result) {\r\n    // If the login method returns its result but the connection is lost\r\n    // before the data is in the local cache, it'll set an onReconnect (see\r\n    // above). The onReconnect will try to log in using the token, and *it*\r\n    // will call userCallback via its own version of this\r\n    // loggedInAndDataReadyCallback. So we don't have to do anything here.\r\n    if (reconnected)\r\n      return;\r\n\r\n    // Note that we need to call this even if _suppressLoggingIn is true,\r\n    // because it could be matching a _setLoggingIn(true) from a\r\n    // half-completed pre-reconnect login method.\r\n    Accounts._setLoggingIn(false);\r\n    if (error || !result) {\r\n      error = error || new Error(\r\n        \"No result from call to \" + options.methodName);\r\n      onceUserCallback(error);\r\n      return;\r\n    }\r\n    try {\r\n      options.validateResult(result);\r\n    } catch (e) {\r\n      onceUserCallback(e);\r\n      return;\r\n    }\r\n\r\n    // Make the client logged in. (The user data should already be loaded!)\r\n    makeClientLoggedIn(result.id, result.token, result.tokenExpires);\r\n    onceUserCallback();\r\n  };\r\n\r\n  if (!options._suppressLoggingIn)\r\n    Accounts._setLoggingIn(true);\r\n  Accounts.connection.apply(\r\n    options.methodName,\r\n    options.methodArguments,\r\n    {wait: true, onResultReceived: onResultReceived},\r\n    loggedInAndDataReadyCallback);\r\n};\r\n\r\nmakeClientLoggedOut = function() {\r\n  unstoreLoginToken();\r\n  Accounts.connection.setUserId(null);\r\n  Accounts.connection.onReconnect = null;\r\n};\r\n\r\nmakeClientLoggedIn = function(userId, token, tokenExpires) {\r\n  storeLoginToken(userId, token, tokenExpires);\r\n  Accounts.connection.setUserId(userId);\r\n};\r\n\r\nMeteor.logout = function (callback) {\r\n  Accounts.connection.apply('logout', [], {wait: true}, function(error, result) {\r\n    if (error) {\r\n      callback && callback(error);\r\n    } else {\r\n      makeClientLoggedOut();\r\n      callback && callback();\r\n    }\r\n  });\r\n};\r\n\r\nMeteor.logoutOtherClients = function (callback) {\r\n  // We need to make two method calls: one to replace our current token,\r\n  // and another to remove all tokens except the current one. We want to\r\n  // call these two methods one after the other, without any other\r\n  // methods running between them. For example, we don't want `logout`\r\n  // to be called in between our two method calls (otherwise the second\r\n  // method call would return an error). Another example: we don't want\r\n  // logout to be called before the callback for `getNewToken`;\r\n  // otherwise we would momentarily log the user out and then write a\r\n  // new token to localStorage.\r\n  //\r\n  // To accomplish this, we make both calls as wait methods, and queue\r\n  // them one after the other, without spinning off the event loop in\r\n  // between. Even though we queue `removeOtherTokens` before\r\n  // `getNewToken`, we won't actually send the `removeOtherTokens` call\r\n  // until the `getNewToken` callback has finished running, because they\r\n  // are both wait methods.\r\n  Accounts.connection.apply(\r\n    'getNewToken',\r\n    [],\r\n    { wait: true },\r\n    function (err, result) {\r\n      if (! err) {\r\n        storeLoginToken(Meteor.userId(), result.token, result.tokenExpires);\r\n      }\r\n    }\r\n  );\r\n  Accounts.connection.apply(\r\n    'removeOtherTokens',\r\n    [],\r\n    { wait: true },\r\n    function (err) {\r\n      callback && callback(err);\r\n    }\r\n  );\r\n};\r\n\r\n\r\n///\r\n/// LOGIN SERVICES\r\n///\r\n\r\nvar loginServicesHandle =\r\n  Accounts.connection.subscribe(\"meteor.loginServiceConfiguration\");\r\n\r\n// A reactive function returning whether the loginServiceConfiguration\r\n// subscription is ready. Used by accounts-ui to hide the login button\r\n// until we have all the configuration loaded\r\n//\r\nAccounts.loginServicesConfigured = function () {\r\n  return loginServicesHandle.ready();\r\n};\r\n\r\n///\r\n/// HANDLEBARS HELPERS\r\n///\r\n\r\n// If our app has a UI, register the {{currentUser}} and {{loggingIn}}\r\n// global helpers.\r\nif (Package.ui) {\r\n  Package.ui.UI.registerHelper('currentUser', function () {\r\n    return Meteor.user();\r\n  });\r\n  Package.ui.UI.registerHelper('loggingIn', function () {\r\n    return Meteor.loggingIn();\r\n  });\r\n}\r\n","// This file deals with storing a login token and user id in the\r\n// browser's localStorage facility. It polls local storage every few\r\n// seconds to synchronize login state between multiple tabs in the same\r\n// browser.\r\n\r\nvar lastLoginTokenWhenPolled;\r\n\r\n// Login with a Meteor access token. This is the only public function\r\n// here.\r\nMeteor.loginWithToken = function (token, callback) {\r\n  Accounts.callLoginMethod({\r\n    methodArguments: [{resume: token}],\r\n    userCallback: callback});\r\n};\r\n\r\n// Semi-internal API. Call this function to re-enable auto login after\r\n// if it was disabled at startup.\r\nAccounts._enableAutoLogin = function () {\r\n  autoLoginEnabled = true;\r\n  pollStoredLoginToken();\r\n};\r\n\r\n\r\n///\r\n/// STORING\r\n///\r\n\r\n// Key names to use in localStorage\r\nvar loginTokenKey = \"Meteor.loginToken\";\r\nvar loginTokenExpiresKey = \"Meteor.loginTokenExpires\";\r\nvar userIdKey = \"Meteor.userId\";\r\n\r\n// Call this from the top level of the test file for any test that does\r\n// logging in and out, to protect multiple tabs running the same tests\r\n// simultaneously from interfering with each others' localStorage.\r\nAccounts._isolateLoginTokenForTest = function () {\r\n  loginTokenKey = loginTokenKey + Random.id();\r\n  userIdKey = userIdKey + Random.id();\r\n};\r\n\r\nstoreLoginToken = function(userId, token, tokenExpires) {\r\n  Meteor._localStorage.setItem(userIdKey, userId);\r\n  Meteor._localStorage.setItem(loginTokenKey, token);\r\n  if (! tokenExpires)\r\n    tokenExpires = Accounts._tokenExpiration(new Date());\r\n  Meteor._localStorage.setItem(loginTokenExpiresKey, tokenExpires);\r\n\r\n  // to ensure that the localstorage poller doesn't end up trying to\r\n  // connect a second time\r\n  lastLoginTokenWhenPolled = token;\r\n};\r\n\r\nunstoreLoginToken = function() {\r\n  Meteor._localStorage.removeItem(userIdKey);\r\n  Meteor._localStorage.removeItem(loginTokenKey);\r\n  Meteor._localStorage.removeItem(loginTokenExpiresKey);\r\n\r\n  // to ensure that the localstorage poller doesn't end up trying to\r\n  // connect a second time\r\n  lastLoginTokenWhenPolled = null;\r\n};\r\n\r\n// This is private, but it is exported for now because it is used by a\r\n// test in accounts-password.\r\n//\r\nstoredLoginToken = Accounts._storedLoginToken = function() {\r\n  return Meteor._localStorage.getItem(loginTokenKey);\r\n};\r\n\r\nstoredLoginTokenExpires = function () {\r\n  return Meteor._localStorage.getItem(loginTokenExpiresKey);\r\n};\r\n\r\nvar storedUserId = function() {\r\n  return Meteor._localStorage.getItem(userIdKey);\r\n};\r\n\r\nvar unstoreLoginTokenIfExpiresSoon = function () {\r\n  var tokenExpires = Meteor._localStorage.getItem(loginTokenExpiresKey);\r\n  if (tokenExpires && Accounts._tokenExpiresSoon(new Date(tokenExpires)))\r\n    unstoreLoginToken();\r\n};\r\n\r\n///\r\n/// AUTO-LOGIN\r\n///\r\n\r\nif (autoLoginEnabled) {\r\n  // Immediately try to log in via local storage, so that any DDP\r\n  // messages are sent after we have established our user account\r\n  unstoreLoginTokenIfExpiresSoon();\r\n  var token = storedLoginToken();\r\n  if (token) {\r\n    // On startup, optimistically present us as logged in while the\r\n    // request is in flight. This reduces page flicker on startup.\r\n    var userId = storedUserId();\r\n    userId && Accounts.connection.setUserId(userId);\r\n    Meteor.loginWithToken(token, function (err) {\r\n      if (err) {\r\n        Meteor._debug(\"Error logging in with token: \" + err);\r\n        makeClientLoggedOut();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// Poll local storage every 3 seconds to login if someone logged in in\r\n// another tab\r\nlastLoginTokenWhenPolled = token;\r\nvar pollStoredLoginToken = function() {\r\n  if (! autoLoginEnabled)\r\n    return;\r\n\r\n  var currentLoginToken = storedLoginToken();\r\n\r\n  // != instead of !== just to make sure undefined and null are treated the same\r\n  if (lastLoginTokenWhenPolled != currentLoginToken) {\r\n    if (currentLoginToken) {\r\n      Meteor.loginWithToken(currentLoginToken, function (err) {\r\n        if (err)\r\n          makeClientLoggedOut();\r\n      });\r\n    } else {\r\n      Meteor.logout();\r\n    }\r\n  }\r\n  lastLoginTokenWhenPolled = currentLoginToken;\r\n};\r\n\r\nsetInterval(pollStoredLoginToken, 3000);\r\n"]}